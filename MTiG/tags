!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.8	//
B230400	cmtdef.h	45;"	d
B230400	cmtdef.h	46;"	d
B460800	cmtdef.h	47;"	d
B921600	cmtdef.h	48;"	d
CC	Makefile	/^CC=g++$/;"	m
CFLAGS	Makefile	/^CFLAGS=-I. -Wall$/;"	m
CHECKIFDOUBLE	cmtpacket.cpp	43;"	d	file:
CHKDELNUL	xsens_std.h	135;"	d
CHKFREENUL	xsens_std.h	144;"	d
CLOCK_REALTIME	xsens_time.cpp	35;"	d	file:
CMT1LOG	cmt1.cpp	150;"	d	file:
CMT1LOG	cmt1.cpp	152;"	d	file:
CMT1_DEFAULT_TIMEOUT	cmtdef.h	835;"	d
CMT1_H	cmt1.h	22;"	d
CMT2LOG	cmt2.cpp	30;"	d	file:
CMT2_DATA_QUEUE_SIZE	cmtdef.h	830;"	d
CMT2_DEFAULT_TIMEOUT	cmtdef.h	837;"	d
CMT2_H	cmt2.h	22;"	d
CMT3EXITLOG	cmt3.cpp	33;"	d	file:
CMT3EXITLOG	cmt3.cpp	36;"	d	file:
CMT3EXITLOGDAT	cmt3.cpp	44;"	d	file:
CMT3F_DEVINFO_SIZE	cmt3.cpp	47;"	d	file:
CMT3LOG	cmt3.cpp	32;"	d	file:
CMT3LOG	cmt3.cpp	35;"	d	file:
CMT3LOGDAT	cmt3.cpp	43;"	d	file:
CMT3_CONFIG_TIMEOUT	cmtdef.h	833;"	d
CMT3_DEFAULT_TIMEOUT_CONF	cmtdef.h	841;"	d
CMT3_DEFAULT_TIMEOUT_MEAS	cmtdef.h	839;"	d
CMT3_H	cmt3.h	22;"	d
CMT4_CONFIGWAIT_TIMEOUT	cmtdef.h	851;"	d
CMT4_DEFAULT_TIMEOUT_CONF	cmtdef.h	845;"	d
CMT4_DEFAULT_TIMEOUT_DATA	cmtdef.h	849;"	d
CMT4_DEFAULT_TIMEOUT_MEAS	cmtdef.h	843;"	d
CMT4_MEASUREMENT_REQ_TIMEOUT	cmtdef.h	847;"	d
CMTDEF_H	cmtdef.h	31;"	d
CMTEXITLOG	cmt1.h	49;"	d
CMTLOG	cmt1.cpp	/^void CMTLOG(const char *str, ...)$/;"	f	namespace:xsens
CMTMESSAGE_H	cmtmessage.h	22;"	d
CMTPACKET_H	cmtpacket.h	28;"	d
CMTSCAN_H	cmtscan.h	29;"	d
CMT_AUTO_SAVE_FRAMES	cmtdef.h	1230;"	d
CMT_BAUDCODE_115K2	cmtdef.h	555;"	d
CMT_BAUDCODE_19K2	cmtdef.h	550;"	d
CMT_BAUDCODE_230K4	cmtdef.h	556;"	d
CMT_BAUDCODE_38K4	cmtdef.h	552;"	d
CMT_BAUDCODE_460K8	cmtdef.h	557;"	d
CMT_BAUDCODE_4K8	cmtdef.h	547;"	d
CMT_BAUDCODE_57K6	cmtdef.h	553;"	d
CMT_BAUDCODE_921K6	cmtdef.h	559;"	d
CMT_BAUDCODE_921K6_ALT	cmtdef.h	558;"	d
CMT_BAUDCODE_9K6	cmtdef.h	548;"	d
CMT_BAUD_RATE_115K2	cmtdef.h	782;"	d
CMT_BAUD_RATE_115K2	cmtdef.h	794;"	d
CMT_BAUD_RATE_19K2	cmtdef.h	778;"	d
CMT_BAUD_RATE_19K2	cmtdef.h	790;"	d
CMT_BAUD_RATE_230K4	cmtdef.h	783;"	d
CMT_BAUD_RATE_230K4	cmtdef.h	795;"	d
CMT_BAUD_RATE_38K4	cmtdef.h	780;"	d
CMT_BAUD_RATE_38K4	cmtdef.h	792;"	d
CMT_BAUD_RATE_460K8	cmtdef.h	784;"	d
CMT_BAUD_RATE_460K8	cmtdef.h	796;"	d
CMT_BAUD_RATE_4800	cmtdef.h	775;"	d
CMT_BAUD_RATE_4800	cmtdef.h	787;"	d
CMT_BAUD_RATE_57K6	cmtdef.h	781;"	d
CMT_BAUD_RATE_57K6	cmtdef.h	793;"	d
CMT_BAUD_RATE_921K6	cmtdef.h	785;"	d
CMT_BAUD_RATE_921K6	cmtdef.h	797;"	d
CMT_BAUD_RATE_9600	cmtdef.h	776;"	d
CMT_BAUD_RATE_9600	cmtdef.h	788;"	d
CMT_BID_BROADCAST	cmtdef.h	1233;"	d
CMT_BID_INVALID	cmtdef.h	1234;"	d
CMT_BID_MASTER	cmtdef.h	82;"	d
CMT_BID_MT	cmtdef.h	83;"	d
CMT_BUNDLE_QUEUE_SIZE	cmtdef.h	820;"	d
CMT_CALLBACK_COUNT	cmtdef.h	/^	CMT_CALLBACK_COUNT					\/\/!< Not a callback function. Used internally for list management$/;"	e	enum:CmtCallbackType
CMT_CALLBACK_LIST_TERMINATOR	cmtdef.h	/^	CMT_CALLBACK_LIST_TERMINATOR	= -1,\/\/!< Not a callback function. Used to define the end of a CallbackSelector list$/;"	e	enum:CmtCallbackType
CMT_CALLBACK_ONBYTESRECEIVED	cmtdef.h	/^	CMT_CALLBACK_ONBYTESRECEIVED,		\/\/!< Called when bytes have been read from a port$/;"	e	enum:CmtCallbackType
CMT_CALLBACK_ONINSTANCE	cmtdef.h	/^	CMT_CALLBACK_ONINSTANCE,			\/\/!< Called when a new CMT instance was created or an existing one is about to be destroyed. Also called once for all existing CMT instances when a plugin becomes enabled. If param is non-null, the instance is created, otherwise it is about to be destroyed. The return value of this callback is ignored.$/;"	e	enum:CmtCallbackType
CMT_CALLBACK_ONMEASUREMENTPREPARE	cmtdef.h	/^	CMT_CALLBACK_ONMEASUREMENTPREPARE,	\/\/!< Called right before sending a GotoMeasurement message$/;"	e	enum:CmtCallbackType
CMT_CALLBACK_ONMEASUREMENTSTART	cmtdef.h	/^	CMT_CALLBACK_ONMEASUREMENTSTART,	\/\/!< Called right after successfully switching to Measurement mode$/;"	e	enum:CmtCallbackType
CMT_CALLBACK_ONMEASUREMENTSTOP	cmtdef.h	/^	CMT_CALLBACK_ONMEASUREMENTSTOP,		\/\/!< Called right before switching from Measurement mode to Config mode$/;"	e	enum:CmtCallbackType
CMT_CALLBACK_ONMESSAGERECEIVED	cmtdef.h	/^	CMT_CALLBACK_ONMESSAGERECEIVED,		\/\/!< Called when a full message has been received from a port$/;"	e	enum:CmtCallbackType
CMT_CALLBACK_ONMESSAGESENT	cmtdef.h	/^	CMT_CALLBACK_ONMESSAGESENT,			\/\/!< Called when a full message has been sent by a port$/;"	e	enum:CmtCallbackType
CMT_CALLBACK_ONMISSINGSAMPLES	cmtdef.h	/^	CMT_CALLBACK_ONMISSINGSAMPLES,		\/\/!< Called when interpolation mode != 0 and missing samples are detected$/;"	e	enum:CmtCallbackType
CMT_CALLBACK_ONPLAYBACK	cmtdef.h	/^	CMT_CALLBACK_ONPLAYBACK,				\/\/!< Called when a full data bundle is available and has been processed by the CMT. The first void* parameter supplied to this function can be handed as the bundle parameter in cmtData... The function is intended to process the newly read bundle. Manipulation is allowed, but nothing gets written back to the file.$/;"	e	enum:CmtCallbackType
CMT_CALLBACK_ONPOSTPROCESS	cmtdef.h	/^	CMT_CALLBACK_ONPOSTPROCESS,			\/\/!< Called when a full data bundle is available and has been processed by the CMT. The first void* parameter supplied to this function can be handed as the bundle parameter in cmtData... The function is intended to manipulate or process the newly received bundle. Manipulation is allowed, but only 'custom data' will be written to a file when logging.$/;"	e	enum:CmtCallbackType
CMT_CALLBACK_ONWAKEUPRECEIVED	cmtdef.h	/^	CMT_CALLBACK_ONWAKEUPRECEIVED,		\/\/!< Called when receiving a wakeup message in config mode. Advise to refresh that port cache as soon as possible$/;"	e	enum:CmtCallbackType
CMT_CONF_BLOCKLEN	cmtdef.h	603;"	d
CMT_CONF_DATALENGTH	cmtdef.h	600;"	d
CMT_CONF_DATALENGTHLEN	cmtdef.h	619;"	d
CMT_CONF_DATE	cmtdef.h	595;"	d
CMT_CONF_DATELEN	cmtdef.h	612;"	d
CMT_CONF_DID	cmtdef.h	599;"	d
CMT_CONF_DIDLEN	cmtdef.h	618;"	d
CMT_CONF_MASTERDID	cmtdef.h	589;"	d
CMT_CONF_MASTERDIDLEN	cmtdef.h	606;"	d
CMT_CONF_NUMDEVICES	cmtdef.h	597;"	d
CMT_CONF_NUMDEVICESLEN	cmtdef.h	616;"	d
CMT_CONF_OUTPUTMODE	cmtdef.h	601;"	d
CMT_CONF_OUTPUTMODELEN	cmtdef.h	620;"	d
CMT_CONF_OUTPUTSETTINGS	cmtdef.h	602;"	d
CMT_CONF_OUTPUTSETTINGSLEN	cmtdef.h	621;"	d
CMT_CONF_OUTPUTSKIPFACTOR	cmtdef.h	591;"	d
CMT_CONF_OUTPUTSKIPFACTORLEN	cmtdef.h	608;"	d
CMT_CONF_PERIOD	cmtdef.h	590;"	d
CMT_CONF_PERIODLEN	cmtdef.h	607;"	d
CMT_CONF_RESERVED_CLIENTLEN	cmtdef.h	614;"	d
CMT_CONF_RESERVED_HOSTLEN	cmtdef.h	615;"	d
CMT_CONF_SYNCIN_MODE	cmtdef.h	592;"	d
CMT_CONF_SYNCIN_MODELEN	cmtdef.h	609;"	d
CMT_CONF_SYNCIN_OFFSET	cmtdef.h	594;"	d
CMT_CONF_SYNCIN_OFFSETLEN	cmtdef.h	611;"	d
CMT_CONF_SYNCIN_SKIPFACTOR	cmtdef.h	593;"	d
CMT_CONF_SYNCIN_SKIPFACTORLEN	cmtdef.h	610;"	d
CMT_CONF_TIME	cmtdef.h	596;"	d
CMT_CONF_TIMELEN	cmtdef.h	613;"	d
CMT_CONTROL_CTS	cmtdef.h	/^	CMT_CONTROL_CTS		= 0x0080,		\/\/ pin 8: Clear To Send$/;"	e	enum:CmtControlLine
CMT_CONTROL_DCD	cmtdef.h	/^	CMT_CONTROL_DCD		= 0x0001,		\/\/ pin 1: Carrier Detect$/;"	e	enum:CmtControlLine
CMT_CONTROL_DSR	cmtdef.h	/^	CMT_CONTROL_DSR		= 0x0020,		\/\/ pin 6: Data Set Ready$/;"	e	enum:CmtControlLine
CMT_CONTROL_DTR	cmtdef.h	/^	CMT_CONTROL_DTR		= 0x0008,		\/\/ pin 4: Data Terminal Ready$/;"	e	enum:CmtControlLine
CMT_CONTROL_GND	cmtdef.h	/^	CMT_CONTROL_GND		= 0x0010,		\/\/ pin 5: Common Ground$/;"	e	enum:CmtControlLine
CMT_CONTROL_RD	cmtdef.h	/^	CMT_CONTROL_RD		= 0x0002,		\/\/ pin 2: Received Data$/;"	e	enum:CmtControlLine
CMT_CONTROL_RI	cmtdef.h	/^	CMT_CONTROL_RI		= 0x0100		\/\/ pin 9: Ring Indicator$/;"	e	enum:CmtControlLine
CMT_CONTROL_RTS	cmtdef.h	/^	CMT_CONTROL_RTS		= 0x0040,		\/\/ pin 7: Request To Send$/;"	e	enum:CmtControlLine
CMT_CONTROL_TD	cmtdef.h	/^	CMT_CONTROL_TD		= 0x0004,		\/\/ pin 3: Transmitted Data$/;"	e	enum:CmtControlLine
CMT_DATA_ITEM_NOT_AVAILABLE	cmtpacket.h	40;"	d
CMT_DEFAULT_BAUD_RATE	cmtdef.h	828;"	d
CMT_DEFAULT_OUTPUT_MODE	cmtdef.h	800;"	d
CMT_DEFAULT_OUTPUT_SETTINGS	cmtdef.h	801;"	d
CMT_DEFAULT_PERIOD	cmtdef.h	808;"	d
CMT_DEFAULT_READ_BUFFER_SIZE	cmtdef.h	824;"	d
CMT_DEFAULT_SAMPLE_FREQUENCY	cmtdef.h	807;"	d
CMT_DEFAULT_SKIP	cmtdef.h	809;"	d
CMT_DEFAULT_WRITE_BUFFER_SIZE	cmtdef.h	826;"	d
CMT_DID_BROADCAST	cmtdef.h	962;"	d
CMT_DID_MASTER	cmtdef.h	963;"	d
CMT_DID_TYPEH_MASK	cmtdef.h	104;"	d
CMT_DID_TYPEH_MT	cmtdef.h	106;"	d
CMT_DID_TYPEH_MTIG	cmtdef.h	109;"	d
CMT_DID_TYPEH_MTI_MTX	cmtdef.h	108;"	d
CMT_DID_TYPEH_XM	cmtdef.h	107;"	d
CMT_DID_TYPEL_MASK	cmtdef.h	105;"	d
CMT_DID_TYPE_MASK	cmtdef.h	110;"	d
CMT_DID_TYPE_MASK_MT_232	cmtdef.h	111;"	d
CMT_DID_TYPE_MASK_MT_422	cmtdef.h	112;"	d
CMT_DID_TYPE_MASK_MT_485	cmtdef.h	114;"	d
CMT_DID_TYPE_MASK_MT_XM	cmtdef.h	113;"	d
CMT_EMTS_SIZE	cmtdef.h	1237;"	d
CMT_ERRORMODE_IGNORE	cmtdef.h	583;"	d
CMT_ERRORMODE_INCSAMPLECNT	cmtdef.h	584;"	d
CMT_ERRORMODE_INCSAMPLECNT_SENDERROR	cmtdef.h	585;"	d
CMT_ERRORMODE_SENDERROR_GOTOCONFIG	cmtdef.h	586;"	d
CMT_ERROR_BAUDRATEINVALID	cmtdef.h	578;"	d
CMT_ERROR_BUSNOTREADY	cmtdef.h	563;"	d
CMT_ERROR_INITOFBUSFAILED1	cmtdef.h	566;"	d
CMT_ERROR_INITOFBUSFAILED2	cmtdef.h	567;"	d
CMT_ERROR_INITOFBUSFAILED3	cmtdef.h	568;"	d
CMT_ERROR_MEASUREMENTFAILED1	cmtdef.h	571;"	d
CMT_ERROR_MEASUREMENTFAILED2	cmtdef.h	572;"	d
CMT_ERROR_MEASUREMENTFAILED3	cmtdef.h	573;"	d
CMT_ERROR_MEASUREMENTFAILED4	cmtdef.h	574;"	d
CMT_ERROR_MEASUREMENTFAILED5	cmtdef.h	575;"	d
CMT_ERROR_MEASUREMENTFAILED6	cmtdef.h	576;"	d
CMT_ERROR_MEASUREMENTFAILED7	cmtdef.h	580;"	d
CMT_ERROR_MESSAGEINVALID	cmtdef.h	565;"	d
CMT_ERROR_NOBUSCOMM	cmtdef.h	562;"	d
CMT_ERROR_PARAMETERINVALID	cmtdef.h	579;"	d
CMT_ERROR_PERIODINVALID	cmtdef.h	564;"	d
CMT_ERROR_SETBIDPROCFAILED1	cmtdef.h	569;"	d
CMT_ERROR_SETBIDPROCFAILED2	cmtdef.h	570;"	d
CMT_ERROR_TIMEROVERFLOW	cmtdef.h	577;"	d
CMT_EXTLENCODE	cmtdef.h	84;"	d
CMT_EXTOUTPUTMODE_DISABLED	cmtdef.h	711;"	d
CMT_EXTOUTPUTMODE_EULER	cmtdef.h	712;"	d
CMT_FILE_LAST_FRAME	cmtdef.h	1231;"	d
CMT_FLDNUM_CALIB_ACCX	cmtdef.h	434;"	d
CMT_FLDNUM_CALIB_ACCY	cmtdef.h	435;"	d
CMT_FLDNUM_CALIB_ACCZ	cmtdef.h	436;"	d
CMT_FLDNUM_CALIB_GYRX	cmtdef.h	437;"	d
CMT_FLDNUM_CALIB_GYRY	cmtdef.h	438;"	d
CMT_FLDNUM_CALIB_GYRZ	cmtdef.h	439;"	d
CMT_FLDNUM_CALIB_MAGX	cmtdef.h	440;"	d
CMT_FLDNUM_CALIB_MAGY	cmtdef.h	441;"	d
CMT_FLDNUM_CALIB_MAGZ	cmtdef.h	442;"	d
CMT_FLDNUM_ORIENT_A	cmtdef.h	453;"	d
CMT_FLDNUM_ORIENT_B	cmtdef.h	454;"	d
CMT_FLDNUM_ORIENT_C	cmtdef.h	455;"	d
CMT_FLDNUM_ORIENT_D	cmtdef.h	456;"	d
CMT_FLDNUM_ORIENT_E	cmtdef.h	457;"	d
CMT_FLDNUM_ORIENT_F	cmtdef.h	458;"	d
CMT_FLDNUM_ORIENT_G	cmtdef.h	459;"	d
CMT_FLDNUM_ORIENT_H	cmtdef.h	460;"	d
CMT_FLDNUM_ORIENT_I	cmtdef.h	461;"	d
CMT_FLDNUM_ORIENT_PITCH	cmtdef.h	450;"	d
CMT_FLDNUM_ORIENT_Q0	cmtdef.h	444;"	d
CMT_FLDNUM_ORIENT_Q1	cmtdef.h	445;"	d
CMT_FLDNUM_ORIENT_Q2	cmtdef.h	446;"	d
CMT_FLDNUM_ORIENT_Q3	cmtdef.h	447;"	d
CMT_FLDNUM_ORIENT_ROLL	cmtdef.h	449;"	d
CMT_FLDNUM_ORIENT_YAW	cmtdef.h	451;"	d
CMT_FLDNUM_RAW_ACCX	cmtdef.h	423;"	d
CMT_FLDNUM_RAW_ACCY	cmtdef.h	424;"	d
CMT_FLDNUM_RAW_ACCZ	cmtdef.h	425;"	d
CMT_FLDNUM_RAW_GYRX	cmtdef.h	426;"	d
CMT_FLDNUM_RAW_GYRY	cmtdef.h	427;"	d
CMT_FLDNUM_RAW_GYRZ	cmtdef.h	428;"	d
CMT_FLDNUM_RAW_MAGX	cmtdef.h	429;"	d
CMT_FLDNUM_RAW_MAGY	cmtdef.h	430;"	d
CMT_FLDNUM_RAW_MAGZ	cmtdef.h	431;"	d
CMT_FLDNUM_RAW_TEMP	cmtdef.h	432;"	d
CMT_GOTO_CONFIG_TRIES	cmtdef.h	804;"	d
CMT_IND_BID	cmtdef.h	73;"	d
CMT_IND_CALIB_ACCX	cmtdef.h	389;"	d
CMT_IND_CALIB_ACCY	cmtdef.h	390;"	d
CMT_IND_CALIB_ACCZ	cmtdef.h	391;"	d
CMT_IND_CALIB_GYRX	cmtdef.h	392;"	d
CMT_IND_CALIB_GYRY	cmtdef.h	393;"	d
CMT_IND_CALIB_GYRZ	cmtdef.h	394;"	d
CMT_IND_CALIB_MAGX	cmtdef.h	395;"	d
CMT_IND_CALIB_MAGY	cmtdef.h	396;"	d
CMT_IND_CALIB_MAGZ	cmtdef.h	397;"	d
CMT_IND_DATA0	cmtdef.h	76;"	d
CMT_IND_DATAEXT0	cmtdef.h	79;"	d
CMT_IND_LEN	cmtdef.h	75;"	d
CMT_IND_LENEXTH	cmtdef.h	77;"	d
CMT_IND_LENEXTL	cmtdef.h	78;"	d
CMT_IND_MID	cmtdef.h	74;"	d
CMT_IND_ORIENT_A	cmtdef.h	408;"	d
CMT_IND_ORIENT_B	cmtdef.h	409;"	d
CMT_IND_ORIENT_C	cmtdef.h	410;"	d
CMT_IND_ORIENT_D	cmtdef.h	411;"	d
CMT_IND_ORIENT_E	cmtdef.h	412;"	d
CMT_IND_ORIENT_F	cmtdef.h	413;"	d
CMT_IND_ORIENT_G	cmtdef.h	414;"	d
CMT_IND_ORIENT_H	cmtdef.h	415;"	d
CMT_IND_ORIENT_I	cmtdef.h	416;"	d
CMT_IND_ORIENT_PITCH	cmtdef.h	405;"	d
CMT_IND_ORIENT_Q0	cmtdef.h	399;"	d
CMT_IND_ORIENT_Q1	cmtdef.h	400;"	d
CMT_IND_ORIENT_Q2	cmtdef.h	401;"	d
CMT_IND_ORIENT_Q3	cmtdef.h	402;"	d
CMT_IND_ORIENT_ROLL	cmtdef.h	404;"	d
CMT_IND_ORIENT_YAW	cmtdef.h	406;"	d
CMT_IND_PREAMBLE	cmtdef.h	72;"	d
CMT_IND_RAW_ACCX	cmtdef.h	378;"	d
CMT_IND_RAW_ACCY	cmtdef.h	379;"	d
CMT_IND_RAW_ACCZ	cmtdef.h	380;"	d
CMT_IND_RAW_GYRX	cmtdef.h	381;"	d
CMT_IND_RAW_GYRY	cmtdef.h	382;"	d
CMT_IND_RAW_GYRZ	cmtdef.h	383;"	d
CMT_IND_RAW_MAGX	cmtdef.h	384;"	d
CMT_IND_RAW_MAGY	cmtdef.h	385;"	d
CMT_IND_RAW_MAGZ	cmtdef.h	386;"	d
CMT_IND_RAW_TEMP	cmtdef.h	387;"	d
CMT_IND_SAMPLECNTH	cmtdef.h	418;"	d
CMT_IND_SAMPLECNTL	cmtdef.h	419;"	d
CMT_INVALIDSETTINGVALUE	cmtdef.h	518;"	d
CMT_LEN_AMD	cmtdef.h	535;"	d
CMT_LEN_AVAILABLESCENARIOS	cmtdef.h	309;"	d
CMT_LEN_BAUDRATE	cmtdef.h	170;"	d
CMT_LEN_BTDISABLE	cmtdef.h	159;"	d
CMT_LEN_BUFFERSIZE	cmtdef.h	257;"	d
CMT_LEN_BUSPWR	cmtdef.h	139;"	d
CMT_LEN_CALIBDATA	cmtdef.h	358;"	d
CMT_LEN_CALIBDATA_FLT	cmtdef.h	369;"	d
CMT_LEN_CALIB_ACCDATA	cmtdef.h	359;"	d
CMT_LEN_CALIB_ACCX	cmtdef.h	475;"	d
CMT_LEN_CALIB_ACCY	cmtdef.h	476;"	d
CMT_LEN_CALIB_ACCZ	cmtdef.h	477;"	d
CMT_LEN_CALIB_GYRDATA	cmtdef.h	360;"	d
CMT_LEN_CALIB_GYRX	cmtdef.h	478;"	d
CMT_LEN_CALIB_GYRY	cmtdef.h	479;"	d
CMT_LEN_CALIB_GYRZ	cmtdef.h	480;"	d
CMT_LEN_CALIB_MAGDATA	cmtdef.h	361;"	d
CMT_LEN_CALIB_MAGX	cmtdef.h	481;"	d
CMT_LEN_CALIB_MAGY	cmtdef.h	482;"	d
CMT_LEN_CALIB_MAGZ	cmtdef.h	483;"	d
CMT_LEN_CHECKSUM	cmtdef.h	90;"	d
CMT_LEN_CONFIGURATION	cmtdef.h	147;"	d
CMT_LEN_DATALENGTH	cmtdef.h	144;"	d
CMT_LEN_DEVICEID	cmtdef.h	124;"	d
CMT_LEN_ERRORMODE	cmtdef.h	232;"	d
CMT_LEN_EXTOUTPUTMODE	cmtdef.h	282;"	d
CMT_LEN_FILTERSETTINGS	cmtdef.h	530;"	d
CMT_LEN_FIRMWAREREV	cmtdef.h	155;"	d
CMT_LEN_FLOAT	cmtdef.h	93;"	d
CMT_LEN_GPSLEVERARM	cmtdef.h	328;"	d
CMT_LEN_GPSSTATUS	cmtdef.h	544;"	d
CMT_LEN_GRAVITYMAGNITUDE	cmtdef.h	322;"	d
CMT_LEN_HEADING	cmtdef.h	264;"	d
CMT_LEN_INITBUSRESULTS	cmtdef.h	127;"	d
CMT_LEN_INITTRACKMODE	cmtdef.h	293;"	d
CMT_LEN_LATLONALT	cmtdef.h	332;"	d
CMT_LEN_LOCATIONID	cmtdef.h	276;"	d
CMT_LEN_MAGNETICDECLINATION	cmtdef.h	270;"	d
CMT_LEN_MSGEXTHEADER	cmtdef.h	87;"	d
CMT_LEN_MSGEXTHEADERCS	cmtdef.h	89;"	d
CMT_LEN_MSGHEADER	cmtdef.h	86;"	d
CMT_LEN_MSGHEADERCS	cmtdef.h	88;"	d
CMT_LEN_OBJECTALIGNMENT	cmtdef.h	244;"	d
CMT_LEN_OPMODE	cmtdef.h	164;"	d
CMT_LEN_ORIENT_A	cmtdef.h	494;"	d
CMT_LEN_ORIENT_B	cmtdef.h	495;"	d
CMT_LEN_ORIENT_C	cmtdef.h	496;"	d
CMT_LEN_ORIENT_D	cmtdef.h	497;"	d
CMT_LEN_ORIENT_E	cmtdef.h	498;"	d
CMT_LEN_ORIENT_EULERDATA	cmtdef.h	363;"	d
CMT_LEN_ORIENT_EULERDATA_FLT	cmtdef.h	372;"	d
CMT_LEN_ORIENT_F	cmtdef.h	499;"	d
CMT_LEN_ORIENT_G	cmtdef.h	500;"	d
CMT_LEN_ORIENT_H	cmtdef.h	501;"	d
CMT_LEN_ORIENT_I	cmtdef.h	502;"	d
CMT_LEN_ORIENT_MATRIXDATA	cmtdef.h	364;"	d
CMT_LEN_ORIENT_MATRIXDATA_FLT	cmtdef.h	373;"	d
CMT_LEN_ORIENT_PITCH	cmtdef.h	491;"	d
CMT_LEN_ORIENT_Q0	cmtdef.h	485;"	d
CMT_LEN_ORIENT_Q1	cmtdef.h	486;"	d
CMT_LEN_ORIENT_Q2	cmtdef.h	487;"	d
CMT_LEN_ORIENT_Q3	cmtdef.h	488;"	d
CMT_LEN_ORIENT_QUATDATA	cmtdef.h	362;"	d
CMT_LEN_ORIENT_QUATDATA_FLT	cmtdef.h	371;"	d
CMT_LEN_ORIENT_ROLL	cmtdef.h	490;"	d
CMT_LEN_ORIENT_YAW	cmtdef.h	492;"	d
CMT_LEN_OUTPUTMODE	cmtdef.h	197;"	d
CMT_LEN_OUTPUTSETTINGS	cmtdef.h	203;"	d
CMT_LEN_OUTPUTSKIPFACTOR	cmtdef.h	209;"	d
CMT_LEN_PERIOD	cmtdef.h	130;"	d
CMT_LEN_PROCESSINGFLAGS	cmtdef.h	186;"	d
CMT_LEN_PRODUCTCODE	cmtdef.h	182;"	d
CMT_LEN_RAWDATA	cmtdef.h	357;"	d
CMT_LEN_RAW_ACCX	cmtdef.h	464;"	d
CMT_LEN_RAW_ACCY	cmtdef.h	465;"	d
CMT_LEN_RAW_ACCZ	cmtdef.h	466;"	d
CMT_LEN_RAW_GYRX	cmtdef.h	467;"	d
CMT_LEN_RAW_GYRY	cmtdef.h	468;"	d
CMT_LEN_RAW_GYRZ	cmtdef.h	469;"	d
CMT_LEN_RAW_MAGX	cmtdef.h	470;"	d
CMT_LEN_RAW_MAGY	cmtdef.h	471;"	d
CMT_LEN_RAW_MAGZ	cmtdef.h	472;"	d
CMT_LEN_RAW_TEMP	cmtdef.h	473;"	d
CMT_LEN_REQSCENARIOACK	cmtdef.h	313;"	d
CMT_LEN_RESETORIENTATION	cmtdef.h	540;"	d
CMT_LEN_SAMPLECNT	cmtdef.h	365;"	d
CMT_LEN_SCENARIOFULL	cmtdef.h	306;"	d
CMT_LEN_SCENARIOLABEL	cmtdef.h	305;"	d
CMT_LEN_SETNOROTATION	cmtdef.h	344;"	d
CMT_LEN_SETSCENARIO	cmtdef.h	316;"	d
CMT_LEN_STOREXKFSTATE	cmtdef.h	298;"	d
CMT_LEN_SYNCINMODE	cmtdef.h	215;"	d
CMT_LEN_SYNCINOFFSET	cmtdef.h	217;"	d
CMT_LEN_SYNCINSKIPFACTOR	cmtdef.h	216;"	d
CMT_LEN_SYNCMODE	cmtdef.h	176;"	d
CMT_LEN_SYNCOUTMODE	cmtdef.h	223;"	d
CMT_LEN_SYNCOUTOFFSET	cmtdef.h	225;"	d
CMT_LEN_SYNCOUTPULSEWIDTH	cmtdef.h	226;"	d
CMT_LEN_SYNCOUTSKIPFACTOR	cmtdef.h	224;"	d
CMT_LEN_TEMPDATA	cmtdef.h	366;"	d
CMT_LEN_TEMPDATA_FLT	cmtdef.h	370;"	d
CMT_LEN_TRANSMITDELAY	cmtdef.h	238;"	d
CMT_LEN_UNSIGINT	cmtdef.h	92;"	d
CMT_LEN_UNSIGSHORT	cmtdef.h	91;"	d
CMT_LEN_UTCTIME	cmtdef.h	303;"	d
CMT_LEN_XMERRORMODE	cmtdef.h	251;"	d
CMT_LEN_XMPWROFF	cmtdef.h	192;"	d
CMT_MAXDATALEN	cmtdef.h	96;"	d
CMT_MAXGARBAGE	cmtdef.h	100;"	d
CMT_MAXMSGLEN	cmtdef.h	98;"	d
CMT_MAXSHORTDATALEN	cmtdef.h	97;"	d
CMT_MAXSHORTMSGLEN	cmtdef.h	99;"	d
CMT_MAX_DEVICES	cmtdef.h	815;"	d
CMT_MAX_DEVICES	cmtdef.h	817;"	d
CMT_MAX_DEVICES_PER_PORT	cmtdef.h	806;"	d
CMT_MAX_FILENAME_LENGTH	cmtdef.h	960;"	d
CMT_MAX_FILES_PER_THREAD	cmtdef.h	813;"	d
CMT_MAX_ITEMS_IN_PACKET	cmtdef.h	821;"	d
CMT_MAX_PACKETS_PER_BUNDLE	cmtdef.h	819;"	d
CMT_MAX_PORTS_PER_THREAD	cmtdef.h	812;"	d
CMT_MAX_SCENARIOS	cmtdef.h	1090;"	d
CMT_MAX_SCENARIOS_IN_MT	cmtdef.h	1089;"	d
CMT_MAX_SVINFO	cmtdef.h	1217;"	d
CMT_MAX_VPORTNAME_LEN	cmtdef.h	1247;"	d
CMT_MID_AUTOSTART	cmtdef.h	136;"	d
CMT_MID_AUTOSTARTACK	cmtdef.h	137;"	d
CMT_MID_AVAILABLESCENARIOS	cmtdef.h	308;"	d
CMT_MID_BATLEVEL	cmtdef.h	288;"	d
CMT_MID_BUSDATA	cmtdef.h	339;"	d
CMT_MID_BUSPWR	cmtdef.h	138;"	d
CMT_MID_BUSPWRACK	cmtdef.h	140;"	d
CMT_MID_CONFIGURATION	cmtdef.h	146;"	d
CMT_MID_DATALENGTH	cmtdef.h	143;"	d
CMT_MID_DEVICEID	cmtdef.h	123;"	d
CMT_MID_DISABLEBT	cmtdef.h	160;"	d
CMT_MID_DISABLEBTACK	cmtdef.h	161;"	d
CMT_MID_EMTSDATA	cmtdef.h	1236;"	d
CMT_MID_ERROR	cmtdef.h	523;"	d
CMT_MID_FIRMWAREREV	cmtdef.h	154;"	d
CMT_MID_GOTOCONFIG	cmtdef.h	337;"	d
CMT_MID_GOTOCONFIGACK	cmtdef.h	338;"	d
CMT_MID_GOTOMEASUREMENT	cmtdef.h	151;"	d
CMT_MID_GOTOMEASUREMENTACK	cmtdef.h	152;"	d
CMT_MID_GPSSTATUS	cmtdef.h	543;"	d
CMT_MID_INITBUS	cmtdef.h	125;"	d
CMT_MID_INITBUSRESULTS	cmtdef.h	126;"	d
CMT_MID_MTDATA	cmtdef.h	340;"	d
CMT_MID_PREPAREDATA	cmtdef.h	351;"	d
CMT_MID_PRODUCTCODE	cmtdef.h	181;"	d
CMT_MID_REQAMD	cmtdef.h	533;"	d
CMT_MID_REQAMDACK	cmtdef.h	534;"	d
CMT_MID_REQAVAILABLESCENARIOS	cmtdef.h	307;"	d
CMT_MID_REQBATLEVEL	cmtdef.h	287;"	d
CMT_MID_REQBAUDRATE	cmtdef.h	168;"	d
CMT_MID_REQBAUDRATEACK	cmtdef.h	169;"	d
CMT_MID_REQBTDISABLE	cmtdef.h	157;"	d
CMT_MID_REQBTDISABLEACK	cmtdef.h	158;"	d
CMT_MID_REQBUFFERSIZE	cmtdef.h	255;"	d
CMT_MID_REQBUFFERSIZEACK	cmtdef.h	256;"	d
CMT_MID_REQCONFIGURATION	cmtdef.h	145;"	d
CMT_MID_REQDATA	cmtdef.h	352;"	d
CMT_MID_REQDATAACK	cmtdef.h	353;"	d
CMT_MID_REQDATALENGTH	cmtdef.h	142;"	d
CMT_MID_REQDID	cmtdef.h	122;"	d
CMT_MID_REQEMTS	cmtdef.h	1235;"	d
CMT_MID_REQERRORMODE	cmtdef.h	230;"	d
CMT_MID_REQERRORMODEACK	cmtdef.h	231;"	d
CMT_MID_REQEXTOUTPUTMODE	cmtdef.h	280;"	d
CMT_MID_REQEXTOUTPUTMODEACK	cmtdef.h	281;"	d
CMT_MID_REQFILTERSETTINGS	cmtdef.h	528;"	d
CMT_MID_REQFILTERSETTINGSACK	cmtdef.h	529;"	d
CMT_MID_REQFWREV	cmtdef.h	153;"	d
CMT_MID_REQGPSLEVERARM	cmtdef.h	324;"	d
CMT_MID_REQGPSLEVERARMACK	cmtdef.h	325;"	d
CMT_MID_REQGPSSTATUS	cmtdef.h	542;"	d
CMT_MID_REQGRAVITYMAGNITUDE	cmtdef.h	318;"	d
CMT_MID_REQGRAVITYMAGNITUDEACK	cmtdef.h	319;"	d
CMT_MID_REQHEADING	cmtdef.h	262;"	d
CMT_MID_REQHEADINGACK	cmtdef.h	263;"	d
CMT_MID_REQINITTRACKMODE	cmtdef.h	291;"	d
CMT_MID_REQINITTRACKMODEACK	cmtdef.h	292;"	d
CMT_MID_REQLATLONALT	cmtdef.h	330;"	d
CMT_MID_REQLATLONALTACK	cmtdef.h	331;"	d
CMT_MID_REQLOCATIONID	cmtdef.h	274;"	d
CMT_MID_REQLOCATIONIDACK	cmtdef.h	275;"	d
CMT_MID_REQMAGNETICDECLINATION	cmtdef.h	268;"	d
CMT_MID_REQMAGNETICDECLINATIONACK	cmtdef.h	269;"	d
CMT_MID_REQOBJECTALIGNMENT	cmtdef.h	242;"	d
CMT_MID_REQOBJECTALIGNMENTACK	cmtdef.h	243;"	d
CMT_MID_REQOPMODE	cmtdef.h	162;"	d
CMT_MID_REQOPMODEACK	cmtdef.h	163;"	d
CMT_MID_REQOUTPUTMODE	cmtdef.h	195;"	d
CMT_MID_REQOUTPUTMODEACK	cmtdef.h	196;"	d
CMT_MID_REQOUTPUTSETTINGS	cmtdef.h	201;"	d
CMT_MID_REQOUTPUTSETTINGSACK	cmtdef.h	202;"	d
CMT_MID_REQOUTPUTSKIPFACTOR	cmtdef.h	207;"	d
CMT_MID_REQOUTPUTSKIPFACTORACK	cmtdef.h	208;"	d
CMT_MID_REQPERIOD	cmtdef.h	128;"	d
CMT_MID_REQPERIODACK	cmtdef.h	129;"	d
CMT_MID_REQPROCESSINGFLAGS	cmtdef.h	184;"	d
CMT_MID_REQPROCESSINGFLAGSACK	cmtdef.h	185;"	d
CMT_MID_REQPRODUCTCODE	cmtdef.h	180;"	d
CMT_MID_REQSCENARIO	cmtdef.h	311;"	d
CMT_MID_REQSCENARIOACK	cmtdef.h	312;"	d
CMT_MID_REQSYNCINSETTINGS	cmtdef.h	213;"	d
CMT_MID_REQSYNCINSETTINGSACK	cmtdef.h	214;"	d
CMT_MID_REQSYNCMODE	cmtdef.h	174;"	d
CMT_MID_REQSYNCMODEACK	cmtdef.h	175;"	d
CMT_MID_REQSYNCOUTSETTINGS	cmtdef.h	221;"	d
CMT_MID_REQSYNCOUTSETTINGSACK	cmtdef.h	222;"	d
CMT_MID_REQTRANSMITDELAY	cmtdef.h	236;"	d
CMT_MID_REQTRANSMITDELAYACK	cmtdef.h	237;"	d
CMT_MID_REQUTCTIME	cmtdef.h	301;"	d
CMT_MID_REQXMERRORMODE	cmtdef.h	249;"	d
CMT_MID_REQXMERRORMODEACK	cmtdef.h	250;"	d
CMT_MID_RESET	cmtdef.h	521;"	d
CMT_MID_RESETACK	cmtdef.h	522;"	d
CMT_MID_RESETORIENTATION	cmtdef.h	538;"	d
CMT_MID_RESETORIENTATIONACK	cmtdef.h	539;"	d
CMT_MID_RESTOREFACTORYDEF	cmtdef.h	148;"	d
CMT_MID_RESTOREFACTORYDEFACK	cmtdef.h	149;"	d
CMT_MID_RUNSELFTEST	cmtdef.h	346;"	d
CMT_MID_SELFTESTRESULTS	cmtdef.h	347;"	d
CMT_MID_SETAMD	cmtdef.h	536;"	d
CMT_MID_SETAMDACK	cmtdef.h	537;"	d
CMT_MID_SETBAUDRATE	cmtdef.h	171;"	d
CMT_MID_SETBAUDRATEACK	cmtdef.h	172;"	d
CMT_MID_SETBID	cmtdef.h	134;"	d
CMT_MID_SETBIDACK	cmtdef.h	135;"	d
CMT_MID_SETBUFFERSIZE	cmtdef.h	258;"	d
CMT_MID_SETBUFFERSIZEACK	cmtdef.h	259;"	d
CMT_MID_SETERRORMODE	cmtdef.h	233;"	d
CMT_MID_SETERRORMODEACK	cmtdef.h	234;"	d
CMT_MID_SETEXTOUTPUTMODE	cmtdef.h	283;"	d
CMT_MID_SETEXTOUTPUTMODEACK	cmtdef.h	284;"	d
CMT_MID_SETFILTERSETTINGS	cmtdef.h	531;"	d
CMT_MID_SETFILTERSETTINGSACK	cmtdef.h	532;"	d
CMT_MID_SETGPSLEVERARM	cmtdef.h	326;"	d
CMT_MID_SETGPSLEVERARMACK	cmtdef.h	327;"	d
CMT_MID_SETGRAVITYMAGNITUDE	cmtdef.h	320;"	d
CMT_MID_SETGRAVITYMAGNITUDEACK	cmtdef.h	321;"	d
CMT_MID_SETHEADING	cmtdef.h	265;"	d
CMT_MID_SETHEADINGACK	cmtdef.h	266;"	d
CMT_MID_SETINITTRACKMODE	cmtdef.h	294;"	d
CMT_MID_SETINITTRACKMODEACK	cmtdef.h	295;"	d
CMT_MID_SETLATLONALT	cmtdef.h	333;"	d
CMT_MID_SETLATLONALTACK	cmtdef.h	334;"	d
CMT_MID_SETLOCATIONID	cmtdef.h	277;"	d
CMT_MID_SETLOCATIONIDACK	cmtdef.h	278;"	d
CMT_MID_SETMAGNETICDECLINATION	cmtdef.h	271;"	d
CMT_MID_SETMAGNETICDECLINATIONACK	cmtdef.h	272;"	d
CMT_MID_SETNOROTATION	cmtdef.h	342;"	d
CMT_MID_SETNOROTATIONACK	cmtdef.h	343;"	d
CMT_MID_SETOBJECTALIGNMENT	cmtdef.h	245;"	d
CMT_MID_SETOBJECTALIGNMENTACK	cmtdef.h	246;"	d
CMT_MID_SETOPMODE	cmtdef.h	165;"	d
CMT_MID_SETOPMODEACK	cmtdef.h	166;"	d
CMT_MID_SETOUTPUTMODE	cmtdef.h	198;"	d
CMT_MID_SETOUTPUTMODEACK	cmtdef.h	199;"	d
CMT_MID_SETOUTPUTSETTINGS	cmtdef.h	204;"	d
CMT_MID_SETOUTPUTSETTINGSACK	cmtdef.h	205;"	d
CMT_MID_SETOUTPUTSKIPFACTOR	cmtdef.h	210;"	d
CMT_MID_SETOUTPUTSKIPFACTORACK	cmtdef.h	211;"	d
CMT_MID_SETPERIOD	cmtdef.h	131;"	d
CMT_MID_SETPERIODACK	cmtdef.h	132;"	d
CMT_MID_SETPROCESSINGFLAGS	cmtdef.h	187;"	d
CMT_MID_SETPROCESSINGFLAGSACK	cmtdef.h	188;"	d
CMT_MID_SETSCENARIO	cmtdef.h	314;"	d
CMT_MID_SETSCENARIOACK	cmtdef.h	315;"	d
CMT_MID_SETSYNCINSETTINGS	cmtdef.h	218;"	d
CMT_MID_SETSYNCINSETTINGSACK	cmtdef.h	219;"	d
CMT_MID_SETSYNCMODE	cmtdef.h	177;"	d
CMT_MID_SETSYNCMODEACK	cmtdef.h	178;"	d
CMT_MID_SETSYNCOUTSETTINGS	cmtdef.h	227;"	d
CMT_MID_SETSYNCOUTSETTINGSACK	cmtdef.h	228;"	d
CMT_MID_SETTRANSMITDELAY	cmtdef.h	239;"	d
CMT_MID_SETTRANSMITDELAYACK	cmtdef.h	240;"	d
CMT_MID_SETXMERRORMODE	cmtdef.h	252;"	d
CMT_MID_SETXMERRORMODEACK	cmtdef.h	253;"	d
CMT_MID_STOREXKFSTATE	cmtdef.h	297;"	d
CMT_MID_STOREXKFSTATEACK	cmtdef.h	299;"	d
CMT_MID_UTCTIME	cmtdef.h	302;"	d
CMT_MID_WAKEUP	cmtdef.h	118;"	d
CMT_MID_WAKEUPACK	cmtdef.h	119;"	d
CMT_MID_XMPWROFF	cmtdef.h	191;"	d
CMT_MID_XMPWROFF	cmtdef.h	525;"	d
CMT_OUTPUTMODE_AUXILIARY	cmtdef.h	668;"	d
CMT_OUTPUTMODE_CALIB	cmtdef.h	666;"	d
CMT_OUTPUTMODE_GPSPVT_PRESSURE	cmtdef.h	664;"	d
CMT_OUTPUTMODE_MT9	cmtdef.h	660;"	d
CMT_OUTPUTMODE_ORIENT	cmtdef.h	667;"	d
CMT_OUTPUTMODE_POSITION	cmtdef.h	669;"	d
CMT_OUTPUTMODE_RAW	cmtdef.h	662;"	d
CMT_OUTPUTMODE_STATUS	cmtdef.h	671;"	d
CMT_OUTPUTMODE_TEMP	cmtdef.h	665;"	d
CMT_OUTPUTMODE_VELOCITY	cmtdef.h	670;"	d
CMT_OUTPUTMODE_XM	cmtdef.h	661;"	d
CMT_OUTPUTSETTINGS_AUXILIARYMODE_AIN1	cmtdef.h	692;"	d
CMT_OUTPUTSETTINGS_AUXILIARYMODE_AIN1_MASK	cmtdef.h	703;"	d
CMT_OUTPUTSETTINGS_AUXILIARYMODE_AIN2	cmtdef.h	693;"	d
CMT_OUTPUTSETTINGS_AUXILIARYMODE_AIN2_MASK	cmtdef.h	704;"	d
CMT_OUTPUTSETTINGS_AUXILIARYMODE_MASK	cmtdef.h	705;"	d
CMT_OUTPUTSETTINGS_CALIBMODE_ACC	cmtdef.h	682;"	d
CMT_OUTPUTSETTINGS_CALIBMODE_ACCGYR	cmtdef.h	683;"	d
CMT_OUTPUTSETTINGS_CALIBMODE_ACCGYRMAG	cmtdef.h	681;"	d
CMT_OUTPUTSETTINGS_CALIBMODE_ACCGYRMAG_MASK	cmtdef.h	688;"	d
CMT_OUTPUTSETTINGS_CALIBMODE_ACCMAG	cmtdef.h	684;"	d
CMT_OUTPUTSETTINGS_CALIBMODE_ACC_MASK	cmtdef.h	698;"	d
CMT_OUTPUTSETTINGS_CALIBMODE_GYR	cmtdef.h	685;"	d
CMT_OUTPUTSETTINGS_CALIBMODE_GYRMAG	cmtdef.h	686;"	d
CMT_OUTPUTSETTINGS_CALIBMODE_GYR_MASK	cmtdef.h	699;"	d
CMT_OUTPUTSETTINGS_CALIBMODE_MAG	cmtdef.h	687;"	d
CMT_OUTPUTSETTINGS_CALIBMODE_MAG_MASK	cmtdef.h	700;"	d
CMT_OUTPUTSETTINGS_CALIBMODE_MASK	cmtdef.h	701;"	d
CMT_OUTPUTSETTINGS_COORDINATES_NED	cmtdef.h	708;"	d
CMT_OUTPUTSETTINGS_DATAFORMAT_DOUBLE	cmtmessage.cpp	31;"	d	file:
CMT_OUTPUTSETTINGS_DATAFORMAT_DOUBLE	cmtpacket.cpp	39;"	d	file:
CMT_OUTPUTSETTINGS_DATAFORMAT_F1220	cmtdef.h	690;"	d
CMT_OUTPUTSETTINGS_DATAFORMAT_FLOAT	cmtdef.h	689;"	d
CMT_OUTPUTSETTINGS_DATAFORMAT_FP1632	cmtdef.h	691;"	d
CMT_OUTPUTSETTINGS_DATAFORMAT_MASK	cmtdef.h	702;"	d
CMT_OUTPUTSETTINGS_ORIENTMODE_EULER	cmtdef.h	679;"	d
CMT_OUTPUTSETTINGS_ORIENTMODE_MASK	cmtdef.h	697;"	d
CMT_OUTPUTSETTINGS_ORIENTMODE_MATRIX	cmtdef.h	680;"	d
CMT_OUTPUTSETTINGS_ORIENTMODE_QUATERNION	cmtdef.h	678;"	d
CMT_OUTPUTSETTINGS_POSITIONMODE_LLA_WGS84	cmtdef.h	694;"	d
CMT_OUTPUTSETTINGS_POSITIONMODE_MASK	cmtdef.h	706;"	d
CMT_OUTPUTSETTINGS_TIMESTAMP_MASK	cmtdef.h	696;"	d
CMT_OUTPUTSETTINGS_TIMESTAMP_NONE	cmtdef.h	675;"	d
CMT_OUTPUTSETTINGS_TIMESTAMP_SAMPLECNT	cmtdef.h	676;"	d
CMT_OUTPUTSETTINGS_TIMESTAMP_SAMPLEUTC	cmtdef.h	677;"	d
CMT_OUTPUTSETTINGS_VELOCITYMODE_MASK	cmtdef.h	707;"	d
CMT_OUTPUTSETTINGS_VELOCITYMODE_MS_XYZ	cmtdef.h	695;"	d
CMT_OUTPUTSETTINGS_XM	cmtdef.h	674;"	d
CMT_PARAM_SYNCIN_MODE	cmtdef.h	629;"	d
CMT_PARAM_SYNCIN_OFFSET	cmtdef.h	631;"	d
CMT_PARAM_SYNCIN_SKIPFACTOR	cmtdef.h	630;"	d
CMT_PARAM_SYNCOUT_MODE	cmtdef.h	645;"	d
CMT_PARAM_SYNCOUT_OFFSET	cmtdef.h	647;"	d
CMT_PARAM_SYNCOUT_PULSEWIDTH	cmtdef.h	648;"	d
CMT_PARAM_SYNCOUT_SKIPFACTOR	cmtdef.h	646;"	d
CMT_PERIOD_100HZ	cmtdef.h	751;"	d
CMT_PERIOD_10HZ	cmtdef.h	728;"	d
CMT_PERIOD_120HZ	cmtdef.h	752;"	d
CMT_PERIOD_128HZ	cmtdef.h	753;"	d
CMT_PERIOD_12HZ	cmtdef.h	729;"	d
CMT_PERIOD_144HZ	cmtdef.h	754;"	d
CMT_PERIOD_150HZ	cmtdef.h	755;"	d
CMT_PERIOD_15HZ	cmtdef.h	730;"	d
CMT_PERIOD_160HZ	cmtdef.h	756;"	d
CMT_PERIOD_16HZ	cmtdef.h	731;"	d
CMT_PERIOD_180HZ	cmtdef.h	757;"	d
CMT_PERIOD_18HZ	cmtdef.h	732;"	d
CMT_PERIOD_192HZ	cmtdef.h	758;"	d
CMT_PERIOD_200HZ	cmtdef.h	759;"	d
CMT_PERIOD_20HZ	cmtdef.h	733;"	d
CMT_PERIOD_225HZ	cmtdef.h	760;"	d
CMT_PERIOD_240HZ	cmtdef.h	761;"	d
CMT_PERIOD_24HZ	cmtdef.h	734;"	d
CMT_PERIOD_256HZ	cmtdef.h	762;"	d
CMT_PERIOD_25HZ	cmtdef.h	735;"	d
CMT_PERIOD_288HZ	cmtdef.h	763;"	d
CMT_PERIOD_300HZ	cmtdef.h	764;"	d
CMT_PERIOD_30HZ	cmtdef.h	736;"	d
CMT_PERIOD_320HZ	cmtdef.h	765;"	d
CMT_PERIOD_32HZ	cmtdef.h	737;"	d
CMT_PERIOD_360HZ	cmtdef.h	766;"	d
CMT_PERIOD_36HZ	cmtdef.h	738;"	d
CMT_PERIOD_384HZ	cmtdef.h	767;"	d
CMT_PERIOD_400HZ	cmtdef.h	768;"	d
CMT_PERIOD_40HZ	cmtdef.h	739;"	d
CMT_PERIOD_450HZ	cmtdef.h	769;"	d
CMT_PERIOD_45HZ	cmtdef.h	740;"	d
CMT_PERIOD_480HZ	cmtdef.h	770;"	d
CMT_PERIOD_48HZ	cmtdef.h	741;"	d
CMT_PERIOD_50HZ	cmtdef.h	742;"	d
CMT_PERIOD_512HZ	cmtdef.h	771;"	d
CMT_PERIOD_60HZ	cmtdef.h	743;"	d
CMT_PERIOD_64HZ	cmtdef.h	744;"	d
CMT_PERIOD_72HZ	cmtdef.h	745;"	d
CMT_PERIOD_75HZ	cmtdef.h	746;"	d
CMT_PERIOD_80HZ	cmtdef.h	747;"	d
CMT_PERIOD_90HZ	cmtdef.h	748;"	d
CMT_PERIOD_96HZ	cmtdef.h	749;"	d
CMT_PREAMBLE	cmtdef.h	81;"	d
CMT_PROCESSINGFLAGS_FIXED_GRAVITY	cmtdef.h	716;"	d
CMT_PROCESSINGFLAGS_IGBU_ENABLED	cmtdef.h	715;"	d
CMT_QM_FIFO	cmtdef.h	/^	CMT_QM_FIFO	= 0,$/;"	e	enum:CmtQueueMode
CMT_QM_LAST	cmtdef.h	/^	CMT_QM_LAST = 1,$/;"	e	enum:CmtQueueMode
CMT_QM_RAW	cmtdef.h	/^	CMT_QM_RAW  = 2$/;"	e	enum:CmtQueueMode
CMT_RESETORIENTATION_ALIGN	cmtdef.h	/^	CMT_RESETORIENTATION_ALIGN$/;"	e	enum:CmtResetMethod
CMT_RESETORIENTATION_GLOBAL	cmtdef.h	/^	CMT_RESETORIENTATION_GLOBAL,$/;"	e	enum:CmtResetMethod
CMT_RESETORIENTATION_HEADING	cmtdef.h	/^	CMT_RESETORIENTATION_HEADING,$/;"	e	enum:CmtResetMethod
CMT_RESETORIENTATION_OBJECT	cmtdef.h	/^	CMT_RESETORIENTATION_OBJECT,$/;"	e	enum:CmtResetMethod
CMT_RESETORIENTATION_STORE	cmtdef.h	/^	CMT_RESETORIENTATION_STORE = 0,$/;"	e	enum:CmtResetMethod
CMT_SELFTEST_OK	cmtdef.h	348;"	d
CMT_SENDRAWSTRING_DEFAULT	cmtdef.h	720;"	d
CMT_SENDRAWSTRING_INIT	cmtdef.h	719;"	d
CMT_SENDRAWSTRING_SEND	cmtdef.h	721;"	d
CMT_STATUSFLAG_GPSVALID	cmtdef.h	1241;"	d
CMT_STATUSFLAG_NOROTATION	cmtdef.h	1243;"	d
CMT_STATUSFLAG_NOROTATION_ABORTED	cmtdef.h	1244;"	d
CMT_STATUSFLAG_NOROTATION_MASK	cmtdef.h	1242;"	d
CMT_STATUSFLAG_NOROTATION_SAMPLES_REJECTED	cmtdef.h	1245;"	d
CMT_STATUSFLAG_SELFTEST_OK	cmtdef.h	1239;"	d
CMT_STATUSFLAG_XKFVALID	cmtdef.h	1240;"	d
CMT_SYNCIN_DISABLED	cmtdef.h	634;"	d
CMT_SYNCIN_EDGE_BOTH	cmtdef.h	637;"	d
CMT_SYNCIN_EDGE_FALLING	cmtdef.h	636;"	d
CMT_SYNCIN_EDGE_MASK	cmtdef.h	638;"	d
CMT_SYNCIN_EDGE_RISING	cmtdef.h	635;"	d
CMT_SYNCIN_TYPE_CLOCK	cmtdef.h	641;"	d
CMT_SYNCIN_TYPE_DOSAMPLING	cmtdef.h	639;"	d
CMT_SYNCIN_TYPE_MASK	cmtdef.h	642;"	d
CMT_SYNCIN_TYPE_SENDLASTDATA	cmtdef.h	640;"	d
CMT_SYNCOUT_DEFAULT_PULSE_WIDTH	cmtdef.h	810;"	d
CMT_SYNCOUT_DISABLED	cmtdef.h	651;"	d
CMT_SYNCOUT_POL_MASK	cmtdef.h	657;"	d
CMT_SYNCOUT_POL_NEG	cmtdef.h	654;"	d
CMT_SYNCOUT_POL_POS	cmtdef.h	655;"	d
CMT_SYNCOUT_TYPE_MASK	cmtdef.h	656;"	d
CMT_SYNCOUT_TYPE_PULSE	cmtdef.h	653;"	d
CMT_SYNCOUT_TYPE_TOGGLE	cmtdef.h	652;"	d
CMT_SYNC_CLOCKFREQMHZ	cmtdef.h	624;"	d
CMT_SYNC_CLOCK_NS_TO_TICKS	cmtdef.h	625;"	d
CMT_SYNC_CLOCK_TICKS_TO_NS	cmtdef.h	626;"	d
CMT_TO_DEFAULT	cmtdef.h	724;"	d
CMT_TO_INIT	cmtdef.h	725;"	d
CMT_TO_RETRY	cmtdef.h	726;"	d
CMT_VALUE_CALIB_ACC	cmtdef.h	509;"	d
CMT_VALUE_CALIB_GYR	cmtdef.h	510;"	d
CMT_VALUE_CALIB_MAG	cmtdef.h	511;"	d
CMT_VALUE_ORIENT_EULER	cmtdef.h	513;"	d
CMT_VALUE_ORIENT_MATRIX	cmtdef.h	514;"	d
CMT_VALUE_ORIENT_QUAT	cmtdef.h	512;"	d
CMT_VALUE_RAW_ACC	cmtdef.h	505;"	d
CMT_VALUE_RAW_GYR	cmtdef.h	506;"	d
CMT_VALUE_RAW_MAG	cmtdef.h	507;"	d
CMT_VALUE_RAW_TEMP	cmtdef.h	508;"	d
CMT_VALUE_SAMPLECNT	cmtdef.h	515;"	d
CMT_VALUE_TEMP	cmtdef.h	516;"	d
CMT_XM_SYNC_MASTER	cmtdef.h	/^	CMT_XM_SYNC_MASTER			= 0x10,$/;"	e	enum:CmtXmSyncMode
CMT_XM_SYNC_OFF	cmtdef.h	/^	CMT_XM_SYNC_OFF				= 0x00,$/;"	e	enum:CmtXmSyncMode
CMT_XM_SYNC_PWM	cmtdef.h	/^	CMT_XM_SYNC_PWM				= 0x01,$/;"	e	enum:CmtXmSyncMode
CMT_XM_SYNC_SLAVE	cmtdef.h	/^	CMT_XM_SYNC_SLAVE			= 0x20,$/;"	e	enum:CmtXmSyncMode
CMT_XM_SYNC_TOGGLE	cmtdef.h	/^	CMT_XM_SYNC_TOGGLE			= 0x30$/;"	e	enum:CmtXmSyncMode
Cmt1f	cmt1.cpp	/^Cmt1f::Cmt1f()$/;"	f	class:xsens::Cmt1f
Cmt1f	cmt1.h	/^class Cmt1f {$/;"	c	namespace:xsens
Cmt1s	cmt1.cpp	/^Cmt1s::Cmt1s() :$/;"	f	class:xsens::Cmt1s
Cmt1s	cmt1.h	/^class Cmt1s {$/;"	c	namespace:xsens
Cmt2f	cmt2.cpp	/^Cmt2f::Cmt2f()$/;"	f	class:xsens::Cmt2f
Cmt2f	cmt2.h	/^class Cmt2f {$/;"	c	namespace:xsens
Cmt2s	cmt2.cpp	/^Cmt2s::Cmt2s() :$/;"	f	class:xsens::Cmt2s
Cmt2s	cmt2.h	/^class Cmt2s {$/;"	c	namespace:xsens
Cmt3	cmt3.cpp	/^Cmt3::Cmt3()$/;"	f	class:xsens::Cmt3
Cmt3	cmt3.h	/^class Cmt3 {$/;"	c	namespace:xsens
CmtAnalogInData	cmtdef.h	/^struct CmtAnalogInData$/;"	s
CmtAnalogInData::m_data	cmtdef.h	/^	uint16_t m_data;$/;"	m	struct:CmtAnalogInData
CmtBinaryData	cmtdef.h	/^struct CmtBinaryData {$/;"	s
CmtBinaryData::m_data	cmtdef.h	/^	uint8_t m_data[CMT_MAXMSGLEN];$/;"	m	struct:CmtBinaryData
CmtBinaryData::m_portNr	cmtdef.h	/^	uint16_t m_portNr;$/;"	m	struct:CmtBinaryData
CmtBinaryData::m_size	cmtdef.h	/^	int32_t m_size;$/;"	m	struct:CmtBinaryData
CmtCalData	cmtdef.h	/^struct CmtCalData {$/;"	s
CmtCalData::m_acc	cmtdef.h	/^	CmtVector	m_acc,m_gyr,m_mag;$/;"	m	struct:CmtCalData
CmtCalData::m_gyr	cmtdef.h	/^	CmtVector	m_acc,m_gyr,m_mag;$/;"	m	struct:CmtCalData
CmtCalData::m_mag	cmtdef.h	/^	CmtVector	m_acc,m_gyr,m_mag;$/;"	m	struct:CmtCalData
CmtCallbackFunction	cmtdef.h	/^typedef void (__cdecl * CmtCallbackFunction)(int32_t instance, int32_t callbackType, void* param, void* userParam);$/;"	t
CmtCallbackSelector	cmtdef.h	1119;"	d
CmtCallbackType	cmtdef.h	/^enum CmtCallbackType {$/;"	g
CmtControlLine	cmtdef.h	/^enum CmtControlLine {$/;"	g
CmtDataFormat	cmtdef.h	/^	CmtDataFormat(	const CmtOutputMode mode = CMT_DEFAULT_OUTPUT_MODE,$/;"	f	struct:CmtDataFormat
CmtDataFormat	cmtdef.h	/^struct CmtDataFormat {$/;"	s
CmtDataFormat::CmtDataFormat	cmtdef.h	/^	CmtDataFormat(	const CmtOutputMode mode = CMT_DEFAULT_OUTPUT_MODE,$/;"	f	struct:CmtDataFormat
CmtDataFormat::m_outputMode	cmtdef.h	/^	CmtOutputMode		m_outputMode;$/;"	m	struct:CmtDataFormat
CmtDataFormat::m_outputSettings	cmtdef.h	/^	CmtOutputSettings	m_outputSettings;$/;"	m	struct:CmtDataFormat
CmtDeviceConfiguration	cmtdef.h	/^struct CmtDeviceConfiguration {$/;"	s
CmtDeviceConfiguration::_devInfo	cmtdef.h	/^	struct _devInfo {$/;"	s	struct:CmtDeviceConfiguration
CmtDeviceConfiguration::_devInfo::m_currentScenario	cmtdef.h	/^		uint16_t	m_currentScenario;$/;"	m	struct:CmtDeviceConfiguration::_devInfo
CmtDeviceConfiguration::_devInfo::m_dataLength	cmtdef.h	/^		uint16_t	m_dataLength;$/;"	m	struct:CmtDeviceConfiguration::_devInfo
CmtDeviceConfiguration::_devInfo::m_deviceId	cmtdef.h	/^		uint32_t	m_deviceId;$/;"	m	struct:CmtDeviceConfiguration::_devInfo
CmtDeviceConfiguration::_devInfo::m_filterMajor	cmtdef.h	/^		uint8_t		m_filterMajor;$/;"	m	struct:CmtDeviceConfiguration::_devInfo
CmtDeviceConfiguration::_devInfo::m_filterMinor	cmtdef.h	/^		uint8_t		m_filterMinor;$/;"	m	struct:CmtDeviceConfiguration::_devInfo
CmtDeviceConfiguration::_devInfo::m_filterType	cmtdef.h	/^		uint8_t		m_filterType;$/;"	m	struct:CmtDeviceConfiguration::_devInfo
CmtDeviceConfiguration::_devInfo::m_fwRevMajor	cmtdef.h	/^		uint8_t		m_fwRevMajor;$/;"	m	struct:CmtDeviceConfiguration::_devInfo
CmtDeviceConfiguration::_devInfo::m_fwRevMinor	cmtdef.h	/^		uint8_t		m_fwRevMinor;$/;"	m	struct:CmtDeviceConfiguration::_devInfo
CmtDeviceConfiguration::_devInfo::m_fwRevRevision	cmtdef.h	/^		uint8_t		m_fwRevRevision;$/;"	m	struct:CmtDeviceConfiguration::_devInfo
CmtDeviceConfiguration::_devInfo::m_outputMode	cmtdef.h	/^		uint16_t	m_outputMode;$/;"	m	struct:CmtDeviceConfiguration::_devInfo
CmtDeviceConfiguration::_devInfo::m_outputSettings	cmtdef.h	/^		uint32_t	m_outputSettings;$/;"	m	struct:CmtDeviceConfiguration::_devInfo
CmtDeviceConfiguration::m_date	cmtdef.h	/^	uint8_t	m_date[8];$/;"	m	struct:CmtDeviceConfiguration
CmtDeviceConfiguration::m_deviceInfo	cmtdef.h	/^	} m_deviceInfo[CMT_MAX_DEVICES_PER_PORT];$/;"	m	struct:CmtDeviceConfiguration	typeref:struct:CmtDeviceConfiguration::_devInfo
CmtDeviceConfiguration::m_masterDeviceId	cmtdef.h	/^	uint32_t	m_masterDeviceId;$/;"	m	struct:CmtDeviceConfiguration
CmtDeviceConfiguration::m_numberOfDevices	cmtdef.h	/^	uint16_t	m_numberOfDevices;$/;"	m	struct:CmtDeviceConfiguration
CmtDeviceConfiguration::m_outputSkipFactor	cmtdef.h	/^	uint16_t	m_outputSkipFactor;$/;"	m	struct:CmtDeviceConfiguration
CmtDeviceConfiguration::m_reservedForClient	cmtdef.h	/^	uint8_t	m_reservedForClient[32];$/;"	m	struct:CmtDeviceConfiguration
CmtDeviceConfiguration::m_reservedForHost	cmtdef.h	/^	uint8_t	m_reservedForHost[32];$/;"	m	struct:CmtDeviceConfiguration
CmtDeviceConfiguration::m_samplingPeriod	cmtdef.h	/^	uint16_t	m_samplingPeriod;$/;"	m	struct:CmtDeviceConfiguration
CmtDeviceConfiguration::m_syncinMode	cmtdef.h	/^	uint16_t	m_syncinMode;$/;"	m	struct:CmtDeviceConfiguration
CmtDeviceConfiguration::m_syncinOffset	cmtdef.h	/^	uint32_t	m_syncinOffset;$/;"	m	struct:CmtDeviceConfiguration
CmtDeviceConfiguration::m_syncinSkipFactor	cmtdef.h	/^	uint16_t	m_syncinSkipFactor;$/;"	m	struct:CmtDeviceConfiguration
CmtDeviceConfiguration::m_time	cmtdef.h	/^	uint8_t	m_time[8];$/;"	m	struct:CmtDeviceConfiguration
CmtDeviceConfiguration::readFromMessage	cmt3.cpp	/^void CmtDeviceConfiguration::readFromMessage(const void* message)$/;"	f	class:CmtDeviceConfiguration
CmtDeviceId	cmtdef.h	/^typedef uint32_t	CmtDeviceId;$/;"	t
CmtDeviceMode	cmtdef.h	/^	CmtDeviceMode(	const CmtOutputMode mode = CMT_DEFAULT_OUTPUT_MODE,$/;"	f	struct:CmtDeviceMode
CmtDeviceMode	cmtdef.h	/^struct CmtDeviceMode {$/;"	s
CmtDeviceMode2	cmtdef.h	/^	CmtDeviceMode2(	const CmtOutputMode mode = CMT_DEFAULT_OUTPUT_MODE,$/;"	f	struct:CmtDeviceMode2
CmtDeviceMode2	cmtdef.h	/^struct CmtDeviceMode2 {$/;"	s
CmtDeviceMode2::CmtDeviceMode2	cmtdef.h	/^	CmtDeviceMode2(	const CmtOutputMode mode = CMT_DEFAULT_OUTPUT_MODE,$/;"	f	struct:CmtDeviceMode2
CmtDeviceMode2::getRealSampleFrequency	cmt3.cpp	/^double CmtDeviceMode2::getRealSampleFrequency(void) const$/;"	f	class:CmtDeviceMode2
CmtDeviceMode2::getSampleFrequency	cmt3.cpp	/^uint16_t CmtDeviceMode2::getSampleFrequency(void) const$/;"	f	class:CmtDeviceMode2
CmtDeviceMode2::m_outputMode	cmtdef.h	/^	CmtOutputMode		m_outputMode;$/;"	m	struct:CmtDeviceMode2
CmtDeviceMode2::m_outputSettings	cmtdef.h	/^	CmtOutputSettings	m_outputSettings;$/;"	m	struct:CmtDeviceMode2
CmtDeviceMode2::m_period	cmtdef.h	/^	uint16_t		m_period;$/;"	m	struct:CmtDeviceMode2
CmtDeviceMode2::m_skip	cmtdef.h	/^	uint16_t		m_skip;$/;"	m	struct:CmtDeviceMode2
CmtDeviceMode2::operator ==	cmt3.cpp	/^bool CmtDeviceMode2::operator == (const CmtDeviceMode2& dev) const$/;"	f	class:CmtDeviceMode2
CmtDeviceMode2::setSampleFrequency	cmt3.cpp	/^void CmtDeviceMode2::setSampleFrequency(uint16_t frequency)$/;"	f	class:CmtDeviceMode2
CmtDeviceMode::CmtDeviceMode	cmtdef.h	/^	CmtDeviceMode(	const CmtOutputMode mode = CMT_DEFAULT_OUTPUT_MODE,$/;"	f	struct:CmtDeviceMode
CmtDeviceMode::getPeriodAndSkipFactor	cmt3.cpp	/^void CmtDeviceMode::getPeriodAndSkipFactor(uint16_t& period,uint16_t& skip) const$/;"	f	class:CmtDeviceMode
CmtDeviceMode::getRealSampleFrequency	cmt3.cpp	/^double CmtDeviceMode::getRealSampleFrequency(void) const$/;"	f	class:CmtDeviceMode
CmtDeviceMode::m_outputMode	cmtdef.h	/^	CmtOutputMode		m_outputMode;$/;"	m	struct:CmtDeviceMode
CmtDeviceMode::m_outputSettings	cmtdef.h	/^	CmtOutputSettings	m_outputSettings;$/;"	m	struct:CmtDeviceMode
CmtDeviceMode::m_sampleFrequency	cmtdef.h	/^	uint16_t		m_sampleFrequency;$/;"	m	struct:CmtDeviceMode
CmtDeviceMode::operator ==	cmt3.cpp	/^bool CmtDeviceMode::operator == (const CmtDeviceMode& dev) const$/;"	f	class:CmtDeviceMode
CmtDeviceMode::setPeriodAndSkipFactor	cmt3.cpp	/^void CmtDeviceMode::setPeriodAndSkipFactor(uint16_t period, uint16_t skip)$/;"	f	class:CmtDeviceMode
CmtEuler	cmtdef.h	/^struct CmtEuler {$/;"	s
CmtEuler::m_pitch	cmtdef.h	/^	double m_pitch;		\/\/!< The pitch (rotation around y-axis \/ right-left-line)$/;"	m	struct:CmtEuler
CmtEuler::m_roll	cmtdef.h	/^	double m_roll;		\/\/!< The roll (rotation around x-axis \/ back-front-line)$/;"	m	struct:CmtEuler
CmtEuler::m_yaw	cmtdef.h	/^	double m_yaw;		\/\/!< The yaw (rotation around z-axis \/ down-up-line)$/;"	m	struct:CmtEuler
CmtGpsPvtData	cmtdef.h	/^struct CmtGpsPvtData {	uint16_t	m_pressure;$/;"	s
CmtGpsPvtData::m_gpsAge	cmtdef.h	/^	uint8_t	m_gpsAge;$/;"	m	struct:CmtGpsPvtData
CmtGpsPvtData::m_hacc	cmtdef.h	/^	uint32_t	m_hacc;$/;"	m	struct:CmtGpsPvtData
CmtGpsPvtData::m_height	cmtdef.h	/^	int32_t		m_height;$/;"	m	struct:CmtGpsPvtData
CmtGpsPvtData::m_itow	cmtdef.h	/^	uint32_t	m_itow;$/;"	m	struct:CmtGpsPvtData
CmtGpsPvtData::m_latitude	cmtdef.h	/^	int32_t		m_latitude;$/;"	m	struct:CmtGpsPvtData
CmtGpsPvtData::m_longitude	cmtdef.h	/^	int32_t		m_longitude;$/;"	m	struct:CmtGpsPvtData
CmtGpsPvtData::m_pressure	cmtdef.h	/^struct CmtGpsPvtData {	uint16_t	m_pressure;$/;"	m	struct:CmtGpsPvtData
CmtGpsPvtData::m_pressureAge	cmtdef.h	/^	uint8_t		m_pressureAge;$/;"	m	struct:CmtGpsPvtData
CmtGpsPvtData::m_sacc	cmtdef.h	/^	uint32_t	m_sacc;$/;"	m	struct:CmtGpsPvtData
CmtGpsPvtData::m_vacc	cmtdef.h	/^	uint32_t	m_vacc;$/;"	m	struct:CmtGpsPvtData
CmtGpsPvtData::m_veld	cmtdef.h	/^	int32_t		m_veld;$/;"	m	struct:CmtGpsPvtData
CmtGpsPvtData::m_vele	cmtdef.h	/^	int32_t		m_vele;$/;"	m	struct:CmtGpsPvtData
CmtGpsPvtData::m_veln	cmtdef.h	/^	int32_t		m_veln;$/;"	m	struct:CmtGpsPvtData
CmtGpsSatelliteInfo	cmtdef.h	/^struct CmtGpsSatelliteInfo {$/;"	s
CmtGpsSatelliteInfo::m_id	cmtdef.h	/^	uint8_t m_id;$/;"	m	struct:CmtGpsSatelliteInfo
CmtGpsSatelliteInfo::m_navigationStatus	cmtdef.h	/^	uint8_t m_navigationStatus;$/;"	m	struct:CmtGpsSatelliteInfo
CmtGpsSatelliteInfo::m_signalQuality	cmtdef.h	/^	uint8_t m_signalQuality;$/;"	m	struct:CmtGpsSatelliteInfo
CmtGpsSatelliteInfo::m_signalStrength	cmtdef.h	/^	uint8_t m_signalStrength;$/;"	m	struct:CmtGpsSatelliteInfo
CmtGpsStatus	cmtdef.h	/^struct CmtGpsStatus {$/;"	s
CmtGpsStatus::m_svInfo	cmtdef.h	/^	CmtGpsSatelliteInfo m_svInfo[CMT_MAX_SVINFO];$/;"	m	struct:CmtGpsStatus
CmtMatrix	cmtdef.h	/^struct CmtMatrix {$/;"	s
CmtMatrix::m_data	cmtdef.h	/^	double m_data[3][3];$/;"	m	struct:CmtMatrix
CmtMtTimeStamp	cmtdef.h	/^typedef uint16_t CmtMtTimeStamp;$/;"	t
CmtOutputMode	cmtdef.h	/^typedef uint32_t CmtOutputMode;$/;"	t
CmtOutputSettings	cmtdef.h	/^typedef uint64_t CmtOutputSettings;$/;"	t
CmtPortInfo	cmtdef.h	/^struct CmtPortInfo {$/;"	s
CmtPortInfo::m_baudrate	cmtdef.h	/^	uint32_t m_baudrate;	\/\/!< The baudrate at which an Xsens device was detected$/;"	m	struct:CmtPortInfo
CmtPortInfo::m_deviceId	cmtdef.h	/^	uint32_t m_deviceId;	\/\/!< The device Id of the detected Xsens device$/;"	m	struct:CmtPortInfo
CmtPortInfo::m_portName	cmtdef.h	/^	char m_portName[256];		\/\/!< The port name$/;"	m	struct:CmtPortInfo
CmtPortInfo::m_portNr	cmtdef.h	/^	uint16_t m_portNr;		\/\/!< The port number$/;"	m	struct:CmtPortInfo
CmtPortInfo::operator <	cmtdef.h	/^	bool operator < (const CmtPortInfo& p) const { return m_portNr < p.m_portNr; }$/;"	f	struct:CmtPortInfo
CmtPortInfo::operator <	cmtdef.h	/^	bool operator < (const CmtPortInfo& p) const { return strcmp(m_portName, p.m_portName) < 0; }$/;"	f	struct:CmtPortInfo
CmtPortInfo::operator ==	cmtdef.h	/^	bool operator == (const CmtPortInfo& p) const { return m_portNr == p.m_portNr; }$/;"	f	struct:CmtPortInfo
CmtPortInfo::operator ==	cmtdef.h	/^	bool operator == (const CmtPortInfo& p) const { return strcmp(m_portName, p.m_portName) == 0; }$/;"	f	struct:CmtPortInfo
CmtPortInfo::operator ==	cmtdef.h	/^	bool operator == (const char *port) const { return strcmp(m_portName, port) == 0; }$/;"	f	struct:CmtPortInfo
CmtPortInfo::operator ==	cmtdef.h	/^	bool operator == (const uint16_t port) const { (void)port; return false; }$/;"	f	struct:CmtPortInfo
CmtPortInfo::operator ==	cmtdef.h	/^	bool operator == (const uint16_t port) const { return m_portNr == port; }$/;"	f	struct:CmtPortInfo
CmtPortInfo::operator >	cmtdef.h	/^	bool operator > (const CmtPortInfo& p) const { return m_portNr > p.m_portNr; }$/;"	f	struct:CmtPortInfo
CmtPortInfo::operator >	cmtdef.h	/^	bool operator > (const CmtPortInfo& p) const { return strcmp(m_portName, p.m_portName) > 0; }$/;"	f	struct:CmtPortInfo
CmtQuat	cmtdef.h	/^struct CmtQuat {$/;"	s
CmtQuat::m_data	cmtdef.h	/^	double m_data[4];$/;"	m	struct:CmtQuat
CmtQueueMode	cmtdef.h	/^enum CmtQueueMode {$/;"	g
CmtRawData	cmtdef.h	/^struct CmtRawData {$/;"	s
CmtRawData::m_acc	cmtdef.h	/^	CmtShortVector	m_acc,m_gyr,m_mag;$/;"	m	struct:CmtRawData
CmtRawData::m_gyr	cmtdef.h	/^	CmtShortVector	m_acc,m_gyr,m_mag;$/;"	m	struct:CmtRawData
CmtRawData::m_mag	cmtdef.h	/^	CmtShortVector	m_acc,m_gyr,m_mag;$/;"	m	struct:CmtRawData
CmtRawData::m_temp	cmtdef.h	/^	uint16_t	m_temp;$/;"	m	struct:CmtRawData
CmtRawGpsData	cmtdef.h	1190;"	d
CmtRawPressureData	cmtdef.h	/^struct CmtRawPressureData {$/;"	s
CmtRawPressureData::m_pressure	cmtdef.h	/^	uint16_t	m_pressure;$/;"	m	struct:CmtRawPressureData
CmtRawPressureData::m_pressureAge	cmtdef.h	/^	uint8_t		m_pressureAge;$/;"	m	struct:CmtRawPressureData
CmtResetMethod	cmtdef.h	/^enum CmtResetMethod {$/;"	g
CmtScenario	cmtdef.h	/^struct CmtScenario {$/;"	s
CmtScenario::m_filterMajor	cmtdef.h	/^	uint8_t m_filterMajor, m_filterMinor;		\/\/!< The version of the XKF filter this scenario is intended for$/;"	m	struct:CmtScenario
CmtScenario::m_filterMinor	cmtdef.h	/^	uint8_t m_filterMajor, m_filterMinor;		\/\/!< The version of the XKF filter this scenario is intended for$/;"	m	struct:CmtScenario
CmtScenario::m_filterType	cmtdef.h	/^	char m_filterType;							\/\/!< The type of the XKF filter this scenario is intended for '3': XKF-3, '6': XKF-6. \\note The value is a character, so XKF-3 is '3', which is hex 0x33$/;"	m	struct:CmtScenario
CmtScenario::m_label	cmtdef.h	/^	char m_label[CMT_LEN_SCENARIOLABEL+1];		\/\/!< The label of the scenario.$/;"	m	struct:CmtScenario
CmtScenario::m_type	cmtdef.h	/^	uint8_t m_type;		\/\/!< The type of the scenario. When set to 255 in an operation, the 'current' scenario is used.$/;"	m	struct:CmtScenario
CmtScenario::m_version	cmtdef.h	/^	uint8_t m_version;	\/\/!< The version of the scenario.$/;"	m	struct:CmtScenario
CmtShortVector	cmtdef.h	/^struct CmtShortVector {$/;"	s
CmtShortVector::m_data	cmtdef.h	/^	uint16_t m_data[3];$/;"	m	struct:CmtShortVector
CmtSyncInSettings	cmtdef.h	/^	CmtSyncInSettings(	const uint16_t mode = 0,$/;"	f	struct:CmtSyncInSettings
CmtSyncInSettings	cmtdef.h	/^struct CmtSyncInSettings {$/;"	s
CmtSyncInSettings::CmtSyncInSettings	cmtdef.h	/^	CmtSyncInSettings(	const uint16_t mode = 0,$/;"	f	struct:CmtSyncInSettings
CmtSyncInSettings::m_mode	cmtdef.h	/^	uint16_t	m_mode;$/;"	m	struct:CmtSyncInSettings
CmtSyncInSettings::m_offset	cmtdef.h	/^	uint32_t	m_offset;		\/\/!< Offset in ns$/;"	m	struct:CmtSyncInSettings
CmtSyncInSettings::m_skipFactor	cmtdef.h	/^	uint16_t	m_skipFactor;$/;"	m	struct:CmtSyncInSettings
CmtSyncOutSettings	cmtdef.h	/^	CmtSyncOutSettings( const uint16_t mode = 0,$/;"	f	struct:CmtSyncOutSettings
CmtSyncOutSettings	cmtdef.h	/^struct CmtSyncOutSettings {$/;"	s
CmtSyncOutSettings::CmtSyncOutSettings	cmtdef.h	/^	CmtSyncOutSettings( const uint16_t mode = 0,$/;"	f	struct:CmtSyncOutSettings
CmtSyncOutSettings::m_mode	cmtdef.h	/^	uint16_t	m_mode;$/;"	m	struct:CmtSyncOutSettings
CmtSyncOutSettings::m_offset	cmtdef.h	/^	uint32_t	m_offset;		\/\/!< Offset in ns$/;"	m	struct:CmtSyncOutSettings
CmtSyncOutSettings::m_pulseWidth	cmtdef.h	/^	uint32_t	m_pulseWidth;	\/\/!< Pulse width in ns$/;"	m	struct:CmtSyncOutSettings
CmtSyncOutSettings::m_skipFactor	cmtdef.h	/^	uint16_t	m_skipFactor;$/;"	m	struct:CmtSyncOutSettings
CmtTimeStamp	cmtdef.h	/^typedef int64_t CmtTimeStamp;$/;"	t
CmtUtcTime	cmtdef.h	/^struct CmtUtcTime$/;"	s
CmtUtcTime::m_day	cmtdef.h	/^	uint8_t	m_day;$/;"	m	struct:CmtUtcTime
CmtUtcTime::m_hour	cmtdef.h	/^	uint8_t	m_hour;$/;"	m	struct:CmtUtcTime
CmtUtcTime::m_minute	cmtdef.h	/^	uint8_t	m_minute;$/;"	m	struct:CmtUtcTime
CmtUtcTime::m_month	cmtdef.h	/^	uint8_t	m_month;$/;"	m	struct:CmtUtcTime
CmtUtcTime::m_nano	cmtdef.h	/^	uint32_t	m_nano;$/;"	m	struct:CmtUtcTime
CmtUtcTime::m_second	cmtdef.h	/^	uint8_t	m_second;$/;"	m	struct:CmtUtcTime
CmtUtcTime::m_valid	cmtdef.h	/^	uint8_t	m_valid;	\/\/!< When set to 1, the time is valid, when set to 2, the time part is valid, but the date may not be valid. when set to 0, the time is invalid and should be ignored.$/;"	m	struct:CmtUtcTime
CmtUtcTime::m_year	cmtdef.h	/^	uint16_t	m_year;$/;"	m	struct:CmtUtcTime
CmtVector	cmtdef.h	/^struct CmtVector {$/;"	s
CmtVector::m_data	cmtdef.h	/^	double m_data[3];$/;"	m	struct:CmtVector
CmtVersion	cmtdef.h	/^struct CmtVersion {$/;"	s
CmtVersion::m_major	cmtdef.h	/^	uint8_t m_major;$/;"	m	struct:CmtVersion
CmtVersion::m_minor	cmtdef.h	/^	uint8_t m_minor;$/;"	m	struct:CmtVersion
CmtVersion::m_revision	cmtdef.h	/^	uint8_t m_revision;$/;"	m	struct:CmtVersion
CmtXmSyncMode	cmtdef.h	/^enum CmtXmSyncMode {$/;"	g
DECL	pstdint.h	786;"	d
DECLI	pstdint.h	784;"	d
DECLU	pstdint.h	783;"	d
DELNUL	xsens_std.h	133;"	d
DEPS	Makefile	/^DEPS = cmt1.h $/;"	m
DO_DATA_REQUEST	cmt3.cpp	234;"	d	file:
DO_DATA_REQUEST_BID	cmt3.cpp	202;"	d	file:
DO_DATA_SET	cmt3.cpp	284;"	d	file:
DO_DATA_SET_BID	cmt3.cpp	240;"	d	file:
EXIT_ERROR	GPSReceive.cpp	26;"	d	file:
EXIT_ERROR	example1s_mt_linux.cpp	27;"	d	file:
EXIT_ERROR	example2s_mt_linux.cpp	23;"	d	file:
EXIT_ERROR	example3s_mt_linux.cpp	27;"	d	file:
EXIT_ERROR	myexample.cpp	22;"	d	file:
EXIT_ON_ERROR	example_linux.cpp	17;"	d	file:
Exception	xsens_exception.cpp	/^Exception::Exception() :$/;"	f	class:xsens::Exception
Exception	xsens_exception.cpp	/^Exception::Exception(const Exception &ex) :$/;"	f	class:xsens::Exception
Exception	xsens_exception.cpp	/^Exception::Exception(const std::string &what) :$/;"	f	class:xsens::Exception
Exception	xsens_exception.h	/^class Exception : public std::exception$/;"	c	namespace:xsens
FORMAT_DOUBLE	cmtpacket.cpp	41;"	d	file:
FREENUL	xsens_std.h	142;"	d
FSEEK	cmt1.cpp	53;"	d	file:
FSEEK	cmt1.cpp	57;"	d	file:
FSEEK_R	cmt1.cpp	54;"	d	file:
FSEEK_R	cmt1.cpp	58;"	d	file:
FTELL	cmt1.cpp	55;"	d	file:
FTELL	cmt1.cpp	59;"	d	file:
FifoQueue	xsens_fifoqueue.h	/^	FifoQueue(const FifoQueue<T,E2>& q)$/;"	f	class:xsens::FifoQueue
FifoQueue	xsens_fifoqueue.h	/^	FifoQueue(size_type size=16, bool delOnOverwrite = true)$/;"	f	class:xsens::FifoQueue
FifoQueue	xsens_fifoqueue.h	/^class FifoQueue {$/;"	c	namespace:xsens
FifoQueueBasic	xsens_fifoqueue.h	/^	FifoQueueBasic(const FifoQueueBasic<T>& q)$/;"	f	class:xsens::FifoQueueBasic
FifoQueueBasic	xsens_fifoqueue.h	/^	FifoQueueBasic(size_type size=16)$/;"	f	class:xsens::FifoQueueBasic
FifoQueueBasic	xsens_fifoqueue.h	/^class FifoQueueBasic {$/;"	c	namespace:xsens
HANDLE	cmt1.h	/^typedef int32_t HANDLE;$/;"	t	namespace:xsens
HANDLE_ERR_RESULT	cmt3.cpp	290;"	d	file:
INT16_C	pstdint.h	268;"	d
INT16_C	pstdint.h	370;"	d
INT16_C	pstdint.h	376;"	d
INT16_MAX	pstdint.h	362;"	d
INT16_MIN	pstdint.h	365;"	d
INT32_C	pstdint.h	262;"	d
INT32_C	pstdint.h	421;"	d
INT32_C	pstdint.h	427;"	d
INT32_C	pstdint.h	433;"	d
INT32_C	pstdint.h	439;"	d
INT32_MAX	pstdint.h	289;"	d
INT32_MAX	pstdint.h	413;"	d
INT32_MIN	pstdint.h	416;"	d
INT64_C	pstdint.h	256;"	d
INT64_C	pstdint.h	462;"	d
INT64_C	pstdint.h	475;"	d
INT64_C	pstdint.h	484;"	d
INT64_C	pstdint.h	493;"	d
INT64_C	pstdint.h	502;"	d
INT64_MAX	pstdint.h	283;"	d
INT64_MAX	pstdint.h	517;"	d
INT64_MIN	pstdint.h	520;"	d
INT8_C	pstdint.h	274;"	d
INT8_C	pstdint.h	334;"	d
INT8_MAX	pstdint.h	326;"	d
INT8_MIN	pstdint.h	329;"	d
INTMAX_C	pstdint.h	569;"	d
INTMAX_C	pstdint.h	585;"	d
INTMAX_MAX	pstdint.h	292;"	d
INTMAX_MAX	pstdint.h	565;"	d
INTMAX_MAX	pstdint.h	582;"	d
INTMAX_MIN	pstdint.h	295;"	d
INTMAX_MIN	pstdint.h	566;"	d
INTPTR_C	pstdint.h	742;"	d
INTPTR_MAX	pstdint.h	736;"	d
INTPTR_MIN	pstdint.h	739;"	d
INT_FAST16_MAX	pstdint.h	665;"	d
INT_FAST16_MIN	pstdint.h	669;"	d
INT_FAST32_MAX	pstdint.h	667;"	d
INT_FAST32_MIN	pstdint.h	670;"	d
INT_FAST64_MAX	pstdint.h	675;"	d
INT_FAST64_MIN	pstdint.h	676;"	d
INT_FAST8_MAX	pstdint.h	663;"	d
INT_FAST8_MIN	pstdint.h	668;"	d
INT_LEAST16_MAX	pstdint.h	616;"	d
INT_LEAST16_MIN	pstdint.h	620;"	d
INT_LEAST32_MAX	pstdint.h	618;"	d
INT_LEAST32_MIN	pstdint.h	621;"	d
INT_LEAST64_MAX	pstdint.h	627;"	d
INT_LEAST64_MIN	pstdint.h	628;"	d
INT_LEAST8_MAX	pstdint.h	614;"	d
INT_LEAST8_MIN	pstdint.h	619;"	d
ISDOUBLE	cmtpacket.cpp	42;"	d	file:
InequalityFunction	xsens_list.h	/^		typedef int32_t (__cdecl * InequalityFunction)(const T&, const T&);$/;"	t	class:xsens::List
Itypes	cmtmessage.cpp	/^union Itypes {$/;"	u	namespace:xsens	file:
JanitorClassFunc	xsens_janitors.h	/^	JanitorClassFunc<T,R>(T& control, t_func_JanitorClassFunc func, bool enabl = true) :$/;"	f	class:xsens::JanitorClassFunc
JanitorClassFunc	xsens_janitors.h	/^class JanitorClassFunc {$/;"	c	namespace:xsens
JanitorClassFuncP1	xsens_janitors.h	/^	JanitorClassFuncP1<T,P1,R>(T& control, P1 p1, t_func_JanitorClassFunc func, bool enabl = true) :$/;"	f	class:xsens::JanitorClassFuncP1
JanitorClassFuncP1	xsens_janitors.h	/^class JanitorClassFuncP1 {$/;"	c	namespace:xsens
LFLAGS	Makefile	/^LFLAGS=-lrt -lpthread$/;"	m
LOGFILE	example1s_mt_linux.cpp	28;"	d	file:
LONG_LONG_MAX	pstdint.h	510;"	d
LSTCHKDELNUL	xsens_std.h	139;"	d
LSTDELNUL	xsens_std.h	137;"	d
List	xsens_list.h	/^	class List$/;"	c	namespace:xsens
List	xsens_list.h	/^List<T>::List()$/;"	f	class:xsens::List
List	xsens_list.h	/^List<T>::List(const List<T>& src)$/;"	f	class:xsens::List
List	xsens_list.h	/^List<T>::List(const uint32_t size, T* src, bool manage)$/;"	f	class:xsens::List
List	xsens_list.h	/^List<T>::List(const uint32_t size, const T* src)$/;"	f	class:xsens::List
List	xsens_list.h	/^List<T>::List(uint32_t size)$/;"	f	class:xsens::List
MSGLOG	cmtmessage.cpp	25;"	d	file:
Message	cmtmessage.cpp	/^Message::Message(const Message& src)$/;"	f	class:xsens::Message
Message	cmtmessage.cpp	/^Message::Message(const uint8_t msgId, const uint16_t length, const uint16_t maxLength)$/;"	f	class:xsens::Message
Message	cmtmessage.cpp	/^Message::Message(const uint8_t* source, const uint16_t size, const uint16_t maxLength)$/;"	f	class:xsens::Message
Message	cmtmessage.h	/^class Message {$/;"	c	namespace:xsens
MessageHeader	cmtmessage.h	/^struct MessageHeader {$/;"	s	namespace:xsens
MillisecondTimer	xsens_time.cpp	/^MillisecondTimer::MillisecondTimer()$/;"	f	class:xsens::MillisecondTimer
MillisecondTimer	xsens_time.h	/^class MillisecondTimer$/;"	c	namespace:xsens
OBJSTATIC	Makefile	/^OBJSTATIC = cmt1.o cmt2.o cmt3.o cmtmessage.o cmtpacket.o cmtscan.o xsens_std.o xsens_time.o xsens_exception.o$/;"	m
PACKETLOG	cmtpacket.cpp	27;"	d	file:
PACKETLOG	cmtpacket.cpp	29;"	d	file:
PATH_MAX	cmt1.cpp	38;"	d	file:
PATH_MAX	cmt1.cpp	39;"	d	file:
PRINTF_INT16_DEC_WIDTH	pstdint.h	237;"	d
PRINTF_INT16_DEC_WIDTH	pstdint.h	550;"	d
PRINTF_INT16_HEX_WIDTH	pstdint.h	225;"	d
PRINTF_INT16_HEX_WIDTH	pstdint.h	537;"	d
PRINTF_INT16_MODIFIER	pstdint.h	213;"	d
PRINTF_INT16_MODIFIER	pstdint.h	347;"	d
PRINTF_INT16_MODIFIER	pstdint.h	354;"	d
PRINTF_INT16_MODIFIER	pstdint.h	372;"	d
PRINTF_INT16_MODIFIER	pstdint.h	378;"	d
PRINTF_INT32_DEC_WIDTH	pstdint.h	234;"	d
PRINTF_INT32_DEC_WIDTH	pstdint.h	547;"	d
PRINTF_INT32_HEX_WIDTH	pstdint.h	222;"	d
PRINTF_INT32_HEX_WIDTH	pstdint.h	534;"	d
PRINTF_INT32_MODIFIER	pstdint.h	207;"	d
PRINTF_INT32_MODIFIER	pstdint.h	209;"	d
PRINTF_INT32_MODIFIER	pstdint.h	392;"	d
PRINTF_INT32_MODIFIER	pstdint.h	399;"	d
PRINTF_INT32_MODIFIER	pstdint.h	405;"	d
PRINTF_INT32_MODIFIER	pstdint.h	423;"	d
PRINTF_INT32_MODIFIER	pstdint.h	429;"	d
PRINTF_INT32_MODIFIER	pstdint.h	435;"	d
PRINTF_INT32_MODIFIER	pstdint.h	441;"	d
PRINTF_INT64_DEC_WIDTH	pstdint.h	231;"	d
PRINTF_INT64_DEC_WIDTH	pstdint.h	544;"	d
PRINTF_INT64_HEX_WIDTH	pstdint.h	219;"	d
PRINTF_INT64_HEX_WIDTH	pstdint.h	531;"	d
PRINTF_INT64_MODIFIER	pstdint.h	200;"	d
PRINTF_INT64_MODIFIER	pstdint.h	202;"	d
PRINTF_INT64_MODIFIER	pstdint.h	464;"	d
PRINTF_INT64_MODIFIER	pstdint.h	477;"	d
PRINTF_INT64_MODIFIER	pstdint.h	486;"	d
PRINTF_INT64_MODIFIER	pstdint.h	495;"	d
PRINTF_INT64_MODIFIER	pstdint.h	504;"	d
PRINTF_INT8_DEC_WIDTH	pstdint.h	240;"	d
PRINTF_INT8_DEC_WIDTH	pstdint.h	553;"	d
PRINTF_INT8_HEX_WIDTH	pstdint.h	228;"	d
PRINTF_INT8_HEX_WIDTH	pstdint.h	540;"	d
PRINTF_INTMAX_DEC_WIDTH	pstdint.h	246;"	d
PRINTF_INTMAX_DEC_WIDTH	pstdint.h	577;"	d
PRINTF_INTMAX_DEC_WIDTH	pstdint.h	593;"	d
PRINTF_INTMAX_HEX_WIDTH	pstdint.h	243;"	d
PRINTF_INTMAX_HEX_WIDTH	pstdint.h	574;"	d
PRINTF_INTMAX_HEX_WIDTH	pstdint.h	590;"	d
PRINTF_INTMAX_MODIFIER	pstdint.h	216;"	d
PRINTF_INTMAX_MODIFIER	pstdint.h	571;"	d
PRINTF_INTMAX_MODIFIER	pstdint.h	587;"	d
PRINTF_INTPTR_MODIFIER	pstdint.h	724;"	d
PRINTF_LEAST16_MODIFIER	pstdint.h	612;"	d
PRINTF_LEAST32_MODIFIER	pstdint.h	611;"	d
PRINTF_LEAST64_MODIFIER	pstdint.h	625;"	d
PTRDIFF_MAX	pstdint.h	727;"	d
PTRDIFF_MIN	pstdint.h	730;"	d
Packet	cmtpacket.cpp	/^Packet::Packet(const Packet& pack)$/;"	f	class:xsens::Packet
Packet	cmtpacket.cpp	/^Packet::Packet(uint16_t items, bool xbus)$/;"	f	class:xsens::Packet
Packet	cmtpacket.h	/^class Packet$/;"	c	namespace:xsens
PacketInfo	cmtpacket.h	/^	mutable struct PacketInfo {$/;"	s	class:xsens::Packet
SAMPLING_FREQ	GPSReceive.cpp	28;"	d	file:
SCANLOG	cmtscan.cpp	44;"	d	file:
SIG_ATOMIC_MAX	pstdint.h	762;"	d
SIZE_MAX	pstdint.h	304;"	d
STDINT_H_UINTPTR_T_DEFINED	pstdint.h	702;"	d
STDINT_H_UINTPTR_T_DEFINED	pstdint.h	754;"	d
TESTUMAX	pstdint.h	788;"	d
TimeStamp	xsens_time.h	/^typedef int64_t TimeStamp;$/;"	t	namespace:xsens
TimeSync	xsens_time.cpp	/^TimeSync::TimeSync(double skew, int historySize)$/;"	f	class:xsens::TimeSync
TimeSync	xsens_time.h	/^class TimeSync {$/;"	c	namespace:xsens
TimeSyncHistoryUnit	xsens_time.cpp	/^struct TimeSyncHistoryUnit {$/;"	s	namespace:xsens	file:
TimeSyncPrivate	xsens_time.cpp	/^class TimeSyncPrivate {$/;"	c	namespace:xsens	file:
UINT16_C	pstdint.h	271;"	d
UINT16_C	pstdint.h	349;"	d
UINT16_C	pstdint.h	352;"	d
UINT16_MAX	pstdint.h	341;"	d
UINT32_C	pstdint.h	265;"	d
UINT32_C	pstdint.h	394;"	d
UINT32_C	pstdint.h	397;"	d
UINT32_C	pstdint.h	403;"	d
UINT32_MAX	pstdint.h	286;"	d
UINT32_MAX	pstdint.h	386;"	d
UINT64_C	pstdint.h	259;"	d
UINT64_C	pstdint.h	461;"	d
UINT64_C	pstdint.h	474;"	d
UINT64_C	pstdint.h	483;"	d
UINT64_C	pstdint.h	492;"	d
UINT64_C	pstdint.h	501;"	d
UINT64_MAX	pstdint.h	280;"	d
UINT64_MAX	pstdint.h	523;"	d
UINT8_C	pstdint.h	277;"	d
UINT8_C	pstdint.h	319;"	d
UINT8_MAX	pstdint.h	314;"	d
UINTMAX_C	pstdint.h	568;"	d
UINTMAX_C	pstdint.h	584;"	d
UINTMAX_MAX	pstdint.h	567;"	d
UINTMAX_MAX	pstdint.h	583;"	d
UINTPTR_C	pstdint.h	745;"	d
UINTPTR_MAX	pstdint.h	733;"	d
UINT_FAST16_MAX	pstdint.h	664;"	d
UINT_FAST32_MAX	pstdint.h	666;"	d
UINT_FAST64_MAX	pstdint.h	674;"	d
UINT_FAST8_MAX	pstdint.h	662;"	d
UINT_LEAST16_MAX	pstdint.h	615;"	d
UINT_LEAST32_MAX	pstdint.h	617;"	d
UINT_LEAST64_MAX	pstdint.h	626;"	d
UINT_LEAST8_MAX	pstdint.h	613;"	d
ULONG_LONG_MAX	pstdint.h	513;"	d
WCHAR_MAX	pstdint.h	692;"	d
WCHAR_MIN	pstdint.h	689;"	d
WITH_SCREEN_DUMP	example1s_mt_linux.cpp	12;"	d	file:
XRV_ABORTED	xsens_std.h	/^	,XRV_ABORTED				= 302	\/\/!< 302: The process was aborted by an external event, usually a user action or process termination$/;"	e	enum:XsensResultValue
XRV_ALREADYDONE	xsens_std.h	/^	,XRV_ALREADYDONE			= 294	\/\/!< 294: The operation is once only and has already been performed$/;"	e	enum:XsensResultValue
XRV_ALREADYOPEN	xsens_std.h	/^	,XRV_ALREADYOPEN			= 269	\/\/!< 269: An I\/O device is already opened with this object$/;"	e	enum:XsensResultValue
XRV_BAUDRATEINVALID	xsens_std.h	/^	,XRV_BAUDRATEINVALID	= 32	\/\/!< 32: Baud rate does not comply with valid range$/;"	e	enum:XsensResultValue
XRV_BUSNOTREADY	xsens_std.h	/^	,XRV_BUSNOTREADY		= 2		\/\/!< 2: InitBus and\/or SetBID are not issued$/;"	e	enum:XsensResultValue
XRV_BUSY	xsens_std.h	/^	,XRV_BUSY					= 276	\/\/!< 276: Busy processing, try again later$/;"	e	enum:XsensResultValue
XRV_CALIBRATIONFAILED	xsens_std.h	/^	,XRV_CALIBRATIONFAILED		= 292	\/\/!< 292: A calibration routine failed$/;"	e	enum:XsensResultValue
XRV_CHECKSUMFAULT	xsens_std.h	/^	,XRV_CHECKSUMFAULT			= 260	\/\/!< 260: Checksum fault occurred$/;"	e	enum:XsensResultValue
XRV_CONFIGCHECKFAIL	xsens_std.h	/^	,XRV_CONFIGCHECKFAIL		= 293	\/\/!< 293: The in-config check of the device failed$/;"	e	enum:XsensResultValue
XRV_COULDNOTREADSETTINGS	xsens_std.h	/^	,XRV_COULDNOTREADSETTINGS	= 271	\/\/!< 271: A required settings file could not be opened or is missing some data$/;"	e	enum:XsensResultValue
XRV_DATACORRUPT	xsens_std.h	/^	,XRV_DATACORRUPT			= 278	\/\/!< 278: A trusted data stream proves to contain corrupted data$/;"	e	enum:XsensResultValue
XRV_DEVICEERROR	xsens_std.h	/^	,XRV_DEVICEERROR		= 40	\/\/!< 40: The device generated an error, try updating the firmware$/;"	e	enum:XsensResultValue
XRV_ENDOFFILE	xsens_std.h	/^	,XRV_ENDOFFILE				= 270	\/\/!< 270: End of file is reached$/;"	e	enum:XsensResultValue
XRV_ERROR	xsens_std.h	/^	,XRV_ERROR					= 256	\/\/!< 256: A generic error occurred$/;"	e	enum:XsensResultValue
XRV_INITBUSFAIL1	xsens_std.h	/^	,XRV_INITBUSFAIL1		= 16	\/\/!< 16: A slave did not respond to WaitForSetBID$/;"	e	enum:XsensResultValue
XRV_INITBUSFAIL2	xsens_std.h	/^	,XRV_INITBUSFAIL2		= 17	\/\/!< 17: An incorrect answer received after WaitForSetBID$/;"	e	enum:XsensResultValue
XRV_INITBUSFAIL3	xsens_std.h	/^	,XRV_INITBUSFAIL3		= 18	\/\/!< 18: After four bus-scans still undetected Motion Trackers$/;"	e	enum:XsensResultValue
XRV_INITFUSIONFAILED	xsens_std.h	/^	,XRV_INITFUSIONFAILED		= 285	\/\/!< 285: Failure during initialization of Fusion Engine$/;"	e	enum:XsensResultValue
XRV_INITPORTFAILED	xsens_std.h	/^	,XRV_INITPORTFAILED			= 291	\/\/!< 291: The low-level port handler failed to initialize$/;"	e	enum:XsensResultValue
XRV_INPUTCANNOTBEOPENED	xsens_std.h	/^	,XRV_INPUTCANNOTBEOPENED	= 267	\/\/!< 267: The specified i\/o device can not be opened$/;"	e	enum:XsensResultValue
XRV_INSUFFICIENTDATA	xsens_std.h	/^	,XRV_INSUFFICIENTDATA		= 275	\/\/!< 275: Insufficient data was supplied to a function$/;"	e	enum:XsensResultValue
XRV_INSUFFICIENTMTS	xsens_std.h	/^	,XRV_INSUFFICIENTMTS		= 284	\/\/!< 284: Not enough sensors were found$/;"	e	enum:XsensResultValue
XRV_INSUFFICIENTSPACE	xsens_std.h	/^	,XRV_INSUFFICIENTSPACE		= 266	\/\/!< 266: Insufficient buffer space available$/;"	e	enum:XsensResultValue
XRV_INVALIDID	xsens_std.h	/^	,XRV_INVALIDID				= 264	\/\/!< 264: Invalid id supplied$/;"	e	enum:XsensResultValue
XRV_INVALIDINSTANCE	xsens_std.h	/^	,XRV_INVALIDINSTANCE		= 277	\/\/!< 277: Invalid instance called$/;"	e	enum:XsensResultValue
XRV_INVALIDMSG	xsens_std.h	/^	,XRV_INVALIDMSG			= 4		\/\/!< 4: The message is invalid or not implemented$/;"	e	enum:XsensResultValue
XRV_INVALIDOPERATION	xsens_std.h	/^	,XRV_INVALIDOPERATION		= 265		\/\/!< 265: Operation is invalid at this point$/;"	e	enum:XsensResultValue
XRV_INVALIDPARAM	xsens_std.h	/^	,XRV_INVALIDPARAM		= 33	\/\/!< 33: An invalid parameter is supplied$/;"	e	enum:XsensResultValue
XRV_INVALIDPERIOD	xsens_std.h	/^	,XRV_INVALIDPERIOD		= 3		\/\/!< 3: Period sent is invalid$/;"	e	enum:XsensResultValue
XRV_MEASUREMENTFAIL1	xsens_std.h	/^	,XRV_MEASUREMENTFAIL1	= 24	\/\/!< 24: Timer overflow - period too short to collect all data from Motion Trackers$/;"	e	enum:XsensResultValue
XRV_MEASUREMENTFAIL2	xsens_std.h	/^	,XRV_MEASUREMENTFAIL2	= 25	\/\/!< 25: Motion Tracker responds with other than SlaveData message$/;"	e	enum:XsensResultValue
XRV_MEASUREMENTFAIL3	xsens_std.h	/^	,XRV_MEASUREMENTFAIL3	= 26	\/\/!< 26: Total bytes of data of Motion Trackers including sample counter exceeds 255 bytes$/;"	e	enum:XsensResultValue
XRV_MEASUREMENTFAIL4	xsens_std.h	/^	,XRV_MEASUREMENTFAIL4	= 27	\/\/!< 27: Timer overflows during measurement$/;"	e	enum:XsensResultValue
XRV_MEASUREMENTFAIL5	xsens_std.h	/^	,XRV_MEASUREMENTFAIL5	= 28	\/\/!< 28: Timer overflows during measurement$/;"	e	enum:XsensResultValue
XRV_MEASUREMENTFAIL6	xsens_std.h	/^	,XRV_MEASUREMENTFAIL6	= 29	\/\/!< 29: No correct response from Motion Tracker during measurement$/;"	e	enum:XsensResultValue
XRV_MEASUREMENTFAIL7	xsens_std.h	/^	,XRV_MEASUREMENTFAIL7	= 35	\/\/!< 35: TX PC Buffer is full$/;"	e	enum:XsensResultValue
XRV_MEASUREMENTFAIL8	xsens_std.h	/^	,XRV_MEASUREMENTFAIL8	= 36	\/\/!< 36: TX PC Buffer overflow, cannot fit full message$/;"	e	enum:XsensResultValue
XRV_MTCOUNTZERO	xsens_std.h	/^	,XRV_MTCOUNTZERO			= 282	\/\/!< 282: No sensors found$/;"	e	enum:XsensResultValue
XRV_MTLOCATIONINVALID	xsens_std.h	/^	,XRV_MTLOCATIONINVALID		= 283	\/\/!< 283: One or more sensors are not where they were expected$/;"	e	enum:XsensResultValue
XRV_NOBUS	xsens_std.h	/^	,XRV_NOBUS				= 1		\/\/!< 1: No bus communication possible$/;"	e	enum:XsensResultValue
XRV_NODATA	xsens_std.h	/^	,XRV_NODATA					= 272	\/\/!< 272: No data is available$/;"	e	enum:XsensResultValue
XRV_NOFILEOPEN	xsens_std.h	/^	,XRV_NOFILEOPEN				= 287	\/\/!< 287: No file opened for reading\/writing$/;"	e	enum:XsensResultValue
XRV_NOFILEORPORTOPEN	xsens_std.h	/^	,XRV_NOFILEORPORTOPEN		= 289	\/\/!< 289: No file or serial port opened for reading\/writing$/;"	e	enum:XsensResultValue
XRV_NOPORTOPEN	xsens_std.h	/^	,XRV_NOPORTOPEN				= 288	\/\/!< 288: No serial port opened for reading\/writing$/;"	e	enum:XsensResultValue
XRV_NOTFOUND	xsens_std.h	/^	,XRV_NOTFOUND				= 262	\/\/!< 262: The requested item was not found$/;"	e	enum:XsensResultValue
XRV_NOTIMPLEMENTED	xsens_std.h	/^	,XRV_NOTIMPLEMENTED			= 257	\/\/!< 257: Operation not implemented in this version (yet)$/;"	e	enum:XsensResultValue
XRV_NOXMFOUND	xsens_std.h	/^	,XRV_NOXMFOUND				= 280	\/\/!< 280: Could not find any MVN-compatible hardware$/;"	e	enum:XsensResultValue
XRV_NULLPTR	xsens_std.h	/^	,XRV_NULLPTR				= 274	\/\/!< 274: Tried to supply a NULL value where it is not allowed$/;"	e	enum:XsensResultValue
XRV_OK	xsens_std.h	/^	 XRV_OK					= 0		\/\/!< 0: Operation was performed successfully$/;"	e	enum:XsensResultValue
XRV_ONLYONEXMFOUND	xsens_std.h	/^	,XRV_ONLYONEXMFOUND			= 281	\/\/!< 281: Found only one responding Xbus Master$/;"	e	enum:XsensResultValue
XRV_OTHER	xsens_std.h	/^	,XRV_OTHER					= 286	\/\/!< 286: Something else was received than was requested$/;"	e	enum:XsensResultValue
XRV_OUTOFMEMORY	xsens_std.h	/^	,XRV_OUTOFMEMORY			= 261	\/\/!< 261: No internal memory available$/;"	e	enum:XsensResultValue
XRV_OUTPUTCANNOTBEOPENED	xsens_std.h	/^	,XRV_OUTPUTCANNOTBEOPENED	= 268	\/\/!< 268: The specified i\/o device can not be opened$/;"	e	enum:XsensResultValue
XRV_PORTNOTFOUND	xsens_std.h	/^	,XRV_PORTNOTFOUND			= 290	\/\/!< 290: A required port could not be found$/;"	e	enum:XsensResultValue
XRV_READINITFAILED	xsens_std.h	/^	,XRV_READINITFAILED			= 279	\/\/!< 279: Failure during read of settings$/;"	e	enum:XsensResultValue
XRV_READONLY	xsens_std.h	/^	,XRV_READONLY				= 273	\/\/!< 273: Tried to change a read-only value$/;"	e	enum:XsensResultValue
XRV_SETBIDFAIL1	xsens_std.h	/^	,XRV_SETBIDFAIL1		= 20	\/\/!< 20: No reply to SetBID message during SetBID procedure$/;"	e	enum:XsensResultValue
XRV_SETBIDFAIL2	xsens_std.h	/^	,XRV_SETBIDFAIL2		= 21	\/\/!< 21: Other than SetBIDAck received$/;"	e	enum:XsensResultValue
XRV_SYNC_DATA_MISSING	xsens_std.h	/^	,XRV_SYNC_DATA_MISSING		= 299	\/\/!< 299: A device is not sending enough data$/;"	e	enum:XsensResultValue
XRV_SYNC_NO_MASTER	xsens_std.h	/^	,XRV_SYNC_NO_MASTER			= 298	\/\/!< 298: No master detected$/;"	e	enum:XsensResultValue
XRV_SYNC_NO_SYNC	xsens_std.h	/^	,XRV_SYNC_NO_SYNC			= 297	\/\/!< 297: A device was detected that was neither master nor slave$/;"	e	enum:XsensResultValue
XRV_SYNC_SECOND_MASTER	xsens_std.h	/^	,XRV_SYNC_SECOND_MASTER		= 296	\/\/!< 296: More than one master was detected$/;"	e	enum:XsensResultValue
XRV_SYNC_SINGLE_SLAVE	xsens_std.h	/^	,XRV_SYNC_SINGLE_SLAVE		= 295	\/\/!< 295: The single connected device is configured as a slave$/;"	e	enum:XsensResultValue
XRV_TIMEOUT	xsens_std.h	/^	,XRV_TIMEOUT				= 258	\/\/!< 258: A timeout occurred$/;"	e	enum:XsensResultValue
XRV_TIMEOUTNODATA	xsens_std.h	/^	,XRV_TIMEOUTNODATA			= 259	\/\/!< 259: Operation aborted because of no data read$/;"	e	enum:XsensResultValue
XRV_TIMEROVERFLOW	xsens_std.h	/^	,XRV_TIMEROVERFLOW		= 30	\/\/!< 30: Timer overflows during measurement$/;"	e	enum:XsensResultValue
XRV_UNEXPECTEDMSG	xsens_std.h	/^	,XRV_UNEXPECTEDMSG			= 263	\/\/!< 263: Unexpected message received (e.g. no acknowledge message received)$/;"	e	enum:XsensResultValue
XRV_VERSION_PROBLEM	xsens_std.h	/^	,XRV_VERSION_PROBLEM		= 301	\/\/!< 301: The object has an unrecognized version, so it's not safe to perform the operation$/;"	e	enum:XsensResultValue
XRV_VERSION_TOO_LOW	xsens_std.h	/^	,XRV_VERSION_TOO_LOW		= 300	\/\/!< 300: The version of the object is too low for the requested operation$/;"	e	enum:XsensResultValue
XSENS_EXCEPTION_H	xsens_exception.h	2;"	d
XSENS_FIFOQUEUE_H	xsens_fifoqueue.h	27;"	d
XSENS_FILEPOS_BEGIN	xsens_file.h	26;"	d
XSENS_FILEPOS_BEGIN	xsens_file.h	30;"	d
XSENS_FILEPOS_CURRENT	xsens_file.h	27;"	d
XSENS_FILEPOS_CURRENT	xsens_file.h	31;"	d
XSENS_FILEPOS_END	xsens_file.h	28;"	d
XSENS_FILEPOS_END	xsens_file.h	32;"	d
XSENS_FILE_H	xsens_file.h	2;"	d
XSENS_JANITORS_H	xsens_janitors.h	27;"	d
XSENS_LABEL_SIZE	xsens_std.h	162;"	d
XSENS_LIST_H	xsens_list.h	32;"	d
XSENS_LIST_LINEAR_SEARCH_TRESHOLD	xsens_list.h	67;"	d
XSENS_LIST_NOTFOUND	xsens_list.h	49;"	d
XSENS_LIST_THROW	xsens_list.h	/^		T& get(const uint32_t index) const XSENS_LIST_THROW;$/;"	m	class:xsens::List
XSENS_LIST_THROW	xsens_list.h	/^		T& last(void) const XSENS_LIST_THROW;$/;"	m	class:xsens::List
XSENS_LIST_THROW	xsens_list.h	/^		T& maxVal(void) const XSENS_LIST_THROW;$/;"	m	class:xsens::List
XSENS_LIST_THROW	xsens_list.h	/^		T& minVal(void) const XSENS_LIST_THROW;$/;"	m	class:xsens::List
XSENS_LIST_THROW	xsens_list.h	/^		T& operator [] (const uint32_t index) const XSENS_LIST_THROW;$/;"	m	class:xsens::List
XSENS_LIST_THROW	xsens_list.h	/^		void deleteAndRemove(const uint32_t index) XSENS_LIST_THROW;$/;"	m	class:xsens::List
XSENS_LIST_THROW	xsens_list.h	/^		void deleteAndRemoveTail(const uint32_t count) XSENS_LIST_THROW;$/;"	m	class:xsens::List
XSENS_LIST_THROW	xsens_list.h	/^		void freeAndRemove(const uint32_t index) XSENS_LIST_THROW;$/;"	m	class:xsens::List
XSENS_LIST_THROW	xsens_list.h	/^		void freeAndRemoveTail(const uint32_t count) XSENS_LIST_THROW;$/;"	m	class:xsens::List
XSENS_LIST_THROW	xsens_list.h	/^		void remove(const uint32_t index) XSENS_LIST_THROW;$/;"	m	class:xsens::List
XSENS_LIST_THROW	xsens_list.h	/^		void removeTail(const uint32_t count) XSENS_LIST_THROW;$/;"	m	class:xsens::List
XSENS_LIST_THROW	xsens_list.h	/^		void swap(const uint32_t i, const uint32_t j) XSENS_LIST_THROW;$/;"	m	class:xsens::List
XSENS_LIST_THROW	xsens_list.h	53;"	d
XSENS_LIST_THROW	xsens_list.h	55;"	d
XSENS_LIST_THROW	xsens_list.h	58;"	d
XSENS_LONG_STRING_SIZE	xsens_std.h	164;"	d
XSENS_MS_PER_DAY	xsens_time.h	15;"	d
XSENS_SEC_PER_DAY	xsens_time.h	13;"	d
XSENS_SHORT_STRING_SIZE	xsens_std.h	163;"	d
XSENS_STD_H	xsens_std.h	20;"	d
XSENS_TIMESTAMP_MAX	xsens_time.h	17;"	d
XSENS_TIME_H	xsens_time.h	2;"	d
XsensFilePos	xsens_file.h	/^	typedef  __int64	XsensFilePos;$/;"	t
XsensFilePos	xsens_file.h	/^	typedef  __off64_t		XsensFilePos;$/;"	t
XsensResultValue	xsens_std.h	/^enum XsensResultValue {$/;"	g
_CRT_SECURE_NO_DEPRECATE	cmt1.cpp	46;"	d	file:
_PSTDINT_H_INCLUDED	pstdint.h	197;"	d
_PSTDINT_H_INCLUDED	pstdint.h	301;"	d
_WIN32_WINNT	xsens_std.h	25;"	d
_XM_SMALL_PACKETS_EMTS	cmt3.cpp	682;"	d	file:
__EXAMPLE_LINUX_H	example_linux.h	2;"	d
__cdecl	cmtdef.h	51;"	d
__cdecl	xsens_janitors.h	31;"	d
__stdcall	cmtdef.h	52;"	d
__stdcall	xsens_janitors.h	32;"	d
_devInfo	cmtdef.h	/^	struct _devInfo {$/;"	s	struct:CmtDeviceConfiguration
_mdl	cmtmessage.h	/^	union _mdl {$/;"	u	struct:xsens::MessageHeader
_mextd	cmtmessage.h	/^		struct _mextd {$/;"	s	union:xsens::MessageHeader::_mdl
_mlen	cmtmessage.h	/^			struct _mlen {$/;"	s	struct:xsens::MessageHeader::_mdl::_mextd
_strnicmp	cmt1.h	38;"	d
_wcsnicmp	cmt1.cpp	/^int _wcsnicmp(const wchar_t* s1, const wchar_t* s2,int count)$/;"	f	namespace:xsens
abortScan	cmtscan.cpp	/^bool abortScan = false;$/;"	m	namespace:xsens	file:
addHistoryItem	xsens_time.cpp	/^void TimeSyncPrivate::addHistoryItem(const TimeSyncHistoryUnit& tu)$/;"	f	class:xsens::TimeSyncPrivate
append	xsens_list.h	/^void List<T>::append(const T& item)$/;"	f	class:xsens::List
appendCopy	xsens_list.h	/^void List<T>::appendCopy(const TB& item)$/;"	f	class:xsens::List
appendData	cmt1.cpp	/^XsensResultValue Cmt1f::appendData (const uint32_t length,  const void* data)$/;"	f	class:xsens::Cmt1f
appendDeepCopy	xsens_list.h	/^void List<T>::appendDeepCopy(const List<T>& source)$/;"	f	class:xsens::List
appendList	xsens_list.h	/^void List<T>::appendList(uint32_t count, const T* lst)$/;"	f	class:xsens::List
appendRelated	xsens_list.h	/^void List<T>::appendRelated(const TR& item)$/;"	f	class:xsens::List
appendShallowCopy	xsens_list.h	/^void List<T>::appendShallowCopy(const List<T>& source)$/;"	f	class:xsens::List
b0	cmtmessage.cpp	/^		signed char b7,b6,b5,b4,b3,b2,b1,b0;$/;"	m	struct:xsens::Itypes::__anon3	file:
b1	cmtmessage.cpp	/^		signed char b7,b6,b5,b4,b3,b2,b1,b0;$/;"	m	struct:xsens::Itypes::__anon3	file:
b2	cmtmessage.cpp	/^		signed char b7,b6,b5,b4,b3,b2,b1,b0;$/;"	m	struct:xsens::Itypes::__anon3	file:
b3	cmtmessage.cpp	/^		signed char b7,b6,b5,b4,b3,b2,b1,b0;$/;"	m	struct:xsens::Itypes::__anon3	file:
b4	cmtmessage.cpp	/^		signed char b7,b6,b5,b4,b3,b2,b1,b0;$/;"	m	struct:xsens::Itypes::__anon3	file:
b5	cmtmessage.cpp	/^		signed char b7,b6,b5,b4,b3,b2,b1,b0;$/;"	m	struct:xsens::Itypes::__anon3	file:
b6	cmtmessage.cpp	/^		signed char b7,b6,b5,b4,b3,b2,b1,b0;$/;"	m	struct:xsens::Itypes::__anon3	file:
b7	cmtmessage.cpp	/^		signed char b7,b6,b5,b4,b3,b2,b1,b0;$/;"	m	struct:xsens::Itypes::__anon3	file:
back	xsens_fifoqueue.h	/^	const value_type& back() const$/;"	f	class:xsens::FifoQueue
back	xsens_fifoqueue.h	/^	const value_type& back() const$/;"	f	class:xsens::FifoQueueBasic
back	xsens_fifoqueue.h	/^	value_type& back()$/;"	f	class:xsens::FifoQueue
back	xsens_fifoqueue.h	/^	value_type& back()$/;"	f	class:xsens::FifoQueueBasic
calcChecksum	cmtmessage.h	/^	uint8_t calcChecksum(void) const$/;"	f	class:xsens::Message
calcScreenOffset	example_linux.cpp	/^int calcScreenOffset(CmtOutputMode &mode, CmtOutputSettings &settings, $/;"	f
clear	cmtmessage.cpp	/^void Message::clear(void)$/;"	f	class:xsens::Message
clear	xsens_fifoqueue.h	/^	void clear(void)$/;"	f	class:xsens::FifoQueue
clear	xsens_fifoqueue.h	/^	void clear(void)$/;"	f	class:xsens::FifoQueueBasic
clear	xsens_list.h	/^void List<T>::clear(void)$/;"	f	class:xsens::List
clearHwError	cmt3.h	/^	void clearHwError(void)									\/\/!< \\brief Reset the hardware error code. \\details Use this function to reset the hardware error code reported by getHwError. \\see getHwError$/;"	f	class:xsens::Cmt3
clock_gettime	xsens_time.cpp	/^static int clock_gettime(int clk_id, struct timespec *tp)$/;"	f	namespace:xsens
close	cmt1.cpp	/^XsensResultValue Cmt1f::close (void)$/;"	f	class:xsens::Cmt1f
close	cmt1.cpp	/^XsensResultValue Cmt1s::close (void)$/;"	f	class:xsens::Cmt1s
close	cmt2.cpp	/^XsensResultValue Cmt2f::close(void)$/;"	f	class:xsens::Cmt2f
close	cmt2.cpp	/^XsensResultValue Cmt2s::close(void)$/;"	f	class:xsens::Cmt2s
closeAndDelete	cmt1.cpp	/^XsensResultValue Cmt1f::closeAndDelete(void)$/;"	f	class:xsens::Cmt1f
closeAndDelete	cmt2.cpp	/^XsensResultValue Cmt2f::closeAndDelete(void)$/;"	f	class:xsens::Cmt2f
closeLogFile	cmt3.cpp	/^XsensResultValue Cmt3::closeLogFile(bool del)$/;"	f	class:xsens::Cmt3
closePort	cmt3.cpp	/^XsensResultValue Cmt3::closePort(bool gotoConfigFirst)$/;"	f	class:xsens::Cmt3
cmpFunc	xsens_list.h	/^		typedef int32_t (*cmpFunc) (const T&,const T&);$/;"	t	class:xsens::List
cmtScanPort	cmtscan.cpp	/^bool cmtScanPort(CmtPortInfo& portInfo, uint32_t baud, uint32_t singleScanTimeout, uint32_t scanTries)$/;"	f	namespace:xsens
cmtScanPorts	cmtscan.cpp	/^bool cmtScanPorts(List<CmtPortInfo>& ports,uint32_t baudrate, uint32_t singleScanTimeout, uint32_t scanTries, bool ignoreNonXsensDevices)$/;"	f	namespace:xsens
computeChecksum	cmtmessage.cpp	/^uint8_t computeChecksum(const uint8_t* buffer, uint32_t length)$/;"	f	namespace:xsens
containsAccG	cmtpacket.cpp	/^bool Packet::containsAccG(const uint16_t index) const$/;"	f	class:xsens::Packet
containsAnalogIn1	cmtpacket.cpp	/^bool Packet::containsAnalogIn1(const uint16_t index) const$/;"	f	class:xsens::Packet
containsAnalogIn2	cmtpacket.cpp	/^bool Packet::containsAnalogIn2(const uint16_t index) const$/;"	f	class:xsens::Packet
containsCalAcc	cmtpacket.cpp	/^bool Packet::containsCalAcc(const uint16_t index) const$/;"	f	class:xsens::Packet
containsCalData	cmtpacket.cpp	/^bool Packet::containsCalData(const uint16_t index) const$/;"	f	class:xsens::Packet
containsCalGyr	cmtpacket.cpp	/^bool Packet::containsCalGyr(const uint16_t index) const$/;"	f	class:xsens::Packet
containsCalMag	cmtpacket.cpp	/^bool Packet::containsCalMag(const uint16_t index) const$/;"	f	class:xsens::Packet
containsGpsPvtData	cmtpacket.cpp	/^bool Packet::containsGpsPvtData(const uint16_t index) const$/;"	f	class:xsens::Packet
containsOri	cmtpacket.cpp	/^bool Packet::containsOri(const uint16_t index) const$/;"	f	class:xsens::Packet
containsOriEuler	cmtpacket.cpp	/^bool Packet::containsOriEuler(const uint16_t index) const$/;"	f	class:xsens::Packet
containsOriMatrix	cmtpacket.cpp	/^bool Packet::containsOriMatrix(const uint16_t index) const$/;"	f	class:xsens::Packet
containsOriQuat	cmtpacket.cpp	/^bool Packet::containsOriQuat(const uint16_t index) const$/;"	f	class:xsens::Packet
containsPositionLLA	cmtpacket.cpp	/^bool Packet::containsPositionLLA(const uint16_t index) const$/;"	f	class:xsens::Packet
containsRawAcc	cmtpacket.cpp	/^bool Packet::containsRawAcc(const uint16_t index) const$/;"	f	class:xsens::Packet
containsRawData	cmtpacket.cpp	/^bool Packet::containsRawData(const uint16_t index) const$/;"	f	class:xsens::Packet
containsRawGpsData	cmtpacket.h	187;"	d
containsRawGyr	cmtpacket.cpp	/^bool Packet::containsRawGyr(const uint16_t index) const$/;"	f	class:xsens::Packet
containsRawMag	cmtpacket.cpp	/^bool Packet::containsRawMag(const uint16_t index) const$/;"	f	class:xsens::Packet
containsRawPressureData	cmtpacket.cpp	/^bool Packet::containsRawPressureData(const uint16_t index) const$/;"	f	class:xsens::Packet
containsRawTemp	cmtpacket.cpp	/^bool Packet::containsRawTemp(const uint16_t index) const$/;"	f	class:xsens::Packet
containsSampleCounter	cmtpacket.cpp	/^bool Packet::containsSampleCounter(const uint16_t index) const$/;"	f	class:xsens::Packet
containsStatus	cmtpacket.cpp	/^bool Packet::containsStatus(const uint16_t index) const$/;"	f	class:xsens::Packet
containsTemp	cmtpacket.cpp	/^bool Packet::containsTemp(const uint16_t index) const$/;"	f	class:xsens::Packet
containsUtcTime	cmtpacket.cpp	/^bool Packet::containsUtcTime(const uint16_t index) const$/;"	f	class:xsens::Packet
containsVelocity	cmtpacket.cpp	/^bool Packet::containsVelocity(const uint16_t index) const$/;"	f	class:xsens::Packet
count	xsens_list.h	/^		uint32_t count(void) const { return m_count; }$/;"	f	class:xsens::List
create	cmt1.cpp	/^XsensResultValue Cmt1f::create (const char* filename)$/;"	f	class:xsens::Cmt1f
create	cmt1.cpp	/^XsensResultValue Cmt1f::create (const wchar_t* filename)$/;"	f	class:xsens::Cmt1f
create	cmt2.cpp	/^XsensResultValue Cmt2f::create(const char* filename)$/;"	f	class:xsens::Cmt2f
create	cmt2.cpp	/^XsensResultValue Cmt2f::create(const wchar_t* filename)$/;"	f	class:xsens::Cmt2f
createLogFile	cmt3.cpp	/^XsensResultValue Cmt3::createLogFile(const char* filename, bool startLogging)$/;"	f	class:xsens::Cmt3
createLogFile	cmt3.cpp	/^XsensResultValue Cmt3::createLogFile(const wchar_t* filename, bool startLogging)$/;"	f	class:xsens::Cmt3
ctrlchandler	GPSReceive.cpp	/^void ctrlchandler(int sig)$/;"	f
ctrlchandler	example2s_mt_linux.cpp	/^void ctrlchandler(int sig)$/;"	f
ctrlchandler	example3s_mt_linux.cpp	/^void ctrlchandler(int sig)$/;"	f
ctrlchandler	myexample.cpp	/^void ctrlchandler(int sig)$/;"	f
d	cmtmessage.cpp	/^	double d;$/;"	m	union:xsens::Itypes	file:
d	xsens_time.h	/^	TimeSyncPrivate* d;$/;"	m	class:xsens::TimeSync
debug_log_fp	cmt1.cpp	/^			FILE* debug_log_fp = NULL;$/;"	m	namespace:xsens	file:
debug_log_valid	cmt1.cpp	/^			int32_t debug_log_valid = 0;$/;"	m	namespace:xsens	file:
debug_qlog_fp	cmt1.cpp	/^			FILE* debug_qlog_fp = NULL;$/;"	m	namespace:xsens	file:
debug_qlog_valid	cmt1.cpp	/^			int32_t debug_qlog_valid = 0;$/;"	m	namespace:xsens	file:
deleteAndClear	xsens_list.h	/^void List<T>::deleteAndClear(void)$/;"	f	class:xsens::List
deleteData	cmt1.cpp	/^XsensResultValue Cmt1f::deleteData (const XsensFilePos start, const uint32_t length)$/;"	f	class:xsens::Cmt1f
deleteData	cmtmessage.cpp	/^void Message::deleteData(uint16_t size, uint16_t offset)$/;"	f	class:xsens::Message
deleteItemsOnDestroy	xsens_list.h	/^void List<T>::deleteItemsOnDestroy(void)$/;"	f	class:xsens::List
disable	xsens_janitors.h	/^	void disable(void)$/;"	f	class:xsens::JanitorClassFunc
disable	xsens_janitors.h	/^	void disable(void)$/;"	f	class:xsens::JanitorClassFuncP1
doHardwareScan	example_linux.cpp	/^int doHardwareScan(xsens::Cmt3 &cmt3, CmtDeviceId deviceIds[])$/;"	f
doMtSettings	example_linux.cpp	/^void doMtSettings(xsens::Cmt3 &cmt3, CmtOutputMode &mode, $/;"	f
doquit	example1s_mt_linux.cpp	/^void doquit(int sig)$/;"	f
empty	xsens_fifoqueue.h	/^	bool empty() const$/;"	f	class:xsens::FifoQueue
empty	xsens_fifoqueue.h	/^	bool empty() const$/;"	f	class:xsens::FifoQueueBasic
enable	xsens_janitors.h	/^	void enable(void)$/;"	f	class:xsens::JanitorClassFunc
enable	xsens_janitors.h	/^	void enable(void)$/;"	f	class:xsens::JanitorClassFuncP1
eraseAndClear	xsens_fifoqueue.h	/^	void eraseAndClear(void)$/;"	f	class:xsens::FifoQueue
eraseAndClear	xsens_fifoqueue.h	/^	void eraseAndClear(void)$/;"	f	class:xsens::FifoQueueBasic
escape	cmt1.cpp	/^XsensResultValue Cmt1s::escape (const CmtControlLine mask, const CmtControlLine state)$/;"	f	class:xsens::Cmt1s
exitFunc	GPSReceive.cpp	/^void exitFunc(void)$/;"	f
exitFunc	example3s_mt_linux.cpp	/^void exitFunc(void)$/;"	f
exitFunc	myexample.cpp	/^void exitFunc(void)$/;"	f
exitFunc1	example1s_mt_linux.cpp	/^void exitFunc1(void)$/;"	f
externalTime	xsens_time.cpp	/^TimeStamp TimeSync::externalTime(TimeStamp tLi)$/;"	f	class:xsens::TimeSync
f0	cmtmessage.cpp	/^		float f1,f0;$/;"	m	struct:xsens::Itypes::__anon4	file:
f1	cmtmessage.cpp	/^		float f1,f0;$/;"	m	struct:xsens::Itypes::__anon4	file:
f32	cmtmessage.cpp	/^	} f32;$/;"	m	union:xsens::Itypes	typeref:struct:xsens::Itypes::__anon4	file:
fillRtc	cmt3.cpp	/^void Cmt3::fillRtc(Packet* pack)$/;"	f	class:xsens::Cmt3
find	cmt1.cpp	/^XsensResultValue Cmt1f::find (const void* needleV, const uint32_t needleLength, XsensFilePos& pos)$/;"	f	class:xsens::Cmt1f
find	xsens_list.h	/^uint32_t List<T>::find(const T item, InequalityFunction fnc) const$/;"	f	class:xsens::List
find	xsens_list.h	/^uint32_t List<T>::find(const TB& item) const$/;"	f	class:xsens::List
findDeref	xsens_list.h	/^uint32_t List<T>::findDeref(const TB& item) const$/;"	f	class:xsens::List
findSorted	xsens_list.h	/^uint32_t List<T>::findSorted(const TB& item) const$/;"	f	class:xsens::List
findSortedDeref	xsens_list.h	/^uint32_t List<T>::findSortedDeref(const TB& item) const$/;"	f	class:xsens::List
findSortedDerefForInsert	xsens_list.h	/^uint32_t List<T>::findSortedDerefForInsert(const TB& item) const$/;"	f	class:xsens::List
findSortedForInsert	xsens_list.h	/^uint32_t List<T>::findSortedForInsert(const TB& item) const$/;"	f	class:xsens::List
findValidMessage	cmt2.cpp	/^int32_t findValidMessage(const uint8_t* buffer, const uint16_t bufferLength)$/;"	f	namespace:xsens
firstIndex	xsens_time.cpp	/^int TimeSyncPrivate::firstIndex() const$/;"	f	class:xsens::TimeSyncPrivate
flushData	cmt1.cpp	/^XsensResultValue Cmt1f::flushData (void)$/;"	f	class:xsens::Cmt1f
flushData	cmt1.cpp	/^XsensResultValue Cmt1s::flushData (void)$/;"	f	class:xsens::Cmt1s
freeAndClear	xsens_list.h	/^void List<T>::freeAndClear(void)$/;"	f	class:xsens::List
freeItemsOnDestroy	xsens_list.h	/^void List<T>::freeItemsOnDestroy(void)$/;"	f	class:xsens::List
front	xsens_fifoqueue.h	/^	const value_type& front() const$/;"	f	class:xsens::FifoQueue
front	xsens_fifoqueue.h	/^	const value_type& front() const$/;"	f	class:xsens::FifoQueueBasic
front	xsens_fifoqueue.h	/^	value_type& front()$/;"	f	class:xsens::FifoQueue
front	xsens_fifoqueue.h	/^	value_type& front()$/;"	f	class:xsens::FifoQueueBasic
getAccG	cmtpacket.cpp	/^CmtVector Packet::getAccG(const uint16_t index) const$/;"	f	class:xsens::Packet
getAnalogIn1	cmtpacket.cpp	/^CmtAnalogInData Packet::getAnalogIn1(const uint16_t index) const$/;"	f	class:xsens::Packet
getAnalogIn2	cmtpacket.cpp	/^CmtAnalogInData Packet::getAnalogIn2(const uint16_t index) const$/;"	f	class:xsens::Packet
getAvailableScenarios	cmt3.cpp	/^XsensResultValue Cmt3::getAvailableScenarios(CmtScenario* scenarios, const CmtDeviceId deviceId)$/;"	f	class:xsens::Cmt3
getBatteryLevel	cmt3.cpp	/^XsensResultValue Cmt3::getBatteryLevel(uint8_t& level)$/;"	f	class:xsens::Cmt3
getBaudrate	cmt1.cpp	/^uint32_t Cmt1s::getBaudrate(void) const { return m_baudrate; }$/;"	f	class:xsens::Cmt1s
getBaudrate	cmt2.h	/^	uint32_t getBaudrate(void) { return (m_baudrate = m_cmt1s.getBaudrate()); }$/;"	f	class:xsens::Cmt2s
getBaudrate	cmt3.cpp	/^XsensResultValue Cmt3::getBaudrate(uint32_t& baudrate)$/;"	f	class:xsens::Cmt3
getBluetoothState	cmt3.cpp	/^XsensResultValue Cmt3::getBluetoothState(bool& enabled)$/;"	f	class:xsens::Cmt3
getBuffer	xsens_list.h	/^		const T* getBuffer(void) const { return m_data; }$/;"	f	class:xsens::List
getBusId	cmt3.cpp	/^XsensResultValue Cmt3::getBusId (uint8_t& busId, const CmtDeviceId deviceId) const$/;"	f	class:xsens::Cmt3
getBusId	cmtmessage.h	/^	uint8_t getBusId(void) const { return m_buffer->m_busId; }$/;"	f	class:xsens::Message
getBusIdInternal	cmt3.cpp	/^uint8_t Cmt3::getBusIdInternal(const CmtDeviceId devId) const$/;"	f	class:xsens::Cmt3
getBusPowerState	cmt3.cpp	/^XsensResultValue Cmt3::getBusPowerState(bool& enabled)$/;"	f	class:xsens::Cmt3
getCalAcc	cmtpacket.cpp	/^CmtVector Packet::getCalAcc(const uint16_t index) const$/;"	f	class:xsens::Packet
getCalData	cmtpacket.cpp	/^CmtCalData Packet::getCalData(const uint16_t index) const$/;"	f	class:xsens::Packet
getCalGyr	cmtpacket.cpp	/^CmtVector Packet::getCalGyr(const uint16_t index) const$/;"	f	class:xsens::Packet
getCalMag	cmtpacket.cpp	/^CmtVector Packet::getCalMag(const uint16_t index) const$/;"	f	class:xsens::Packet
getCmt1f	cmt2.cpp	/^Cmt1f* Cmt2f::getCmt1f(void)$/;"	f	class:xsens::Cmt2f
getCmt1s	cmt2.h	/^	Cmt1s* getCmt1s(void) { return &m_cmt1s; }$/;"	f	class:xsens::Cmt2s
getCmt2f	cmt3.cpp	/^Cmt2f* Cmt3::getCmt2f(void)$/;"	f	class:xsens::Cmt3
getCmt2s	cmt3.cpp	/^Cmt2s* Cmt3::getCmt2s(void)$/;"	f	class:xsens::Cmt3
getConfiguration	cmt3.cpp	/^XsensResultValue Cmt3::getConfiguration(CmtDeviceConfiguration& configuration)$/;"	f	class:xsens::Cmt3
getDataBuffer	cmtmessage.h	/^	const uint8_t* getDataBuffer(const uint16_t offset = 0) const$/;"	f	class:xsens::Message
getDataBuffer	cmtmessage.h	/^	uint8_t* getDataBuffer(const uint16_t offset = 0)$/;"	f	class:xsens::Message
getDataByte	cmtmessage.h	/^	uint8_t getDataByte(const uint16_t offset = 0) const$/;"	f	class:xsens::Message
getDataDouble	cmtmessage.cpp	/^double Message::getDataDouble(const uint16_t offset) const$/;"	f	class:xsens::Message
getDataF1220	cmtmessage.cpp	/^double Message::getDataF1220(const uint16_t offset) const$/;"	f	class:xsens::Message
getDataFP1632	cmtmessage.cpp	/^double Message::getDataFP1632(const uint16_t offset) const$/;"	f	class:xsens::Message
getDataFPValue	cmtmessage.cpp	/^double Message::getDataFPValue(const uint64_t outputSettings, const uint16_t offset) const$/;"	f	class:xsens::Message
getDataFPValue	cmtmessage.cpp	/^void Message::getDataFPValue(double *dest, const uint64_t outputSettings, uint16_t offset, const int16_t numValues) const$/;"	f	class:xsens::Message
getDataFloat	cmtmessage.cpp	/^float Message::getDataFloat(const uint16_t offset) const$/;"	f	class:xsens::Message
getDataFormat	cmtpacket.cpp	/^CmtDataFormat Packet::getDataFormat(const uint16_t index) const$/;"	f	class:xsens::Packet
getDataLength	cmt3.cpp	/^XsensResultValue Cmt3::getDataLength(uint32_t& length, const CmtDeviceId deviceId)$/;"	f	class:xsens::Cmt3
getDataLong	cmtmessage.cpp	/^uint32_t Message::getDataLong(const uint16_t offset) const$/;"	f	class:xsens::Message
getDataShort	cmtmessage.cpp	/^uint16_t Message::getDataShort(const uint16_t offset) const$/;"	f	class:xsens::Message
getDataSize	cmtmessage.cpp	/^uint16_t Message::getDataSize(void) const$/;"	f	class:xsens::Message
getDataSize	cmtpacket.cpp	/^uint16_t Packet::getDataSize(const uint16_t index) const$/;"	f	class:xsens::Packet
getDataStart	cmtmessage.cpp	/^uint8_t* Message::getDataStart(void) const$/;"	f	class:xsens::Message
getDateAsString	xsens_time.cpp	/^void getDateAsString(uint8_t *dest, const tm* date)$/;"	f	namespace:xsens
getDateTime	xsens_time.cpp	/^int64_t getDateTime(tm *date)$/;"	f	namespace:xsens
getDeviceCount	cmt3.cpp	/^uint32_t Cmt3::getDeviceCount (void) const$/;"	f	class:xsens::Cmt3
getDeviceId	cmt3.cpp	/^XsensResultValue Cmt3::getDeviceId(const uint8_t busId, CmtDeviceId& deviceId) const$/;"	f	class:xsens::Cmt3
getDeviceMode	cmt3.cpp	/^XsensResultValue Cmt3::getDeviceMode(CmtDeviceMode& mode, const CmtDeviceId deviceId)$/;"	f	class:xsens::Cmt3
getDeviceMode2	cmt3.cpp	/^XsensResultValue Cmt3::getDeviceMode2(CmtDeviceMode2& mode, const CmtDeviceId deviceId)$/;"	f	class:xsens::Cmt3
getEMtsData	cmt3.cpp	/^XsensResultValue Cmt3::getEMtsData(void* buffer, const CmtDeviceId deviceId)$/;"	f	class:xsens::Cmt3
getErrorMode	cmt3.cpp	/^XsensResultValue Cmt3::getErrorMode(uint16_t& mode, const CmtDeviceId deviceId)$/;"	f	class:xsens::Cmt3
getFPValueSize	cmtpacket.cpp	/^uint16_t Packet::getFPValueSize(const uint16_t index) const$/;"	f	class:xsens::Packet
getFileSize	cmt1.h	/^	XsensFilePos getFileSize(void) const { return m_fileSize; }$/;"	f	class:xsens::Cmt1f
getFileSize	cmt2.cpp	/^XsensFilePos Cmt2f::getFileSize(void)$/;"	f	class:xsens::Cmt2f
getFirmwareRevision	cmt3.cpp	/^XsensResultValue Cmt3::getFirmwareRevision(CmtVersion& revision, const CmtDeviceId deviceId)$/;"	f	class:xsens::Cmt3
getGpsLeverArm	cmt3.cpp	/^XsensResultValue Cmt3::getGpsLeverArm(CmtVector& arm, const CmtDeviceId deviceId)$/;"	f	class:xsens::Cmt3
getGpsPvtData	cmtpacket.cpp	/^CmtGpsPvtData Packet::getGpsPvtData(const uint16_t index) const$/;"	f	class:xsens::Packet
getGpsStatus	cmt3.cpp	/^XsensResultValue Cmt3::getGpsStatus(CmtGpsStatus& status, const CmtDeviceId deviceId)$/;"	f	class:xsens::Cmt3
getGravityMagnitude	cmt3.cpp	/^XsensResultValue Cmt3::getGravityMagnitude(double& magnitude, const CmtDeviceId deviceId)$/;"	f	class:xsens::Cmt3
getHandle	cmt1.cpp	/^HANDLE Cmt1s::getHandle(void) const { return m_handle; }$/;"	f	class:xsens::Cmt1s
getHeading	cmt3.cpp	/^XsensResultValue Cmt3::getHeading(double& heading, const CmtDeviceId deviceId)$/;"	f	class:xsens::Cmt3
getHwError	cmt3.h	/^	XsensResultValue getHwError(CmtDeviceId& did) const		\/\/!< \\brief Return the last Hardware error code. \\details This function returns the XsensResultValue of the last problem reported by hardware (if any). Hardware problems are all 'error' messages returned by a sensor. \\param did If any problems were found, the responsible device ID will be returned in this parameter. \\see clearHwError$/;"	f	class:xsens::Cmt3
getLastResult	cmt1.cpp	/^XsensResultValue Cmt1s::getLastResult(void) const { return m_lastResult; }$/;"	f	class:xsens::Cmt1s
getLastResult	cmt1.h	/^	XsensResultValue getLastResult(void) const	{ return m_lastResult; }$/;"	f	class:xsens::Cmt1f
getLastResult	cmt2.cpp	/^XsensResultValue Cmt2f::getLastResult(void) const$/;"	f	class:xsens::Cmt2f
getLastResult	cmt2.h	/^	XsensResultValue getLastResult(void) const { return m_lastResult; }$/;"	f	class:xsens::Cmt2s
getLastResult	cmt3.h	/^	XsensResultValue getLastResult(void) const				\/\/!< \\brief Return the error code of the last user function call.$/;"	f	class:xsens::Cmt3
getLatLonAlt	cmt3.cpp	/^XsensResultValue Cmt3::getLatLonAlt(CmtVector& lla, const CmtDeviceId deviceId)$/;"	f	class:xsens::Cmt3
getLocationId	cmt3.cpp	/^XsensResultValue Cmt3::getLocationId(uint16_t& locationId, const CmtDeviceId deviceId)$/;"	f	class:xsens::Cmt3
getLogFileName	cmt3.cpp	/^XsensResultValue Cmt3::getLogFileName(char* filename)$/;"	f	class:xsens::Cmt3
getLogFileName	cmt3.cpp	/^XsensResultValue Cmt3::getLogFileName(wchar_t* filename)$/;"	f	class:xsens::Cmt3
getLogFileReadPosition	cmt3.cpp	/^XsensResultValue Cmt3::getLogFileReadPosition(XsensFilePos& pos)$/;"	f	class:xsens::Cmt3
getLogFileSize	cmt3.cpp	/^XsensResultValue Cmt3::getLogFileSize(XsensFilePos& size)$/;"	f	class:xsens::Cmt3
getMagneticDeclination	cmt3.cpp	/^XsensResultValue Cmt3::getMagneticDeclination(double& declination, const CmtDeviceId deviceId)$/;"	f	class:xsens::Cmt3
getMasterId	cmt3.cpp	/^CmtDeviceId Cmt3::getMasterId(void)$/;"	f	class:xsens::Cmt3
getMessageId	cmtmessage.h	/^	uint8_t getMessageId(void) const { return m_buffer->m_messageId; }$/;"	f	class:xsens::Message
getMessageStart	cmtmessage.h	/^	const uint8_t* getMessageStart(void) const$/;"	f	class:xsens::Message
getMtCount	cmt3.cpp	/^uint16_t Cmt3::getMtCount(void) const$/;"	f	class:xsens::Cmt3
getMtDeviceId	cmt3.cpp	/^XsensResultValue Cmt3::getMtDeviceId (const uint8_t index, CmtDeviceId& deviceId) const$/;"	f	class:xsens::Cmt3
getName	cmt1.cpp	/^XsensResultValue Cmt1f::getName(char* filename) const$/;"	f	class:xsens::Cmt1f
getName	cmt1.cpp	/^XsensResultValue Cmt1f::getName(wchar_t* filename) const$/;"	f	class:xsens::Cmt1f
getName	cmt2.cpp	/^XsensResultValue Cmt2f::getName(char* filename) const$/;"	f	class:xsens::Cmt2f
getName	cmt2.cpp	/^XsensResultValue Cmt2f::getName(wchar_t* filename) const$/;"	f	class:xsens::Cmt2f
getObjectAlignmentMatrix	cmt3.cpp	/^XsensResultValue Cmt3::getObjectAlignmentMatrix(CmtMatrix& matrix, const CmtDeviceId deviceId)$/;"	f	class:xsens::Cmt3
getOriEuler	cmtpacket.cpp	/^CmtEuler Packet::getOriEuler(const uint16_t index) const$/;"	f	class:xsens::Packet
getOriMatrix	cmtpacket.cpp	/^CmtMatrix Packet::getOriMatrix(const uint16_t index) const$/;"	f	class:xsens::Packet
getOriQuat	cmtpacket.cpp	/^CmtQuat Packet::getOriQuat(const uint16_t index) const$/;"	f	class:xsens::Packet
getPeriodAndSkipFactor	cmt3.cpp	/^void CmtDeviceMode::getPeriodAndSkipFactor(uint16_t& period,uint16_t& skip) const$/;"	f	class:CmtDeviceMode
getPortName	cmt1.cpp	/^void Cmt1s::getPortName(char *portname) const { sprintf(portname, "%s", m_portname); }$/;"	f	class:xsens::Cmt1s
getPortName	cmt2.cpp	/^XsensResultValue Cmt2s::getPortName(char *portname) const$/;"	f	class:xsens::Cmt2s
getPortNr	cmt1.cpp	/^uint16_t Cmt1s::getPortNr (void) const { return m_port; }$/;"	f	class:xsens::Cmt1s
getPortNr	cmt2.cpp	/^XsensResultValue Cmt2s::getPortNr(int32_t& port) const$/;"	f	class:xsens::Cmt2s
getPortNr	cmt2.cpp	/^XsensResultValue Cmt2s::getPortNr(uint16_t& port) const$/;"	f	class:xsens::Cmt2s
getPortNr	cmt3.cpp	/^XsensResultValue Cmt3::getPortNr(uint16_t& port) const$/;"	f	class:xsens::Cmt3
getPositionLLA	cmtpacket.cpp	/^CmtVector Packet::getPositionLLA(const uint16_t index) const$/;"	f	class:xsens::Packet
getProcessingFlags	cmt3.cpp	/^XsensResultValue Cmt3::getProcessingFlags(uint16_t& processingFlags, const CmtDeviceId deviceId)$/;"	f	class:xsens::Cmt3
getProductCode	cmt3.cpp	/^XsensResultValue Cmt3::getProductCode (char* productCode, const CmtDeviceId deviceId)$/;"	f	class:xsens::Cmt3
getRawAcc	cmtpacket.cpp	/^CmtShortVector Packet::getRawAcc(const uint16_t index) const$/;"	f	class:xsens::Packet
getRawData	cmtpacket.cpp	/^CmtRawData Packet::getRawData(const uint16_t index) const$/;"	f	class:xsens::Packet
getRawGpsData	cmtpacket.h	185;"	d
getRawGyr	cmtpacket.cpp	/^CmtShortVector Packet::getRawGyr(const uint16_t index) const$/;"	f	class:xsens::Packet
getRawMag	cmtpacket.cpp	/^CmtShortVector Packet::getRawMag(const uint16_t index) const$/;"	f	class:xsens::Packet
getRawPressureData	cmtpacket.cpp	/^CmtRawPressureData Packet::getRawPressureData(const uint16_t index) const$/;"	f	class:xsens::Packet
getRawTemp	cmtpacket.cpp	/^uint16_t Packet::getRawTemp(const uint16_t index) const$/;"	f	class:xsens::Packet
getReadPos	cmt1.h	/^	XsensFilePos getReadPos(void) const { return m_readPos; }$/;"	f	class:xsens::Cmt1f
getReadPosition	cmt2.cpp	/^XsensFilePos Cmt2f::getReadPosition(void)$/;"	f	class:xsens::Cmt2f
getRealSampleFrequency	cmt3.cpp	/^double CmtDeviceMode2::getRealSampleFrequency(void) const$/;"	f	class:CmtDeviceMode2
getRealSampleFrequency	cmt3.cpp	/^double CmtDeviceMode::getRealSampleFrequency(void) const$/;"	f	class:CmtDeviceMode
getRtc	cmtpacket.cpp	/^TimeStamp Packet::getRtc(const uint16_t index) const$/;"	f	class:xsens::Packet
getSampleCounter	cmtpacket.cpp	/^uint16_t Packet::getSampleCounter(const uint16_t index) const$/;"	f	class:xsens::Packet
getSampleFrequency	cmt3.cpp	/^uint16_t Cmt3::getSampleFrequency(void)$/;"	f	class:xsens::Cmt3
getSampleFrequency	cmt3.cpp	/^uint16_t CmtDeviceMode2::getSampleFrequency(void) const$/;"	f	class:CmtDeviceMode2
getScenario	cmt3.cpp	/^XsensResultValue Cmt3::getScenario(uint8_t& scenarioType, uint8_t& scenarioVersion, const CmtDeviceId deviceId)$/;"	f	class:xsens::Cmt3
getSerialBaudrate	cmt3.cpp	/^XsensResultValue Cmt3::getSerialBaudrate(uint32_t& baudrate)$/;"	f	class:xsens::Cmt3
getStatus	cmtpacket.cpp	/^uint8_t Packet::getStatus(const uint16_t index) const$/;"	f	class:xsens::Packet
getSyncInMode	cmt3.cpp	/^XsensResultValue Cmt3::getSyncInMode(uint16_t& mode)$/;"	f	class:xsens::Cmt3
getSyncInOffset	cmt3.cpp	/^XsensResultValue Cmt3::getSyncInOffset(uint32_t& offset)$/;"	f	class:xsens::Cmt3
getSyncInSettings	cmt3.cpp	/^XsensResultValue Cmt3::getSyncInSettings(CmtSyncInSettings& settings)$/;"	f	class:xsens::Cmt3
getSyncInSkipFactor	cmt3.cpp	/^XsensResultValue Cmt3::getSyncInSkipFactor(uint16_t& skipFactor)$/;"	f	class:xsens::Cmt3
getSyncMode	cmt3.cpp	/^XsensResultValue Cmt3::getSyncMode(uint8_t& mode)$/;"	f	class:xsens::Cmt3
getSyncOutMode	cmt3.cpp	/^XsensResultValue Cmt3::getSyncOutMode(uint16_t& mode)$/;"	f	class:xsens::Cmt3
getSyncOutOffset	cmt3.cpp	/^XsensResultValue Cmt3::getSyncOutOffset(uint32_t& offset)$/;"	f	class:xsens::Cmt3
getSyncOutPulseWidth	cmt3.cpp	/^XsensResultValue Cmt3::getSyncOutPulseWidth(uint32_t& pulseWidth)$/;"	f	class:xsens::Cmt3
getSyncOutSettings	cmt3.cpp	/^XsensResultValue Cmt3::getSyncOutSettings(CmtSyncOutSettings& settings)$/;"	f	class:xsens::Cmt3
getSyncOutSkipFactor	cmt3.cpp	/^XsensResultValue Cmt3::getSyncOutSkipFactor(uint16_t& skipFactor)$/;"	f	class:xsens::Cmt3
getTemp	cmtpacket.cpp	/^double Packet::getTemp(const uint16_t index) const$/;"	f	class:xsens::Packet
getTimeAsString	xsens_time.cpp	/^void getTimeAsString(uint8_t *dest, const tm* date)$/;"	f	namespace:xsens
getTimeOfDay	xsens_time.cpp	/^uint32_t getTimeOfDay(tm* date_, time_t* secs_)$/;"	f	namespace:xsens
getTimeout	cmt1.cpp	/^uint32_t Cmt1s::getTimeout (void) const { return m_timeout; }$/;"	f	class:xsens::Cmt1s
getTimeout	cmt2.h	/^	uint32_t getTimeout(void) const { return m_timeout; }$/;"	f	class:xsens::Cmt2s
getTimeoutConfig	cmt3.cpp	/^uint32_t Cmt3::getTimeoutConfig (void) const$/;"	f	class:xsens::Cmt3
getTimeoutMeasurement	cmt3.cpp	/^uint32_t Cmt3::getTimeoutMeasurement (void) const$/;"	f	class:xsens::Cmt3
getTotalMessageSize	cmtmessage.cpp	/^uint16_t Message::getTotalMessageSize(void) const$/;"	f	class:xsens::Message
getTransmissionDelay	cmt3.cpp	/^XsensResultValue Cmt3::getTransmissionDelay(uint16_t& delay, const CmtDeviceId deviceId)$/;"	f	class:xsens::Cmt3
getUserInputs	example_linux.cpp	/^void getUserInputs(CmtOutputMode &mode, CmtOutputSettings &settings)$/;"	f
getUtcTime	cmt3.cpp	/^XsensResultValue Cmt3::getUtcTime(CmtUtcTime& utc, const CmtDeviceId deviceId)$/;"	f	class:xsens::Cmt3
getUtcTime	cmtpacket.cpp	/^CmtUtcTime Packet::getUtcTime(const uint16_t index) const$/;"	f	class:xsens::Packet
getVelocity	cmtpacket.cpp	/^CmtVector Packet::getVelocity(const uint16_t index) const$/;"	f	class:xsens::Packet
getWritePos	cmt1.h	/^	XsensFilePos getWritePos(void) const { return m_writePos; }$/;"	f	class:xsens::Cmt1f
getXbus	cmtpacket.cpp	/^bool Packet::getXbus(void) const$/;"	f	class:xsens::Packet
getXmOutputMode	cmt3.cpp	/^XsensResultValue Cmt3::getXmOutputMode(uint8_t& mode)$/;"	f	class:xsens::Cmt3
glue3	pstdint.h	781;"	d
glue3_aux	pstdint.h	780;"	d
gotoConfig	cmt3.cpp	/^XsensResultValue Cmt3::gotoConfig(void)$/;"	f	class:xsens::Cmt3
gotoMeasurement	cmt3.cpp	/^XsensResultValue Cmt3::gotoMeasurement(void)$/;"	f	class:xsens::Cmt3
gotoRead	cmt1.cpp	/^void Cmt1f::gotoRead(void)$/;"	f	class:xsens::Cmt1f
gotoWrite	cmt1.cpp	/^void Cmt1f::gotoWrite(void)$/;"	f	class:xsens::Cmt1f
historyMax	xsens_time.cpp	/^double TimeSyncPrivate::historyMax() const$/;"	f	class:xsens::TimeSyncPrivate
i0	cmtmessage.cpp	/^		int32_t i1,i0;$/;"	m	struct:xsens::Itypes::__anon1	file:
i1	cmtmessage.cpp	/^		int32_t i1,i0;$/;"	m	struct:xsens::Itypes::__anon1	file:
i16	cmtmessage.cpp	/^	} i16;$/;"	m	union:xsens::Itypes	typeref:struct:xsens::Itypes::__anon2	file:
i32	cmtmessage.cpp	/^	} i32;$/;"	m	union:xsens::Itypes	typeref:struct:xsens::Itypes::__anon1	file:
i64	cmtmessage.cpp	/^	int64_t i64;$/;"	m	union:xsens::Itypes	file:
i8	cmtmessage.cpp	/^	} i8;$/;"	m	union:xsens::Itypes	typeref:struct:xsens::Itypes::__anon3	file:
initBus	cmt3.cpp	/^XsensResultValue Cmt3::initBus(void)$/;"	f	class:xsens::Cmt3
initializeTime	xsens_time.cpp	/^void initializeTime()$/;"	f	namespace:xsens
insert	xsens_list.h	/^void List<T>::insert(const T& item, const uint32_t index)$/;"	f	class:xsens::List
insertCopy	xsens_list.h	/^void List<T>::insertCopy(const TB& item, const uint32_t index)$/;"	f	class:xsens::List
insertData	cmt1.cpp	/^XsensResultValue Cmt1f::insertData (const XsensFilePos start, const uint32_t length, const void* data)$/;"	f	class:xsens::Cmt1f
insertData	cmtmessage.cpp	/^void Message::insertData(uint16_t size, uint16_t offset)$/;"	f	class:xsens::Message
insertSorted	xsens_list.h	/^uint32_t List<T>::insertSorted(const T& item)$/;"	f	class:xsens::List
insertSortedCopy	xsens_list.h	/^uint32_t List<T>::insertSortedCopy(const TB& item)$/;"	f	class:xsens::List
insertSortedDeref	xsens_list.h	/^uint32_t List<T>::insertSortedDeref(const T& item)$/;"	f	class:xsens::List
int16_t	pstdint.h	/^  typedef signed int int16_t;$/;"	t
int16_t	pstdint.h	/^  typedef signed short int16_t;$/;"	t
int32_t	pstdint.h	/^  typedef signed int int32_t;$/;"	t
int32_t	pstdint.h	/^  typedef signed long int32_t;$/;"	t
int32_t	pstdint.h	/^  typedef signed short int32_t;$/;"	t
int64_t	pstdint.h	/^   __extension__ typedef long int64_t;$/;"	t
int64_t	pstdint.h	/^   __extension__ typedef long long int64_t;$/;"	t
int64_t	pstdint.h	/^   typedef __int64 int64_t;$/;"	t
int64_t	pstdint.h	/^   typedef long long int64_t;$/;"	t
int8_t	pstdint.h	/^    typedef signed char int8_t;$/;"	t
int_fast16_t	pstdint.h	/^typedef  int_least16_t  int_fast16_t;$/;"	t
int_fast32_t	pstdint.h	/^typedef  int_least32_t  int_fast32_t;$/;"	t
int_fast64_t	pstdint.h	/^  typedef  int_least64_t  int_fast64_t;$/;"	t
int_fast8_t	pstdint.h	/^typedef   int_least8_t   int_fast8_t;$/;"	t
int_least16_t	pstdint.h	/^  typedef  int16_t  int_least16_t;$/;"	t
int_least32_t	pstdint.h	/^  typedef  int32_t  int_least32_t;$/;"	t
int_least64_t	pstdint.h	/^    typedef  int64_t  int_least64_t;$/;"	t
int_least8_t	pstdint.h	/^  typedef   int8_t   int_least8_t;$/;"	t
intmax_t	pstdint.h	/^  typedef int32_t intmax_t;$/;"	t
intmax_t	pstdint.h	/^  typedef int64_t intmax_t;$/;"	t
intptr_t	pstdint.h	/^  typedef ptrdiff_t intptr_t;$/;"	t
intptr_t	pstdint.h	/^  typedef stdint_intptr_glue3( int,stdint_intptr_bits,_t)  intptr_t;$/;"	t
isChecksumOk	cmtmessage.cpp	/^bool Message::isChecksumOk(void) const$/;"	f	class:xsens::Message
isDeepCopyOf	xsens_list.h	/^void List<T>::isDeepCopyOf(const List<T>& source)$/;"	f	class:xsens::List
isInitialized	xsens_time.cpp	/^int TimeSync::isInitialized() const$/;"	f	class:xsens::TimeSync
isLogFileOpen	cmt3.cpp	/^bool Cmt3::isLogFileOpen(const char* filename) const$/;"	f	class:xsens::Cmt3
isLogFileOpen	cmt3.cpp	/^bool Cmt3::isLogFileOpen(const wchar_t* filename) const$/;"	f	class:xsens::Cmt3
isLogging	cmt3.h	/^	bool isLogging(void) const			\/\/!< \\brief Return whether the Cmt3 object is writing to a log file or not$/;"	f	class:xsens::Cmt3
isOpen	cmt1.cpp	/^bool Cmt1s::isOpen (void) const { return m_isOpen; }$/;"	f	class:xsens::Cmt1s
isOpen	cmt1.h	/^	bool isOpen(void) const { return m_isOpen; }$/;"	f	class:xsens::Cmt1f
isOpen	cmt2.cpp	/^bool Cmt2f::isOpen(void) const$/;"	f	class:xsens::Cmt2f
isOpen	cmt2.h	/^	bool isOpen (void) const { return (m_cmt1s.isOpen()); }$/;"	f	class:xsens::Cmt2s
isPortOpen	cmt3.h	/^	bool isPortOpen(void) const			\/\/!< \\brief Return whether the communication port is open or not.$/;"	f	class:xsens::Cmt3
isReadOnly	cmt1.h	/^	bool isReadOnly(void) const { return !m_isOpen || m_readOnly; }$/;"	f	class:xsens::Cmt1f
isReadingFromFile	cmt3.h	/^	bool isReadingFromFile(void) const	\/\/!< \\brief Return whether the Cmt3 object is reading from a log file or not$/;"	f	class:xsens::Cmt3
isShallowCopyOf	xsens_list.h	/^void List<T>::isShallowCopyOf(const List<T>& x)$/;"	f	class:xsens::List
isXm	cmt3.cpp	/^bool Cmt3::isXm(void) const$/;"	f	class:xsens::Cmt3
isnum	example_linux.cpp	/^inline int isnum(int c)$/;"	f
lastIndex	xsens_time.cpp	/^int TimeSyncPrivate::lastIndex() const$/;"	f	class:xsens::TimeSyncPrivate
length	xsens_fifoqueue.h	/^	size_type length() const$/;"	f	class:xsens::FifoQueue
length	xsens_fifoqueue.h	/^	size_type length() const$/;"	f	class:xsens::FifoQueueBasic
length	xsens_list.h	/^		uint32_t length(void) const { return m_count; }$/;"	f	class:xsens::List
loadFromString	cmtmessage.cpp	/^XsensResultValue Message::loadFromString(const uint8_t* source, const uint16_t size)$/;"	f	class:xsens::Message
localTime	xsens_time.cpp	/^TimeStamp TimeSync::localTime(TimeStamp tMi)$/;"	f	class:xsens::TimeSync
m_C	xsens_time.cpp	/^	double m_C;				\/\/!< Stability factor (lower is more stable)$/;"	m	class:xsens::TimeSyncPrivate	file:
m_a	xsens_time.cpp	/^	double m_a;				\/\/!< Fuzzy factor$/;"	m	class:xsens::TimeSyncPrivate	file:
m_acc	cmtdef.h	/^	CmtShortVector	m_acc,m_gyr,m_mag;$/;"	m	struct:CmtRawData
m_acc	cmtdef.h	/^	CmtVector	m_acc,m_gyr,m_mag;$/;"	m	struct:CmtCalData
m_acc_g	cmtpacket.h	/^		uint16_t m_acc_g;$/;"	m	struct:xsens::Packet::PacketInfo
m_analogIn1	cmtpacket.h	/^		uint16_t m_analogIn1;$/;"	m	struct:xsens::Packet::PacketInfo
m_analogIn2	cmtpacket.h	/^		uint16_t m_analogIn2;$/;"	m	struct:xsens::Packet::PacketInfo
m_autoUpdateChecksum	cmtmessage.h	/^	bool m_autoUpdateChecksum;$/;"	m	class:xsens::Message
m_baudrate	cmt1.h	/^	uint32_t m_baudrate;$/;"	m	class:xsens::Cmt1s
m_baudrate	cmt2.h	/^	uint32_t m_baudrate;$/;"	m	class:xsens::Cmt2s
m_baudrate	cmt3.h	/^	uint32_t m_baudrate;		\/\/!< The baudrate that was last set to be used by the port.$/;"	m	class:xsens::Cmt3
m_baudrate	cmtdef.h	/^	uint32_t m_baudrate;	\/\/!< The baudrate at which an Xsens device was detected$/;"	m	struct:CmtPortInfo
m_buffer	cmtmessage.h	/^	MessageHeader* m_buffer;$/;"	m	class:xsens::Message
m_busId	cmtmessage.h	/^	uint8_t m_busId;$/;"	m	struct:xsens::MessageHeader
m_calAcc	cmtpacket.h	/^		uint16_t m_calAcc;$/;"	m	struct:xsens::Packet::PacketInfo
m_calData	cmtpacket.h	/^		uint16_t m_calData;$/;"	m	struct:xsens::Packet::PacketInfo
m_calGyr	cmtpacket.h	/^		uint16_t m_calGyr;$/;"	m	struct:xsens::Packet::PacketInfo
m_calMag	cmtpacket.h	/^		uint16_t m_calMag;$/;"	m	struct:xsens::Packet::PacketInfo
m_checksum	cmtmessage.h	/^	uint8_t* m_checksum;$/;"	m	class:xsens::Message
m_cmt1f	cmt2.h	/^	Cmt1f m_cmt1f;$/;"	m	class:xsens::Cmt2f
m_cmt1s	cmt2.h	/^	Cmt1s m_cmt1s;$/;"	m	class:xsens::Cmt2s
m_commState	cmt1.h	/^		DCB		m_commState;		\/\/!< Stored settings about the serial port$/;"	m	class:xsens::Cmt1s
m_commState	cmt1.h	/^		termios	m_commState;		\/\/!< Stored settings about the serial port$/;"	m	class:xsens::Cmt1s
m_config	cmt3.h	/^	CmtDeviceConfiguration m_config;				\/\/!< Cached configuration data.$/;"	m	class:xsens::Cmt3
m_control	xsens_janitors.h	/^	T& m_control;$/;"	m	class:xsens::JanitorClassFunc
m_control	xsens_janitors.h	/^	T& m_control;$/;"	m	class:xsens::JanitorClassFuncP1
m_correction	xsens_time.cpp	/^	double m_correction;		\/\/!< Last known correction value computed from the history$/;"	m	class:xsens::TimeSyncPrivate	file:
m_count	xsens_list.h	/^		uint32_t m_count;				\/\/!< The number of items currently in the list$/;"	m	class:xsens::List
m_currentCount	xsens_fifoqueue.h	/^	size_t m_currentCount;$/;"	m	class:xsens::FifoQueue
m_currentCount	xsens_fifoqueue.h	/^	size_t m_currentCount;$/;"	m	class:xsens::FifoQueueBasic
m_currentScenario	cmtdef.h	/^		uint16_t	m_currentScenario;$/;"	m	struct:CmtDeviceConfiguration::_devInfo
m_data	cmtdef.h	/^	double m_data[3];$/;"	m	struct:CmtVector
m_data	cmtdef.h	/^	double m_data[3][3];$/;"	m	struct:CmtMatrix
m_data	cmtdef.h	/^	double m_data[4];$/;"	m	struct:CmtQuat
m_data	cmtdef.h	/^	uint16_t m_data;$/;"	m	struct:CmtAnalogInData
m_data	cmtdef.h	/^	uint16_t m_data[3];$/;"	m	struct:CmtShortVector
m_data	cmtdef.h	/^	uint8_t m_data[CMT_MAXMSGLEN];$/;"	m	struct:CmtBinaryData
m_data	cmtmessage.h	/^			uint8_t m_data[CMT_MAXDATALEN];$/;"	m	struct:xsens::MessageHeader::_mdl::_mextd
m_data	cmtmessage.h	/^		uint8_t m_data[254];$/;"	m	union:xsens::MessageHeader::_mdl
m_data	xsens_list.h	/^		T* m_data;							\/\/!< The array containing the items$/;"	m	class:xsens::List
m_dataLength	cmtdef.h	/^		uint16_t	m_dataLength;$/;"	m	struct:CmtDeviceConfiguration::_devInfo
m_date	cmtdef.h	/^	uint8_t	m_date[8];$/;"	m	struct:CmtDeviceConfiguration
m_datlen	cmtmessage.h	/^	} m_datlen;$/;"	m	struct:xsens::MessageHeader	typeref:union:xsens::MessageHeader::_mdl
m_day	cmtdef.h	/^	uint8_t	m_day;$/;"	m	struct:CmtUtcTime
m_deleteOnOverwrite	xsens_fifoqueue.h	/^	bool m_deleteOnOverwrite;$/;"	m	class:xsens::FifoQueue
m_detailedScan	cmt3.h	/^	bool m_detailedScan;			\/\/!< Automatically scan for device details during open. Default is true (recommended).$/;"	m	class:xsens::Cmt3
m_deviceId	cmtdef.h	/^		uint32_t	m_deviceId;$/;"	m	struct:CmtDeviceConfiguration::_devInfo
m_deviceId	cmtdef.h	/^	uint32_t m_deviceId;	\/\/!< The device Id of the detected Xsens device$/;"	m	struct:CmtPortInfo
m_deviceInfo	cmtdef.h	/^	} m_deviceInfo[CMT_MAX_DEVICES_PER_PORT];$/;"	m	struct:CmtDeviceConfiguration	typeref:struct:CmtDeviceConfiguration::_devInfo
m_doubleBoundary	cmtpacket.h	/^		uint16_t m_doubleBoundary;$/;"	m	struct:xsens::Packet::PacketInfo
m_eMtsData	cmt3.h	/^	void* m_eMtsData[CMT_MAX_DEVICES_PER_PORT];		\/\/!< Cached eMTS data.$/;"	m	class:xsens::Cmt3
m_enabled	xsens_janitors.h	/^	bool m_enabled;$/;"	m	class:xsens::JanitorClassFunc
m_enabled	xsens_janitors.h	/^	bool m_enabled;$/;"	m	class:xsens::JanitorClassFuncP1
m_endTime	cmt1.h	/^	uint32_t m_endTime;$/;"	m	class:xsens::Cmt1s
m_extended	cmtmessage.h	/^		} m_extended;$/;"	m	union:xsens::MessageHeader::_mdl	typeref:struct:xsens::MessageHeader::_mdl::_mextd
m_fileSize	cmt1.h	/^	XsensFilePos m_fileSize;$/;"	m	class:xsens::Cmt1f
m_filename	cmt1.h	/^	char m_filename[CMT_MAX_FILENAME_LENGTH];$/;"	m	class:xsens::Cmt1f
m_filename_w	cmt1.h	/^	wchar_t m_filename_w[CMT_MAX_FILENAME_LENGTH];$/;"	m	class:xsens::Cmt1f
m_filterMajor	cmtdef.h	/^		uint8_t		m_filterMajor;$/;"	m	struct:CmtDeviceConfiguration::_devInfo
m_filterMajor	cmtdef.h	/^	uint8_t m_filterMajor, m_filterMinor;		\/\/!< The version of the XKF filter this scenario is intended for$/;"	m	struct:CmtScenario
m_filterMinor	cmtdef.h	/^		uint8_t		m_filterMinor;$/;"	m	struct:CmtDeviceConfiguration::_devInfo
m_filterMinor	cmtdef.h	/^	uint8_t m_filterMajor, m_filterMinor;		\/\/!< The version of the XKF filter this scenario is intended for$/;"	m	struct:CmtScenario
m_filterType	cmtdef.h	/^		uint8_t		m_filterType;$/;"	m	struct:CmtDeviceConfiguration::_devInfo
m_filterType	cmtdef.h	/^	char m_filterType;							\/\/!< The type of the XKF filter this scenario is intended for '3': XKF-3, '6': XKF-6. \\note The value is a character, so XKF-3 is '3', which is hex 0x33$/;"	m	struct:CmtScenario
m_first	xsens_fifoqueue.h	/^	size_t m_first;$/;"	m	class:xsens::FifoQueue
m_first	xsens_fifoqueue.h	/^	size_t m_first;$/;"	m	class:xsens::FifoQueueBasic
m_firstItem	cmt3.h	/^	uint16_t m_firstItem;				\/\/!< The index of the first formatting item.$/;"	m	class:xsens::Cmt3
m_formatList	cmtpacket.h	/^	CmtDataFormat*	m_formatList;	\/\/!< A list of the formats of the data items$/;"	m	class:xsens::Packet
m_funcJCF	xsens_janitors.h	/^	t_func_JanitorClassFunc m_funcJCF;$/;"	m	class:xsens::JanitorClassFunc
m_funcJCF	xsens_janitors.h	/^	t_func_JanitorClassFunc m_funcJCF;$/;"	m	class:xsens::JanitorClassFuncP1
m_fwRevMajor	cmtdef.h	/^		uint8_t		m_fwRevMajor;$/;"	m	struct:CmtDeviceConfiguration::_devInfo
m_fwRevMinor	cmtdef.h	/^		uint8_t		m_fwRevMinor;$/;"	m	struct:CmtDeviceConfiguration::_devInfo
m_fwRevRevision	cmtdef.h	/^		uint8_t		m_fwRevRevision;$/;"	m	struct:CmtDeviceConfiguration::_devInfo
m_gotoConfigTries	cmt3.h	/^	uint16_t m_gotoConfigTries;		\/\/!< The number of times a goto config is attempted before the function fails.$/;"	m	class:xsens::Cmt3
m_gpsAge	cmtdef.h	/^	uint8_t	m_gpsAge;$/;"	m	struct:CmtGpsPvtData
m_gpsPvtData	cmtpacket.h	/^		uint16_t m_gpsPvtData;$/;"	m	struct:xsens::Packet::PacketInfo
m_gpsPvtGpsAge	cmtpacket.h	/^		uint16_t m_gpsPvtGpsAge;$/;"	m	struct:xsens::Packet::PacketInfo
m_gpsPvtGpsData	cmtpacket.h	/^		uint16_t m_gpsPvtGpsData;$/;"	m	struct:xsens::Packet::PacketInfo
m_gpsPvtHacc	cmtpacket.h	/^		uint16_t m_gpsPvtHacc;$/;"	m	struct:xsens::Packet::PacketInfo
m_gpsPvtHeight	cmtpacket.h	/^		uint16_t m_gpsPvtHeight;$/;"	m	struct:xsens::Packet::PacketInfo
m_gpsPvtItow	cmtpacket.h	/^		uint16_t m_gpsPvtItow;$/;"	m	struct:xsens::Packet::PacketInfo
m_gpsPvtLatitude	cmtpacket.h	/^		uint16_t m_gpsPvtLatitude;$/;"	m	struct:xsens::Packet::PacketInfo
m_gpsPvtLongitude	cmtpacket.h	/^		uint16_t m_gpsPvtLongitude;$/;"	m	struct:xsens::Packet::PacketInfo
m_gpsPvtPressure	cmtpacket.h	/^		uint16_t m_gpsPvtPressure;$/;"	m	struct:xsens::Packet::PacketInfo
m_gpsPvtPressureAge	cmtpacket.h	/^		uint16_t m_gpsPvtPressureAge;$/;"	m	struct:xsens::Packet::PacketInfo
m_gpsPvtSacc	cmtpacket.h	/^		uint16_t m_gpsPvtSacc;$/;"	m	struct:xsens::Packet::PacketInfo
m_gpsPvtVacc	cmtpacket.h	/^		uint16_t m_gpsPvtVacc;$/;"	m	struct:xsens::Packet::PacketInfo
m_gpsPvtVeld	cmtpacket.h	/^		uint16_t m_gpsPvtVeld;$/;"	m	struct:xsens::Packet::PacketInfo
m_gpsPvtVele	cmtpacket.h	/^		uint16_t m_gpsPvtVele;$/;"	m	struct:xsens::Packet::PacketInfo
m_gpsPvtVeln	cmtpacket.h	/^		uint16_t m_gpsPvtVeln;$/;"	m	struct:xsens::Packet::PacketInfo
m_gyr	cmtdef.h	/^	CmtShortVector	m_acc,m_gyr,m_mag;$/;"	m	struct:CmtRawData
m_gyr	cmtdef.h	/^	CmtVector	m_acc,m_gyr,m_mag;$/;"	m	struct:CmtCalData
m_hacc	cmtdef.h	/^	uint32_t	m_hacc;$/;"	m	struct:CmtGpsPvtData
m_handle	cmt1.h	/^		HANDLE	m_handle;			\/\/!< The serial port handle$/;"	m	class:xsens::Cmt1s
m_handle	cmt1.h	/^		int32_t		m_handle;			\/\/!< The serial port handle$/;"	m	class:xsens::Cmt1s
m_handle	cmt1.h	/^	FILE* m_handle;$/;"	m	class:xsens::Cmt1f
m_height	cmtdef.h	/^	int32_t		m_height;$/;"	m	struct:CmtGpsPvtData
m_high	cmtmessage.h	/^				uint8_t m_high;$/;"	m	struct:xsens::MessageHeader::_mdl::_mextd::_mlen
m_history	xsens_time.cpp	/^	TimeSyncHistoryUnit* m_history;		\/\/!< The time sync history buffer, implemented as a circular buffer$/;"	m	class:xsens::TimeSyncPrivate	file:
m_historyCount	xsens_time.cpp	/^	int m_historyCount;			\/\/!< Items currently in the history$/;"	m	class:xsens::TimeSyncPrivate	file:
m_historyIndex	xsens_time.cpp	/^	int m_historyIndex;			\/\/!< Index of the next item to write in the history (in a full history this is also the oldest item index)$/;"	m	class:xsens::TimeSyncPrivate	file:
m_historyMaxIndex	xsens_time.cpp	/^	int m_historyMaxIndex;		\/\/!< Index of the maximum tCR value in the history$/;"	m	class:xsens::TimeSyncPrivate	file:
m_historySize	xsens_time.cpp	/^	int m_historySize;		\/\/!< The number of items stored in the history$/;"	m	class:xsens::TimeSyncPrivate	file:
m_hour	cmtdef.h	/^	uint8_t	m_hour;$/;"	m	struct:CmtUtcTime
m_id	cmtdef.h	/^	uint8_t m_id;$/;"	m	struct:CmtGpsSatelliteInfo
m_infoList	cmtpacket.h	/^	}*	m_infoList;$/;"	m	class:xsens::Packet	typeref:struct:xsens::Packet::PacketInfo
m_initialSkew	xsens_time.cpp	/^	double m_initialSkew;	\/\/!< Initial skew to apply. When 0, the skew will be estimated automatically.$/;"	m	class:xsens::TimeSyncPrivate	file:
m_initialized	xsens_time.cpp	/^	bool m_initialized;			\/\/!< Whether an initial estimate has been made and the normal time sync estimation can take place$/;"	m	class:xsens::TimeSyncPrivate	file:
m_isOpen	cmt1.h	/^	bool m_isOpen;$/;"	m	class:xsens::Cmt1f
m_isOpen	cmt1.h	/^	bool m_isOpen;$/;"	m	class:xsens::Cmt1s
m_itemCount	cmtpacket.h	/^	uint16_t		m_itemCount;	\/\/!< The number of data items in the message$/;"	m	class:xsens::Packet
m_itow	cmtdef.h	/^	uint32_t	m_itow;$/;"	m	struct:CmtGpsPvtData
m_jcf	xsens_list.h	/^		JanitorClassFunc<List<T> >* m_jcf;	\/\/!< Used to clean up the list on exit$/;"	m	class:xsens::List
m_label	cmtdef.h	/^	char m_label[CMT_LEN_SCENARIOLABEL+1];		\/\/!< The label of the scenario.$/;"	m	struct:CmtScenario
m_lastHwError	cmt3.h	/^	XsensResultValue m_lastHwError;			\/\/!< Contains the last error reported by hardware.$/;"	m	class:xsens::Cmt3
m_lastHwErrorDeviceId	cmt3.h	/^	CmtDeviceId m_lastHwErrorDeviceId;		\/\/!< Contains the Device ID of the device that caused the last hardware error.$/;"	m	class:xsens::Cmt3
m_lastResult	cmt1.h	/^	mutable XsensResultValue m_lastResult;$/;"	m	class:xsens::Cmt1f
m_lastResult	cmt1.h	/^	mutable XsensResultValue m_lastResult;$/;"	m	class:xsens::Cmt1s
m_lastResult	cmt2.h	/^	mutable XsensResultValue m_lastResult;$/;"	m	class:xsens::Cmt2f
m_lastResult	cmt2.h	/^	mutable XsensResultValue m_lastResult;$/;"	m	class:xsens::Cmt2s
m_lastResult	cmt3.h	/^	mutable XsensResultValue m_lastResult;	\/\/!< The last result of an operation.$/;"	m	class:xsens::Cmt3
m_latitude	cmtdef.h	/^	int32_t		m_latitude;$/;"	m	struct:CmtGpsPvtData
m_length	cmtmessage.h	/^			} m_length;$/;"	m	struct:xsens::MessageHeader::_mdl::_mextd	typeref:struct:xsens::MessageHeader::_mdl::_mextd::_mlen
m_length	cmtmessage.h	/^	uint8_t m_length;$/;"	m	struct:xsens::MessageHeader
m_list	xsens_fifoqueue.h	/^	T*	m_list;$/;"	m	class:xsens::FifoQueue
m_list	xsens_fifoqueue.h	/^	T*	m_list;$/;"	m	class:xsens::FifoQueueBasic
m_logFile	cmt3.h	/^	Cmt2f m_logFile;				\/\/!< The (optional) CMT level 2 logfile object that this class operates on. $/;"	m	class:xsens::Cmt3
m_logging	cmt3.h	/^	bool m_logging;							\/\/!< Indicates whether to write all received messages to the logfile or not, automatically set to true by createLogFile.$/;"	m	class:xsens::Cmt3
m_longitude	cmtdef.h	/^	int32_t		m_longitude;$/;"	m	struct:CmtGpsPvtData
m_low	cmtmessage.h	/^				uint8_t m_low;$/;"	m	struct:xsens::MessageHeader::_mdl::_mextd::_mlen
m_mag	cmtdef.h	/^	CmtShortVector	m_acc,m_gyr,m_mag;$/;"	m	struct:CmtRawData
m_mag	cmtdef.h	/^	CmtVector	m_acc,m_gyr,m_mag;$/;"	m	struct:CmtCalData
m_major	cmtdef.h	/^	uint8_t m_major;$/;"	m	struct:CmtVersion
m_manage	xsens_list.h	/^		bool m_manage;$/;"	m	class:xsens::List
m_masterDeviceId	cmtdef.h	/^	uint32_t	m_masterDeviceId;$/;"	m	struct:CmtDeviceConfiguration
m_max	xsens_list.h	/^		uint32_t m_max;				\/\/!< The current size of the data array$/;"	m	class:xsens::List
m_maxCount	xsens_fifoqueue.h	/^	size_t m_maxCount;$/;"	m	class:xsens::FifoQueue
m_maxCount	xsens_fifoqueue.h	/^	size_t m_maxCount;$/;"	m	class:xsens::FifoQueueBasic
m_maxLength	cmtmessage.h	/^	uint32_t m_maxLength;$/;"	m	class:xsens::Message
m_measuring	cmt3.h	/^	bool m_measuring;						\/\/!< Keeps track of whether the connected device is measuring or being configured.$/;"	m	class:xsens::Cmt3
m_messageId	cmtmessage.h	/^	uint8_t m_messageId;$/;"	m	struct:xsens::MessageHeader
m_minor	cmtdef.h	/^	uint8_t m_minor;$/;"	m	struct:CmtVersion
m_minute	cmtdef.h	/^	uint8_t	m_minute;$/;"	m	struct:CmtUtcTime
m_mode	cmtdef.h	/^	uint16_t	m_mode;$/;"	m	struct:CmtSyncInSettings
m_mode	cmtdef.h	/^	uint16_t	m_mode;$/;"	m	struct:CmtSyncOutSettings
m_month	cmtdef.h	/^	uint8_t	m_month;$/;"	m	struct:CmtUtcTime
m_msg	cmtpacket.h	/^	Message			m_msg;			\/\/!< The message$/;"	m	class:xsens::Packet
m_nano	cmtdef.h	/^	uint32_t	m_nano;$/;"	m	struct:CmtUtcTime
m_navigationStatus	cmtdef.h	/^	uint8_t m_navigationStatus;$/;"	m	struct:CmtGpsSatelliteInfo
m_numberOfDevices	cmtdef.h	/^	uint16_t	m_numberOfDevices;$/;"	m	struct:CmtDeviceConfiguration
m_offset	cmtdef.h	/^	uint32_t	m_offset;		\/\/!< Offset in ns$/;"	m	struct:CmtSyncInSettings
m_offset	cmtdef.h	/^	uint32_t	m_offset;		\/\/!< Offset in ns$/;"	m	struct:CmtSyncOutSettings
m_offset	cmtpacket.h	/^		uint16_t m_offset;$/;"	m	struct:xsens::Packet::PacketInfo
m_onBytesReceived	cmt1.h	/^	CmtCallbackFunction m_onBytesReceived;$/;"	m	class:xsens::Cmt1s
m_onBytesReceivedInstance	cmt1.h	/^	int32_t m_onBytesReceivedInstance;$/;"	m	class:xsens::Cmt1s
m_onBytesReceivedParam	cmt1.h	/^	void* m_onBytesReceivedParam;$/;"	m	class:xsens::Cmt1s
m_onMessageReceived	cmt2.h	/^	CmtCallbackFunction m_onMessageReceived;$/;"	m	class:xsens::Cmt2s
m_onMessageReceivedInstance	cmt2.h	/^	int32_t m_onMessageReceivedInstance;$/;"	m	class:xsens::Cmt2s
m_onMessageReceivedParam	cmt2.h	/^	void* m_onMessageReceivedParam;$/;"	m	class:xsens::Cmt2s
m_onMessageSent	cmt2.h	/^	CmtCallbackFunction m_onMessageSent;$/;"	m	class:xsens::Cmt2s
m_onMessageSentInstance	cmt2.h	/^	int32_t m_onMessageSentInstance;$/;"	m	class:xsens::Cmt2s
m_onMessageSentParam	cmt2.h	/^	void* m_onMessageSentParam;$/;"	m	class:xsens::Cmt2s
m_oriEul	cmtpacket.h	/^		uint16_t m_oriEul;$/;"	m	struct:xsens::Packet::PacketInfo
m_oriMat	cmtpacket.h	/^		uint16_t m_oriMat;$/;"	m	struct:xsens::Packet::PacketInfo
m_oriQuat	cmtpacket.h	/^		uint16_t m_oriQuat;$/;"	m	struct:xsens::Packet::PacketInfo
m_outlierDelta	xsens_time.cpp	/^	double m_outlierDelta;		\/\/!< Used to move m_outlierThreshold up or down (lower value is less movement)$/;"	m	class:xsens::TimeSyncPrivate	file:
m_outlierThreshold	xsens_time.cpp	/^	double m_outlierThreshold;	\/\/!< Dynamic threshold for detecting outliers in the update function$/;"	m	class:xsens::TimeSyncPrivate	file:
m_outputMode	cmtdef.h	/^		uint16_t	m_outputMode;$/;"	m	struct:CmtDeviceConfiguration::_devInfo
m_outputMode	cmtdef.h	/^	CmtOutputMode		m_outputMode;$/;"	m	struct:CmtDataFormat
m_outputMode	cmtdef.h	/^	CmtOutputMode		m_outputMode;$/;"	m	struct:CmtDeviceMode
m_outputMode	cmtdef.h	/^	CmtOutputMode		m_outputMode;$/;"	m	struct:CmtDeviceMode2
m_outputSettings	cmtdef.h	/^		uint32_t	m_outputSettings;$/;"	m	struct:CmtDeviceConfiguration::_devInfo
m_outputSettings	cmtdef.h	/^	CmtOutputSettings	m_outputSettings;$/;"	m	struct:CmtDataFormat
m_outputSettings	cmtdef.h	/^	CmtOutputSettings	m_outputSettings;$/;"	m	struct:CmtDeviceMode
m_outputSettings	cmtdef.h	/^	CmtOutputSettings	m_outputSettings;$/;"	m	struct:CmtDeviceMode2
m_outputSkipFactor	cmtdef.h	/^	uint16_t	m_outputSkipFactor;$/;"	m	struct:CmtDeviceConfiguration
m_param1	xsens_janitors.h	/^	P1 m_param1;$/;"	m	class:xsens::JanitorClassFuncP1
m_period	cmt3.h	/^	uint16_t m_period;				\/\/!< The sample period of the port.$/;"	m	class:xsens::Cmt3
m_period	cmtdef.h	/^	uint16_t		m_period;$/;"	m	struct:CmtDeviceMode2
m_pitch	cmtdef.h	/^	double m_pitch;		\/\/!< The pitch (rotation around y-axis \/ right-left-line)$/;"	m	struct:CmtEuler
m_port	cmt1.h	/^	uint16_t m_port;$/;"	m	class:xsens::Cmt1s
m_portName	cmtdef.h	/^	char m_portName[256];		\/\/!< The port name$/;"	m	struct:CmtPortInfo
m_portNr	cmtdef.h	/^	uint16_t m_portNr;		\/\/!< The port number$/;"	m	struct:CmtPortInfo
m_portNr	cmtdef.h	/^	uint16_t m_portNr;$/;"	m	struct:CmtBinaryData
m_portname	cmt1.h	/^	char m_portname[32];$/;"	m	class:xsens::Cmt1s
m_posLLA	cmtpacket.h	/^		uint16_t m_posLLA;$/;"	m	struct:xsens::Packet::PacketInfo
m_preamble	cmtmessage.h	/^	uint8_t m_preamble;$/;"	m	struct:xsens::MessageHeader
m_pressure	cmtdef.h	/^	uint16_t	m_pressure;$/;"	m	struct:CmtRawPressureData
m_pressure	cmtdef.h	/^struct CmtGpsPvtData {	uint16_t	m_pressure;$/;"	m	struct:CmtGpsPvtData
m_pressureAge	cmtdef.h	/^	uint8_t		m_pressureAge;$/;"	m	struct:CmtGpsPvtData
m_pressureAge	cmtdef.h	/^	uint8_t		m_pressureAge;$/;"	m	struct:CmtRawPressureData
m_pulseWidth	cmtdef.h	/^	uint32_t	m_pulseWidth;	\/\/!< Pulse width in ns$/;"	m	struct:CmtSyncOutSettings
m_quickSkewWindow	xsens_time.cpp	/^	int m_quickSkewWindow;	\/\/!< The number of steps to apply the quick skew estimation algorithm$/;"	m	class:xsens::TimeSyncPrivate	file:
m_rawAcc	cmtpacket.h	/^		uint16_t m_rawAcc;$/;"	m	struct:xsens::Packet::PacketInfo
m_rawData	cmtpacket.h	/^		uint16_t m_rawData;$/;"	m	struct:xsens::Packet::PacketInfo
m_rawGyr	cmtpacket.h	/^		uint16_t m_rawGyr;$/;"	m	struct:xsens::Packet::PacketInfo
m_rawMag	cmtpacket.h	/^		uint16_t m_rawMag;$/;"	m	struct:xsens::Packet::PacketInfo
m_rawTemp	cmtpacket.h	/^		uint16_t m_rawTemp;$/;"	m	struct:xsens::Packet::PacketInfo
m_readBufSize	cmt3.h	/^	uint32_t m_readBufSize;					\/\/!< Contains the size of the serial read buffer$/;"	m	class:xsens::Cmt3
m_readBuffer	cmt2.h	/^	uint8_t m_readBuffer[CMT_DEFAULT_READ_BUFFER_SIZE];$/;"	m	class:xsens::Cmt2s
m_readBufferCount	cmt2.h	/^	uint16_t m_readBufferCount;$/;"	m	class:xsens::Cmt2s
m_readFromFile	cmt3.h	/^	bool m_readFromFile;			\/\/!< Indicates whether to read from the log file or from the serial port.$/;"	m	class:xsens::Cmt3
m_readOnly	cmt1.h	/^	bool m_readOnly;$/;"	m	class:xsens::Cmt1f
m_readOnly	cmt2.h	/^	bool m_readOnly;				\/\/!< When set to true, the file is read-only and attempts to write to it will fail$/;"	m	class:xsens::Cmt2f
m_readPos	cmt1.h	/^	XsensFilePos m_readPos;$/;"	m	class:xsens::Cmt1f
m_reading	cmt1.h	/^	bool m_reading;$/;"	m	class:xsens::Cmt1f
m_reservedForClient	cmtdef.h	/^	uint8_t	m_reservedForClient[32];$/;"	m	struct:CmtDeviceConfiguration
m_reservedForHost	cmtdef.h	/^	uint8_t	m_reservedForHost[32];$/;"	m	struct:CmtDeviceConfiguration
m_revision	cmtdef.h	/^	uint8_t m_revision;$/;"	m	struct:CmtVersion
m_roll	cmtdef.h	/^	double m_roll;		\/\/!< The roll (rotation around x-axis \/ back-front-line)$/;"	m	struct:CmtEuler
m_rtc	cmtpacket.h	/^	TimeStamp		m_rtc;			\/\/!< Sample time in ms, based on the sample counter$/;"	m	class:xsens::Packet
m_rtcCount	cmt3.h	/^	uint32_t m_rtcCount;			\/\/!< The long sample counter (normal counter wraps at 64k).$/;"	m	class:xsens::Cmt3
m_rtcInitialized	cmt3.h	/^	bool m_rtcInitialized;			\/\/!< Indicates whether the RTC synchronization isinitialized$/;"	m	class:xsens::Cmt3
m_rtcLastSc	cmt3.h	/^	CmtMtTimeStamp m_rtcLastSc;		\/\/!< The last received sample counter, used to determine wrap-around.$/;"	m	class:xsens::Cmt3
m_rtcSync	cmt3.h	/^	xsens::TimeSync m_rtcSync;		\/\/!< Used for synchronizing MT timestamps to system timestamps$/;"	m	class:xsens::Cmt3
m_sacc	cmtdef.h	/^	uint32_t	m_sacc;$/;"	m	struct:CmtGpsPvtData
m_sampleFrequency	cmtdef.h	/^	uint16_t		m_sampleFrequency;$/;"	m	struct:CmtDeviceMode
m_samplingPeriod	cmtdef.h	/^	uint16_t	m_samplingPeriod;$/;"	m	struct:CmtDeviceConfiguration
m_sc	cmtpacket.h	/^		uint16_t m_sc;$/;"	m	struct:xsens::Packet::PacketInfo
m_second	cmtdef.h	/^	uint8_t	m_second;$/;"	m	struct:CmtUtcTime
m_serial	cmt3.h	/^	Cmt2s m_serial;					\/\/!< The (optional) CMT level 2 serial object that this class operates on.$/;"	m	class:xsens::Cmt3
m_signalQuality	cmtdef.h	/^	uint8_t m_signalQuality;$/;"	m	struct:CmtGpsSatelliteInfo
m_signalStrength	cmtdef.h	/^	uint8_t m_signalStrength;$/;"	m	struct:CmtGpsSatelliteInfo
m_size	cmtdef.h	/^	int32_t m_size;$/;"	m	struct:CmtBinaryData
m_size	cmtpacket.h	/^		uint16_t m_size;$/;"	m	struct:xsens::Packet::PacketInfo
m_skew	xsens_time.cpp	/^	double m_skew;			\/\/!< Last known computed skew$/;"	m	class:xsens::TimeSyncPrivate	file:
m_skip	cmt3.h	/^	uint16_t m_skip;				\/\/!< The skip factor of the port.$/;"	m	class:xsens::Cmt3
m_skip	cmtdef.h	/^	uint16_t		m_skip;$/;"	m	struct:CmtDeviceMode2
m_skipFactor	cmtdef.h	/^	uint16_t	m_skipFactor;$/;"	m	struct:CmtSyncInSettings
m_skipFactor	cmtdef.h	/^	uint16_t	m_skipFactor;$/;"	m	struct:CmtSyncOutSettings
m_status	cmtpacket.h	/^		uint16_t m_status;$/;"	m	struct:xsens::Packet::PacketInfo
m_svInfo	cmtdef.h	/^	CmtGpsSatelliteInfo m_svInfo[CMT_MAX_SVINFO];$/;"	m	struct:CmtGpsStatus
m_syncinMode	cmtdef.h	/^	uint16_t	m_syncinMode;$/;"	m	struct:CmtDeviceConfiguration
m_syncinOffset	cmtdef.h	/^	uint32_t	m_syncinOffset;$/;"	m	struct:CmtDeviceConfiguration
m_syncinSkipFactor	cmtdef.h	/^	uint16_t	m_syncinSkipFactor;$/;"	m	struct:CmtDeviceConfiguration
m_tC	xsens_time.cpp	/^	double m_tC;				\/\/!< Last known computed time value, used in update and time conversion functions$/;"	m	class:xsens::TimeSyncPrivate	file:
m_tMc	xsens_time.cpp	/^	double m_tMc;				\/\/!< Linearization point for the xsens::TimeSync::localTime and xsens::TimeSync::externalTime functions$/;"	m	class:xsens::TimeSyncPrivate	file:
m_tR0	xsens_time.cpp	/^	TimeStamp m_tR0;		\/\/!< Linearization point for R (local) values$/;"	m	class:xsens::TimeSyncPrivate	file:
m_tS0	xsens_time.cpp	/^	TimeStamp m_tS0;		\/\/!< Linearization point for S (external) values$/;"	m	class:xsens::TimeSyncPrivate	file:
m_temp	cmtdef.h	/^	uint16_t	m_temp;$/;"	m	struct:CmtRawData
m_temp	cmtpacket.h	/^		uint16_t m_temp;$/;"	m	struct:xsens::Packet::PacketInfo
m_time	cmtdef.h	/^	uint8_t	m_time[8];$/;"	m	struct:CmtDeviceConfiguration
m_timeout	cmt1.h	/^	uint32_t m_timeout;$/;"	m	class:xsens::Cmt1s
m_timeout	cmt2.h	/^	uint32_t m_timeout;$/;"	m	class:xsens::Cmt2s
m_timeoutConf	cmt3.h	/^	uint32_t m_timeoutConf;	\/\/!< The config mode timeout.$/;"	m	class:xsens::Cmt3
m_timeoutMeas	cmt3.h	/^	uint32_t m_timeoutMeas;			\/\/!< The measurement mode timeout.$/;"	m	class:xsens::Cmt3
m_toEnd	cmt2.h	/^	uint32_t m_toEnd;$/;"	m	class:xsens::Cmt2s
m_toa	cmtpacket.h	/^	TimeStamp		m_toa;			\/\/!< Time of arrival$/;"	m	class:xsens::Packet
m_tstart	xsens_time.h	/^	uint32_t m_tstart;$/;"	m	class:xsens::MillisecondTimer
m_type	cmtdef.h	/^	uint8_t m_type;		\/\/!< The type of the scenario. When set to 255 in an operation, the 'current' scenario is used.$/;"	m	struct:CmtScenario
m_unicode	cmt1.h	/^	bool m_unicode;$/;"	m	class:xsens::Cmt1f
m_useRtc	cmt3.h	/^	bool m_useRtc;					\/\/!< Indicates if the RTC should be computed or not (to save CPU time).$/;"	m	class:xsens::Cmt3
m_utcDay	cmtpacket.h	/^		uint16_t m_utcDay;$/;"	m	struct:xsens::Packet::PacketInfo
m_utcHour	cmtpacket.h	/^		uint16_t m_utcHour;$/;"	m	struct:xsens::Packet::PacketInfo
m_utcMinute	cmtpacket.h	/^		uint16_t m_utcMinute;$/;"	m	struct:xsens::Packet::PacketInfo
m_utcMonth	cmtpacket.h	/^		uint16_t m_utcMonth;$/;"	m	struct:xsens::Packet::PacketInfo
m_utcNano	cmtpacket.h	/^		uint16_t m_utcNano;$/;"	m	struct:xsens::Packet::PacketInfo
m_utcSecond	cmtpacket.h	/^		uint16_t m_utcSecond;$/;"	m	struct:xsens::Packet::PacketInfo
m_utcTime	cmtpacket.h	/^		uint16_t m_utcTime;$/;"	m	struct:xsens::Packet::PacketInfo
m_utcValid	cmtpacket.h	/^		uint16_t m_utcValid;$/;"	m	struct:xsens::Packet::PacketInfo
m_utcYear	cmtpacket.h	/^		uint16_t m_utcYear;$/;"	m	struct:xsens::Packet::PacketInfo
m_vacc	cmtdef.h	/^	uint32_t	m_vacc;$/;"	m	struct:CmtGpsPvtData
m_valid	cmtdef.h	/^	uint8_t	m_valid;	\/\/!< When set to 1, the time is valid, when set to 2, the time part is valid, but the date may not be valid. when set to 0, the time is invalid and should be ignored.$/;"	m	struct:CmtUtcTime
m_velNEDorNWU	cmtpacket.h	/^		uint16_t m_velNEDorNWU;$/;"	m	struct:xsens::Packet::PacketInfo
m_veld	cmtdef.h	/^	int32_t		m_veld;$/;"	m	struct:CmtGpsPvtData
m_vele	cmtdef.h	/^	int32_t		m_vele;$/;"	m	struct:CmtGpsPvtData
m_veln	cmtdef.h	/^	int32_t		m_veln;$/;"	m	struct:CmtGpsPvtData
m_version	cmtdef.h	/^	uint8_t m_version;	\/\/!< The version of the scenario.$/;"	m	struct:CmtScenario
m_what	xsens_exception.h	/^	std::string m_what;$/;"	m	class:xsens::Exception
m_writeBufSize	cmt3.h	/^	uint32_t m_writeBufSize;				\/\/!< Contains the size of the serial write buffer$/;"	m	class:xsens::Cmt3
m_writePos	cmt1.h	/^	XsensFilePos m_writePos;$/;"	m	class:xsens::Cmt1f
m_xm	cmtpacket.h	/^	bool m_xm;						\/\/!< Indicates that xbus-formatting is used$/;"	m	class:xsens::Packet
m_yaw	cmtdef.h	/^	double m_yaw;		\/\/!< The yaw (rotation around z-axis \/ down-up-line)$/;"	m	struct:CmtEuler
m_year	cmtdef.h	/^	uint16_t	m_year;$/;"	m	struct:CmtUtcTime
main	GPSReceive.cpp	/^int main(int argc, char *argv[])$/;"	f
main	example1s_mt_linux.cpp	/^int main(void)$/;"	f
main	example2s_mt_linux.cpp	/^int main(void)$/;"	f
main	example3s_mt_linux.cpp	/^int main(void)$/;"	f
main	example_linux.cpp	/^int main(int argc, char* argv[])$/;"	f
main	myexample.cpp	/^int main(void)$/;"	f
main	pstdint.h	/^int main () {$/;"	f
millisecondsElapsed	xsens_time.cpp	/^uint32_t MillisecondTimer::millisecondsElapsed()$/;"	f	class:xsens::MillisecondTimer
msleep	xsens_time.cpp	/^void msleep(uint32_t ms)$/;"	f	namespace:xsens
open	cmt1.cpp	/^XsensResultValue Cmt1f::open(const char* filename, const bool create, const bool readOnly)$/;"	f	class:xsens::Cmt1f
open	cmt1.cpp	/^XsensResultValue Cmt1f::open(const wchar_t* filename, const bool create, const bool readOnly)$/;"	f	class:xsens::Cmt1f
open	cmt1.cpp	/^XsensResultValue Cmt1s::open (	const uint32_t portNumber,$/;"	f	class:xsens::Cmt1s
open	cmt1.cpp	/^XsensResultValue Cmt1s::open(  const char *portName,$/;"	f	class:xsens::Cmt1s
open	cmt2.cpp	/^XsensResultValue Cmt2f::open(const char* filename, const bool readOnly)$/;"	f	class:xsens::Cmt2f
open	cmt2.cpp	/^XsensResultValue Cmt2f::open(const wchar_t* filename, const bool readOnly)$/;"	f	class:xsens::Cmt2f
open	cmt2.cpp	/^XsensResultValue Cmt2s::open (const char *portName, const uint32_t baudRate, uint32_t readBufSize, uint32_t writeBufSize)$/;"	f	class:xsens::Cmt2s
open	cmt2.cpp	/^XsensResultValue Cmt2s::open (const uint32_t portNumber, const uint32_t baudRate, uint32_t readBufSize, uint32_t writeBufSize)$/;"	f	class:xsens::Cmt2s
openLogFile	cmt3.cpp	/^XsensResultValue Cmt3::openLogFile(const char* filename)$/;"	f	class:xsens::Cmt3
openLogFile	cmt3.cpp	/^XsensResultValue Cmt3::openLogFile(const wchar_t* filename)$/;"	f	class:xsens::Cmt3
openPort	cmt3.cpp	/^XsensResultValue Cmt3::openPort(const char *portName, const uint32_t baudRate, uint32_t readBufSize, uint32_t writeBufSize)$/;"	f	class:xsens::Cmt3
openPort	cmt3.cpp	/^XsensResultValue Cmt3::openPort(const uint32_t portNumber, const uint32_t baudRate, uint32_t readBufSize, uint32_t writeBufSize)$/;"	f	class:xsens::Cmt3
operator <	cmtdef.h	/^	bool operator < (const CmtPortInfo& p) const { return m_portNr < p.m_portNr; }$/;"	f	struct:CmtPortInfo
operator <	cmtdef.h	/^	bool operator < (const CmtPortInfo& p) const { return strcmp(m_portName, p.m_portName) < 0; }$/;"	f	struct:CmtPortInfo
operator =	cmtmessage.cpp	/^void Message::operator = (const Message& src)$/;"	f	class:xsens::Message
operator =	cmtpacket.cpp	/^void Packet::operator = (const Packet& pack)$/;"	f	class:xsens::Packet
operator =	xsens_fifoqueue.h	/^	FifoQueue<T,E>& operator=(const FifoQueue<T,E2>& q)$/;"	f	class:xsens::FifoQueue
operator =	xsens_fifoqueue.h	/^	FifoQueueBasic<T>& operator=(const FifoQueueBasic<T>& q)$/;"	f	class:xsens::FifoQueueBasic
operator ==	cmt3.cpp	/^bool CmtDeviceMode2::operator == (const CmtDeviceMode2& dev) const$/;"	f	class:CmtDeviceMode2
operator ==	cmt3.cpp	/^bool CmtDeviceMode::operator == (const CmtDeviceMode& dev) const$/;"	f	class:CmtDeviceMode
operator ==	cmtdef.h	/^	bool operator == (const CmtPortInfo& p) const { return m_portNr == p.m_portNr; }$/;"	f	struct:CmtPortInfo
operator ==	cmtdef.h	/^	bool operator == (const CmtPortInfo& p) const { return strcmp(m_portName, p.m_portName) == 0; }$/;"	f	struct:CmtPortInfo
operator ==	cmtdef.h	/^	bool operator == (const char *port) const { return strcmp(m_portName, port) == 0; }$/;"	f	struct:CmtPortInfo
operator ==	cmtdef.h	/^	bool operator == (const uint16_t port) const { (void)port; return false; }$/;"	f	struct:CmtPortInfo
operator ==	cmtdef.h	/^	bool operator == (const uint16_t port) const { return m_portNr == port; }$/;"	f	struct:CmtPortInfo
operator ==	xsens_list.h	/^bool List<T>::operator == (const List<TB>& lst)$/;"	f	class:xsens::List
operator >	cmtdef.h	/^	bool operator > (const CmtPortInfo& p) const { return m_portNr > p.m_portNr; }$/;"	f	struct:CmtPortInfo
operator >	cmtdef.h	/^	bool operator > (const CmtPortInfo& p) const { return strcmp(m_portName, p.m_portName) > 0; }$/;"	f	struct:CmtPortInfo
operator []	xsens_fifoqueue.h	/^	const value_type& operator[] (size_t index) const$/;"	f	class:xsens::FifoQueue
operator []	xsens_fifoqueue.h	/^	const value_type& operator[] (size_t index) const$/;"	f	class:xsens::FifoQueueBasic
operator []	xsens_fifoqueue.h	/^	value_type& operator[] (size_t index)$/;"	f	class:xsens::FifoQueue
operator []	xsens_fifoqueue.h	/^	value_type& operator[] (size_t index)$/;"	f	class:xsens::FifoQueueBasic
peekLogMessageId	cmt3.cpp	/^XsensResultValue Cmt3::peekLogMessageId(uint8_t& messageId)$/;"	f	class:xsens::Cmt3
pop	xsens_fifoqueue.h	/^	void pop(void)$/;"	f	class:xsens::FifoQueue
pop	xsens_fifoqueue.h	/^	void pop(void)$/;"	f	class:xsens::FifoQueueBasic
popBack	xsens_fifoqueue.h	/^	void popBack(void)$/;"	f	class:xsens::FifoQueue
popBack	xsens_fifoqueue.h	/^	void popBack(void)$/;"	f	class:xsens::FifoQueueBasic
push	xsens_fifoqueue.h	/^	void push(const value_type& x)$/;"	f	class:xsens::FifoQueue
push	xsens_fifoqueue.h	/^	void push(const value_type& x)$/;"	f	class:xsens::FifoQueueBasic
push_front	xsens_fifoqueue.h	/^	void push_front(const value_type& x)$/;"	f	class:xsens::FifoQueueBasic
qSort	xsens_list.h	/^void List<T>::qSort(uint32_t left, uint32_t right)$/;"	f	class:xsens::List
qSortDeref	xsens_list.h	/^void List<T>::qSortDeref(uint32_t left, uint32_t right)$/;"	f	class:xsens::List
quit	GPSReceive.cpp	/^int quit = 0;$/;"	v
quit	example1s_mt_linux.cpp	/^volatile int quit = 0;$/;"	v
quit	example2s_mt_linux.cpp	/^int quit = 0;$/;"	v
quit	example3s_mt_linux.cpp	/^int quit = 0;$/;"	v
quit	myexample.cpp	/^int quit = 0;$/;"	v
readData	cmt1.cpp	/^XsensResultValue Cmt1f::readData (const uint32_t maxLength, const char terminator, void* dataV, uint32_t* length)$/;"	f	class:xsens::Cmt1f
readData	cmt1.cpp	/^XsensResultValue Cmt1f::readData(const uint32_t maxLength, void* data, uint32_t* length)$/;"	f	class:xsens::Cmt1f
readData	cmt1.cpp	/^XsensResultValue Cmt1s::readData (const uint32_t maxLength, uint8_t* data,$/;"	f	class:xsens::Cmt1s
readDataPacket	cmt3.cpp	/^XsensResultValue Cmt3::readDataPacket(Packet* pack, bool acceptOther)$/;"	f	class:xsens::Cmt3
readFromMessage	cmt3.cpp	/^void CmtDeviceConfiguration::readFromMessage(const void* message)$/;"	f	class:CmtDeviceConfiguration
readMessage	cmt2.cpp	/^XsensResultValue Cmt2f::readMessage(Message* msg, const uint8_t msgId)$/;"	f	class:xsens::Cmt2f
readMessage	cmt2.cpp	/^XsensResultValue Cmt2s::readMessage(Message* rcv)$/;"	f	class:xsens::Cmt2s
recomputeChecksum	cmtmessage.h	/^	void recomputeChecksum(void) { m_checksum[0] = calcChecksum(); }$/;"	f	class:xsens::Message
refreshCache	cmt3.cpp	/^XsensResultValue Cmt3::refreshCache(const bool file)$/;"	f	class:xsens::Cmt3
remove	xsens_fifoqueue.h	/^	void remove(size_t index)$/;"	f	class:xsens::FifoQueue
remove	xsens_fifoqueue.h	/^	void remove(size_t index)$/;"	f	class:xsens::FifoQueueBasic
removeDuplicateEntries	xsens_list.h	/^uint32_t List<T>::removeDuplicateEntries(void)$/;"	f	class:xsens::List
removeDuplicateEntriesDeref	xsens_list.h	/^uint32_t List<T>::removeDuplicateEntriesDeref(void)$/;"	f	class:xsens::List
requestData	cmt3.cpp	/^XsensResultValue Cmt3::requestData(Packet* pack, const uint8_t *data, const uint16_t count)$/;"	f	class:xsens::Cmt3
reset	cmt3.cpp	/^XsensResultValue Cmt3::reset(void)$/;"	f	class:xsens::Cmt3
reset	xsens_time.cpp	/^void TimeSync::reset()$/;"	f	class:xsens::TimeSync
resetLogFileReadPos	cmt3.cpp	/^XsensResultValue Cmt3::resetLogFileReadPos(void)$/;"	f	class:xsens::Cmt3
resetOrientation	cmt3.cpp	/^XsensResultValue Cmt3::resetOrientation(const CmtResetMethod method, const CmtDeviceId deviceId)$/;"	f	class:xsens::Cmt3
resize	xsens_fifoqueue.h	/^	void resize(const size_t size)$/;"	f	class:xsens::FifoQueue
resize	xsens_fifoqueue.h	/^	void resize(const size_t size)$/;"	f	class:xsens::FifoQueueBasic
resize	xsens_list.h	/^void List<T>::resize(uint32_t newSize)$/;"	f	class:xsens::List
resizeData	cmtmessage.cpp	/^void Message::resizeData(const uint16_t newSize)$/;"	f	class:xsens::Message
restart	xsens_time.cpp	/^void MillisecondTimer::restart()$/;"	f	class:xsens::MillisecondTimer
restoreFactoryDefaults	cmt3.cpp	/^XsensResultValue Cmt3::restoreFactoryDefaults(const CmtDeviceId deviceId)$/;"	f	class:xsens::Cmt3
reverse	xsens_list.h	/^void List<T>::reverse(void)$/;"	f	class:xsens::List
reverseFind	xsens_list.h	/^uint32_t List<T>::reverseFind(const TB& item) const$/;"	f	class:xsens::List
reverseFindDeref	xsens_list.h	/^uint32_t List<T>::reverseFindDeref(const TB& item) const$/;"	f	class:xsens::List
runSelfTest	cmt3.cpp	/^XsensResultValue Cmt3::runSelfTest(uint16_t &result, const CmtDeviceId deviceId)$/;"	f	class:xsens::Cmt3
rx_log	cmt1.h	/^		FILE* rx_log;$/;"	m	class:xsens::Cmt1s
s0	cmtmessage.cpp	/^		int16_t s3,s2,s1,s0;$/;"	m	struct:xsens::Itypes::__anon2	file:
s1	cmtmessage.cpp	/^		int16_t s3,s2,s1,s0;$/;"	m	struct:xsens::Itypes::__anon2	file:
s2	cmtmessage.cpp	/^		int16_t s3,s2,s1,s0;$/;"	m	struct:xsens::Itypes::__anon2	file:
s3	cmtmessage.cpp	/^		int16_t s3,s2,s1,s0;$/;"	m	struct:xsens::Itypes::__anon2	file:
setBaudrate	cmt3.cpp	/^XsensResultValue Cmt3::setBaudrate(const uint32_t baudrate, bool reconnect)$/;"	f	class:xsens::Cmt3
setBluetoothState	cmt3.cpp	/^XsensResultValue Cmt3::setBluetoothState(const bool enabled)$/;"	f	class:xsens::Cmt3
setBusId	cmtmessage.cpp	/^void Message::setBusId(const uint8_t busId)$/;"	f	class:xsens::Message
setBusPowerState	cmt3.cpp	/^XsensResultValue Cmt3::setBusPowerState(const bool enabled)$/;"	f	class:xsens::Cmt3
setCallbackFunction	cmt1.cpp	/^XsensResultValue Cmt1s::setCallbackFunction(CmtCallbackType tp, int32_t instance, CmtCallbackFunction func, void* param)$/;"	f	class:xsens::Cmt1s
setCallbackFunction	cmt2.cpp	/^XsensResultValue Cmt2s::setCallbackFunction(CmtCallbackType tp, int32_t instance, CmtCallbackFunction func, void* param)$/;"	f	class:xsens::Cmt2s
setDataBuffer	cmtmessage.cpp	/^void Message::setDataBuffer(const uint8_t* data, const uint16_t offset,$/;"	f	class:xsens::Message
setDataByte	cmtmessage.cpp	/^void Message::setDataByte(const uint8_t data, const uint16_t offset)$/;"	f	class:xsens::Message
setDataDouble	cmtmessage.cpp	/^void Message::setDataDouble(const double data, const uint16_t offset)$/;"	f	class:xsens::Message
setDataF1220	cmtmessage.cpp	/^void Message::setDataF1220(const double data, const uint16_t offset)$/;"	f	class:xsens::Message
setDataFP1632	cmtmessage.cpp	/^void Message::setDataFP1632(const double data, const uint16_t offset)$/;"	f	class:xsens::Message
setDataFPValue	cmtmessage.cpp	/^void Message::setDataFPValue(const uint64_t outputSettings, const double *data, uint16_t offset, const uint16_t numValues)$/;"	f	class:xsens::Message
setDataFPValue	cmtmessage.cpp	/^void Message::setDataFPValue(const uint64_t outputSettings, const double data, const uint16_t offset)$/;"	f	class:xsens::Message
setDataFloat	cmtmessage.cpp	/^void Message::setDataFloat(const float data, const uint16_t offset)$/;"	f	class:xsens::Message
setDataFormat	cmtpacket.cpp	/^bool Packet::setDataFormat(const CmtDataFormat& format, const uint16_t index)$/;"	f	class:xsens::Packet
setDataFormat	cmtpacket.cpp	/^bool Packet::setDataFormat(const CmtOutputMode outputMode, const CmtOutputSettings outputSettings, const uint16_t index)$/;"	f	class:xsens::Packet
setDataLong	cmtmessage.cpp	/^void Message::setDataLong(const uint32_t data, const uint16_t offset)$/;"	f	class:xsens::Message
setDataShort	cmtmessage.cpp	/^void Message::setDataShort(const uint16_t data, const uint16_t offset)$/;"	f	class:xsens::Message
setDataSource	cmt3.cpp	/^XsensResultValue Cmt3::setDataSource(bool readFromFile)$/;"	f	class:xsens::Cmt3
setDeviceMode	cmt3.cpp	/^XsensResultValue Cmt3::setDeviceMode (const CmtDeviceMode& mode, bool force, const CmtDeviceId deviceId)$/;"	f	class:xsens::Cmt3
setDeviceMode2	cmt3.cpp	/^XsensResultValue Cmt3::setDeviceMode2 (const CmtDeviceMode2& mode, bool force, const CmtDeviceId deviceId)$/;"	f	class:xsens::Cmt3
setErrorMode	cmt3.cpp	/^XsensResultValue Cmt3::setErrorMode(const uint16_t mode)$/;"	f	class:xsens::Cmt3
setGotoConfigTries	cmt3.cpp	/^XsensResultValue Cmt3::setGotoConfigTries(const uint16_t tries)$/;"	f	class:xsens::Cmt3
setGpsLeverArm	cmt3.cpp	/^XsensResultValue Cmt3::setGpsLeverArm(const CmtVector& arm, const CmtDeviceId deviceId)$/;"	f	class:xsens::Cmt3
setGravityMagnitude	cmt3.cpp	/^XsensResultValue Cmt3::setGravityMagnitude(const double magnitude, const CmtDeviceId deviceId)$/;"	f	class:xsens::Cmt3
setHeading	cmt3.cpp	/^XsensResultValue Cmt3::setHeading (const double heading, const CmtDeviceId deviceId)$/;"	f	class:xsens::Cmt3
setInitialSkew	xsens_time.cpp	/^void TimeSync::setInitialSkew(double skew)$/;"	f	class:xsens::TimeSync
setLatLonAlt	cmt3.cpp	/^XsensResultValue Cmt3::setLatLonAlt(const CmtVector& lla, const CmtDeviceId deviceId)$/;"	f	class:xsens::Cmt3
setLocationId	cmt3.cpp	/^XsensResultValue Cmt3::setLocationId (uint16_t locationId, const CmtDeviceId deviceId)$/;"	f	class:xsens::Cmt3
setLogMode	cmt3.cpp	/^XsensResultValue Cmt3::setLogMode(bool active)$/;"	f	class:xsens::Cmt3
setMagneticDeclination	cmt3.cpp	/^XsensResultValue Cmt3::setMagneticDeclination(const double declination, const CmtDeviceId deviceId)$/;"	f	class:xsens::Cmt3
setMessageId	cmtmessage.cpp	/^void Message::setMessageId(const uint8_t msgId)$/;"	f	class:xsens::Message
setNoRotation	cmt3.cpp	/^XsensResultValue Cmt3::setNoRotation(const uint16_t duration, const CmtDeviceId deviceId)$/;"	f	class:xsens::Cmt3
setObjectAlignmentMatrix	cmt3.cpp	/^XsensResultValue Cmt3::setObjectAlignmentMatrix(const CmtMatrix& matrix, const CmtDeviceId deviceId)$/;"	f	class:xsens::Cmt3
setPeriodAndSkipFactor	cmt3.cpp	/^void CmtDeviceMode::setPeriodAndSkipFactor(uint16_t period, uint16_t skip)$/;"	f	class:CmtDeviceMode
setProcessingFlags	cmt3.cpp	/^XsensResultValue Cmt3::setProcessingFlags (uint16_t processingFlags, const CmtDeviceId deviceId)$/;"	f	class:xsens::Cmt3
setReadPos	cmt1.cpp	/^XsensResultValue Cmt1f::setReadPos (const XsensFilePos pos)$/;"	f	class:xsens::Cmt1f
setReadPosition	cmt2.cpp	/^XsensResultValue Cmt2f::setReadPosition(XsensFilePos pos)$/;"	f	class:xsens::Cmt2f
setSampleFrequency	cmt3.cpp	/^void CmtDeviceMode2::setSampleFrequency(uint16_t frequency)$/;"	f	class:CmtDeviceMode2
setScenario	cmt3.cpp	/^XsensResultValue Cmt3::setScenario(const uint8_t scenarioType, const CmtDeviceId deviceId)$/;"	f	class:xsens::Cmt3
setSyncInMode	cmt3.cpp	/^XsensResultValue Cmt3::setSyncInMode (const uint16_t mode)$/;"	f	class:xsens::Cmt3
setSyncInOffset	cmt3.cpp	/^XsensResultValue Cmt3::setSyncInOffset (const uint32_t offset)$/;"	f	class:xsens::Cmt3
setSyncInSettings	cmt3.cpp	/^XsensResultValue Cmt3::setSyncInSettings (const CmtSyncInSettings& settings)$/;"	f	class:xsens::Cmt3
setSyncInSkipFactor	cmt3.cpp	/^XsensResultValue Cmt3::setSyncInSkipFactor (const uint16_t skipFactor)$/;"	f	class:xsens::Cmt3
setSyncMode	cmt3.cpp	/^XsensResultValue Cmt3::setSyncMode(const uint8_t mode)$/;"	f	class:xsens::Cmt3
setSyncOutMode	cmt3.cpp	/^XsensResultValue Cmt3::setSyncOutMode (const uint16_t mode)$/;"	f	class:xsens::Cmt3
setSyncOutOffset	cmt3.cpp	/^XsensResultValue Cmt3::setSyncOutOffset(const uint32_t offset)$/;"	f	class:xsens::Cmt3
setSyncOutPulseWidth	cmt3.cpp	/^XsensResultValue Cmt3::setSyncOutPulseWidth(const uint32_t pulseWidth)$/;"	f	class:xsens::Cmt3
setSyncOutSettings	cmt3.cpp	/^XsensResultValue Cmt3::setSyncOutSettings (const CmtSyncOutSettings& settings)$/;"	f	class:xsens::Cmt3
setSyncOutSkipFactor	cmt3.cpp	/^XsensResultValue Cmt3::setSyncOutSkipFactor(const uint16_t skipFactor)$/;"	f	class:xsens::Cmt3
setTimeout	cmt1.cpp	/^XsensResultValue Cmt1s::setTimeout (const uint32_t ms)$/;"	f	class:xsens::Cmt1s
setTimeout	cmt2.cpp	/^XsensResultValue Cmt2s::setTimeout (const uint32_t ms)$/;"	f	class:xsens::Cmt2s
setTimeout	cmt3.h	/^	XsensResultValue setTimeout (const uint32_t ms)						\/\/!< \\brief Set the default timeout value to use in blocking operations on the communication port.$/;"	f	class:xsens::Cmt3
setTimeoutConfig	cmt3.cpp	/^XsensResultValue Cmt3::setTimeoutConfig(const uint32_t timeout)$/;"	f	class:xsens::Cmt3
setTimeoutMeasurement	cmt3.cpp	/^XsensResultValue Cmt3::setTimeoutMeasurement(const uint32_t timeout)$/;"	f	class:xsens::Cmt3
setTransmissionDelay	cmt3.cpp	/^XsensResultValue Cmt3::setTransmissionDelay(const uint16_t delay)$/;"	f	class:xsens::Cmt3
setWritePos	cmt1.cpp	/^XsensResultValue Cmt1f::setWritePos(const XsensFilePos pos)$/;"	f	class:xsens::Cmt1f
setXbus	cmtpacket.cpp	/^void Packet::setXbus(bool xbus, bool convert)$/;"	f	class:xsens::Packet
setXmOutputMode	cmt3.cpp	/^XsensResultValue Cmt3::setXmOutputMode(const uint8_t mode)$/;"	f	class:xsens::Cmt3
setXmPowerOff	cmt3.cpp	/^XsensResultValue Cmt3::setXmPowerOff(void)$/;"	f	class:xsens::Cmt3
size	xsens_fifoqueue.h	/^	size_type size() const$/;"	f	class:xsens::FifoQueue
size	xsens_fifoqueue.h	/^	size_type size() const$/;"	f	class:xsens::FifoQueueBasic
size_type	xsens_fifoqueue.h	/^	typedef size_t	size_type;		\/\/!< The type of a 'size' value.$/;"	t	class:xsens::FifoQueue
size_type	xsens_fifoqueue.h	/^	typedef size_t	size_type;		\/\/!< The type of a 'size' value.$/;"	t	class:xsens::FifoQueueBasic
sortAscending	xsens_list.h	/^void List<T>::sortAscending(void)$/;"	f	class:xsens::List
sortAscendingDeref	xsens_list.h	/^void List<T>::sortAscendingDeref(void)$/;"	f	class:xsens::List
stdint_int64_defined	pstdint.h	455;"	d
stdint_int64_defined	pstdint.h	458;"	d
stdint_int64_defined	pstdint.h	471;"	d
stdint_int64_defined	pstdint.h	480;"	d
stdint_int64_defined	pstdint.h	489;"	d
stdint_int64_defined	pstdint.h	498;"	d
stdint_int64_defined	pstdint.h	679;"	d
stdint_intptr_bits	pstdint.h	707;"	d
stdint_intptr_bits	pstdint.h	710;"	d
stdint_intptr_bits	pstdint.h	712;"	d
stdint_intptr_bits	pstdint.h	715;"	d
stdint_intptr_glue3	pstdint.h	722;"	d
stdint_intptr_glue3_i	pstdint.h	721;"	d
stdint_least_defined	pstdint.h	631;"	d
storeXkfState	cmt3.cpp	/^XsensResultValue Cmt3::storeXkfState(const CmtDeviceId deviceId)$/;"	f	class:xsens::Cmt3
swapEndian16	cmtmessage.h	71;"	d
swapEndian32	cmtmessage.h	72;"	d
tCR	xsens_time.cpp	/^	double tS, tR, tCR;$/;"	m	struct:xsens::TimeSyncHistoryUnit	file:
tR	xsens_time.cpp	/^	double tS, tR, tCR;$/;"	m	struct:xsens::TimeSyncHistoryUnit	file:
tS	xsens_time.cpp	/^	double tS, tR, tCR;$/;"	m	struct:xsens::TimeSyncHistoryUnit	file:
t_func_JanitorClassFunc	xsens_janitors.h	/^	typedef R (T::*t_func_JanitorClassFunc)(P1);$/;"	t	class:xsens::JanitorClassFuncP1
t_func_JanitorClassFunc	xsens_janitors.h	/^	typedef R (T::*t_func_JanitorClassFunc)(void);$/;"	t	class:xsens::JanitorClassFunc
timeStampNow	xsens_time.cpp	/^TimeStamp timeStampNow()$/;"	f	namespace:xsens
twinSortAscending	xsens_list.h	/^void List<T>::twinSortAscending(List<T2>& twin)$/;"	f	class:xsens::List
tx_log	cmt1.h	/^		FILE* tx_log;$/;"	m	class:xsens::Cmt1s
uint16_t	pstdint.h	/^  typedef unsigned int uint16_t;$/;"	t
uint16_t	pstdint.h	/^  typedef unsigned short uint16_t;$/;"	t
uint32_t	pstdint.h	/^  typedef unsigned long uint32_t;$/;"	t
uint32_t	pstdint.h	/^  typedef unsigned short uint32_t;$/;"	t
uint32_t	pstdint.h	/^typedef unsigned int uint32_t;$/;"	t
uint64_t	pstdint.h	/^   __extension__ typedef unsigned long long uint64_t;$/;"	t
uint64_t	pstdint.h	/^   __extension__ typedef unsigned long uint64_t;$/;"	t
uint64_t	pstdint.h	/^   typedef unsigned __int64 uint64_t;$/;"	t
uint64_t	pstdint.h	/^   typedef unsigned long long uint64_t;$/;"	t
uint8_t	pstdint.h	/^    typedef unsigned char uint8_t;$/;"	t
uint_fast16_t	pstdint.h	/^typedef uint_least16_t uint_fast16_t;$/;"	t
uint_fast32_t	pstdint.h	/^typedef uint_least32_t uint_fast32_t;$/;"	t
uint_fast64_t	pstdint.h	/^  typedef uint_least64_t uint_fast64_t;$/;"	t
uint_fast8_t	pstdint.h	/^typedef  uint_least8_t  uint_fast8_t;$/;"	t
uint_least16_t	pstdint.h	/^  typedef uint16_t uint_least16_t;$/;"	t
uint_least32_t	pstdint.h	/^  typedef uint32_t uint_least32_t;$/;"	t
uint_least64_t	pstdint.h	/^    typedef uint64_t uint_least64_t;$/;"	t
uint_least8_t	pstdint.h	/^  typedef  uint8_t  uint_least8_t;$/;"	t
uintmax_t	pstdint.h	/^  typedef uint32_t uintmax_t;$/;"	t
uintmax_t	pstdint.h	/^  typedef uint64_t uintmax_t;$/;"	t
uintptr_t	pstdint.h	/^  typedef stdint_intptr_glue3(uint,stdint_intptr_bits,_t) uintptr_t;$/;"	t
update	xsens_time.cpp	/^void TimeSync::update(TimeStamp local, TimeStamp external)$/;"	f	class:xsens::TimeSync
updateAccG	cmtpacket.cpp	/^bool Packet::updateAccG(const CmtVector& g, const uint16_t index)$/;"	f	class:xsens::Packet
updateAnalogIn1	cmtpacket.cpp	/^bool Packet::updateAnalogIn1(const CmtAnalogInData& data, const uint16_t index)$/;"	f	class:xsens::Packet
updateAnalogIn2	cmtpacket.cpp	/^bool Packet::updateAnalogIn2(const CmtAnalogInData& data, const uint16_t index)$/;"	f	class:xsens::Packet
updateCalAcc	cmtpacket.cpp	/^bool Packet::updateCalAcc(const CmtVector& vec, const uint16_t index)$/;"	f	class:xsens::Packet
updateCalData	cmtpacket.cpp	/^bool Packet::updateCalData(const CmtCalData& data, const uint16_t index)$/;"	f	class:xsens::Packet
updateCalGyr	cmtpacket.cpp	/^bool Packet::updateCalGyr(const CmtVector& vec, const uint16_t index)$/;"	f	class:xsens::Packet
updateCalMag	cmtpacket.cpp	/^bool Packet::updateCalMag(const CmtVector& vec, const uint16_t index)$/;"	f	class:xsens::Packet
updateGpsPvtData	cmtpacket.cpp	/^bool Packet::updateGpsPvtData(const CmtGpsPvtData& data, const uint16_t index)$/;"	f	class:xsens::Packet
updateOriEuler	cmtpacket.cpp	/^bool Packet::updateOriEuler(const CmtEuler& data, const uint16_t index)$/;"	f	class:xsens::Packet
updateOriMatrix	cmtpacket.cpp	/^bool Packet::updateOriMatrix(const CmtMatrix& data, const uint16_t index)$/;"	f	class:xsens::Packet
updateOriQuat	cmtpacket.cpp	/^bool Packet::updateOriQuat(const CmtQuat& data, const uint16_t index)$/;"	f	class:xsens::Packet
updatePositionLLA	cmtpacket.cpp	/^bool Packet::updatePositionLLA(const CmtVector& data, const uint16_t index)$/;"	f	class:xsens::Packet
updateRawAcc	cmtpacket.cpp	/^bool Packet::updateRawAcc(const CmtShortVector& vec, const uint16_t index)$/;"	f	class:xsens::Packet
updateRawData	cmtpacket.cpp	/^bool Packet::updateRawData(const CmtRawData& data, const uint16_t index)$/;"	f	class:xsens::Packet
updateRawGpsData	cmtpacket.h	189;"	d
updateRawGyr	cmtpacket.cpp	/^bool Packet::updateRawGyr(const CmtShortVector& vec, const uint16_t index)$/;"	f	class:xsens::Packet
updateRawMag	cmtpacket.cpp	/^bool Packet::updateRawMag(const CmtShortVector& vec, const uint16_t index)$/;"	f	class:xsens::Packet
updateRawPressureData	cmtpacket.cpp	/^bool Packet::updateRawPressureData(const CmtRawPressureData& data, const uint16_t index)$/;"	f	class:xsens::Packet
updateRawTemp	cmtpacket.cpp	/^bool Packet::updateRawTemp(const uint16_t temp, const uint16_t index)$/;"	f	class:xsens::Packet
updateSampleCounter	cmtpacket.cpp	/^bool Packet::updateSampleCounter(const uint16_t counter, const uint16_t index)$/;"	f	class:xsens::Packet
updateStatus	cmtpacket.cpp	/^bool Packet::updateStatus(const uint8_t data, const uint16_t index)$/;"	f	class:xsens::Packet
updateTemp	cmtpacket.cpp	/^bool Packet::updateTemp(const double& temp, const uint16_t index)$/;"	f	class:xsens::Packet
updateUtcTime	cmtpacket.cpp	/^bool Packet::updateUtcTime(const CmtUtcTime& data, const uint16_t index)$/;"	f	class:xsens::Packet
updateVelocity	cmtpacket.cpp	/^bool Packet::updateVelocity(const CmtVector& data, const uint16_t index)$/;"	f	class:xsens::Packet
value_type	xsens_fifoqueue.h	/^	typedef T		value_type;		\/\/!< The type of the value stored in this queue.$/;"	t	class:xsens::FifoQueue
value_type	xsens_fifoqueue.h	/^	typedef T		value_type;		\/\/!< The type of the value stored in this queue.$/;"	t	class:xsens::FifoQueueBasic
waitForData	cmt1.cpp	/^XsensResultValue Cmt1s::waitForData (const uint32_t maxLength,$/;"	f	class:xsens::Cmt1s
waitForDataMessage	cmt3.cpp	/^XsensResultValue Cmt3::waitForDataMessage(Packet* pack)$/;"	f	class:xsens::Cmt3
waitForMessage	cmt2.cpp	/^XsensResultValue Cmt2s::waitForMessage(Message* rcv, const uint8_t msgId, uint32_t timeoutOverride, bool acceptErrorMessage)$/;"	f	class:xsens::Cmt2s
what	xsens_exception.cpp	/^const char *Exception::what() const throw()$/;"	f	class:xsens::Exception
writeData	cmt1.cpp	/^XsensResultValue Cmt1f::writeData (const uint32_t length,  const void* data)$/;"	f	class:xsens::Cmt1f
writeData	cmt1.cpp	/^XsensResultValue Cmt1s::writeData (const uint32_t length,  const uint8_t* data,$/;"	f	class:xsens::Cmt1s
writeHeaders	example_linux.cpp	/^void writeHeaders(unsigned long mtCount, CmtOutputMode &mode, $/;"	f
writeMessage	cmt2.cpp	/^XsensResultValue Cmt2f::writeMessage(const Message* msg)$/;"	f	class:xsens::Cmt2f
writeMessage	cmt2.cpp	/^XsensResultValue Cmt2s::writeMessage(Message* msg)$/;"	f	class:xsens::Cmt2s
writeMessageToLogFile	cmt3.cpp	/^XsensResultValue Cmt3::writeMessageToLogFile(const Message& msg)$/;"	f	class:xsens::Cmt3
xsens	cmt1.cpp	/^namespace xsens {$/;"	n	file:
xsens	cmt1.h	/^namespace xsens {$/;"	n
xsens	cmt2.cpp	/^namespace xsens {$/;"	n	file:
xsens	cmt2.h	/^namespace xsens {$/;"	n
xsens	cmt3.cpp	/^namespace xsens {$/;"	n	file:
xsens	cmt3.h	/^namespace xsens {$/;"	n
xsens	cmtmessage.cpp	/^namespace xsens {$/;"	n	file:
xsens	cmtmessage.h	/^namespace xsens {$/;"	n
xsens	cmtpacket.cpp	/^namespace xsens {$/;"	n	file:
xsens	cmtpacket.h	/^namespace xsens {$/;"	n
xsens	cmtscan.cpp	/^namespace xsens {$/;"	n	file:
xsens	cmtscan.h	/^namespace xsens {$/;"	n
xsens	xsens_exception.cpp	/^namespace xsens {$/;"	n	file:
xsens	xsens_exception.h	/^namespace xsens {$/;"	n
xsens	xsens_fifoqueue.h	/^namespace xsens {$/;"	n
xsens	xsens_janitors.h	/^namespace xsens {$/;"	n
xsens	xsens_list.h	/^namespace xsens {$/;"	n
xsens	xsens_time.cpp	/^namespace xsens {$/;"	n	file:
xsens	xsens_time.h	/^namespace xsens {$/;"	n
xsens::CMTLOG	cmt1.cpp	/^void CMTLOG(const char *str, ...)$/;"	f	namespace:xsens
xsens::Cmt1f	cmt1.h	/^class Cmt1f {$/;"	c	namespace:xsens
xsens::Cmt1f::Cmt1f	cmt1.cpp	/^Cmt1f::Cmt1f()$/;"	f	class:xsens::Cmt1f
xsens::Cmt1f::appendData	cmt1.cpp	/^XsensResultValue Cmt1f::appendData (const uint32_t length,  const void* data)$/;"	f	class:xsens::Cmt1f
xsens::Cmt1f::close	cmt1.cpp	/^XsensResultValue Cmt1f::close (void)$/;"	f	class:xsens::Cmt1f
xsens::Cmt1f::closeAndDelete	cmt1.cpp	/^XsensResultValue Cmt1f::closeAndDelete(void)$/;"	f	class:xsens::Cmt1f
xsens::Cmt1f::create	cmt1.cpp	/^XsensResultValue Cmt1f::create (const char* filename)$/;"	f	class:xsens::Cmt1f
xsens::Cmt1f::create	cmt1.cpp	/^XsensResultValue Cmt1f::create (const wchar_t* filename)$/;"	f	class:xsens::Cmt1f
xsens::Cmt1f::deleteData	cmt1.cpp	/^XsensResultValue Cmt1f::deleteData (const XsensFilePos start, const uint32_t length)$/;"	f	class:xsens::Cmt1f
xsens::Cmt1f::find	cmt1.cpp	/^XsensResultValue Cmt1f::find (const void* needleV, const uint32_t needleLength, XsensFilePos& pos)$/;"	f	class:xsens::Cmt1f
xsens::Cmt1f::flushData	cmt1.cpp	/^XsensResultValue Cmt1f::flushData (void)$/;"	f	class:xsens::Cmt1f
xsens::Cmt1f::getFileSize	cmt1.h	/^	XsensFilePos getFileSize(void) const { return m_fileSize; }$/;"	f	class:xsens::Cmt1f
xsens::Cmt1f::getLastResult	cmt1.h	/^	XsensResultValue getLastResult(void) const	{ return m_lastResult; }$/;"	f	class:xsens::Cmt1f
xsens::Cmt1f::getName	cmt1.cpp	/^XsensResultValue Cmt1f::getName(char* filename) const$/;"	f	class:xsens::Cmt1f
xsens::Cmt1f::getName	cmt1.cpp	/^XsensResultValue Cmt1f::getName(wchar_t* filename) const$/;"	f	class:xsens::Cmt1f
xsens::Cmt1f::getReadPos	cmt1.h	/^	XsensFilePos getReadPos(void) const { return m_readPos; }$/;"	f	class:xsens::Cmt1f
xsens::Cmt1f::getWritePos	cmt1.h	/^	XsensFilePos getWritePos(void) const { return m_writePos; }$/;"	f	class:xsens::Cmt1f
xsens::Cmt1f::gotoRead	cmt1.cpp	/^void Cmt1f::gotoRead(void)$/;"	f	class:xsens::Cmt1f
xsens::Cmt1f::gotoWrite	cmt1.cpp	/^void Cmt1f::gotoWrite(void)$/;"	f	class:xsens::Cmt1f
xsens::Cmt1f::insertData	cmt1.cpp	/^XsensResultValue Cmt1f::insertData (const XsensFilePos start, const uint32_t length, const void* data)$/;"	f	class:xsens::Cmt1f
xsens::Cmt1f::isOpen	cmt1.h	/^	bool isOpen(void) const { return m_isOpen; }$/;"	f	class:xsens::Cmt1f
xsens::Cmt1f::isReadOnly	cmt1.h	/^	bool isReadOnly(void) const { return !m_isOpen || m_readOnly; }$/;"	f	class:xsens::Cmt1f
xsens::Cmt1f::m_fileSize	cmt1.h	/^	XsensFilePos m_fileSize;$/;"	m	class:xsens::Cmt1f
xsens::Cmt1f::m_filename	cmt1.h	/^	char m_filename[CMT_MAX_FILENAME_LENGTH];$/;"	m	class:xsens::Cmt1f
xsens::Cmt1f::m_filename_w	cmt1.h	/^	wchar_t m_filename_w[CMT_MAX_FILENAME_LENGTH];$/;"	m	class:xsens::Cmt1f
xsens::Cmt1f::m_handle	cmt1.h	/^	FILE* m_handle;$/;"	m	class:xsens::Cmt1f
xsens::Cmt1f::m_isOpen	cmt1.h	/^	bool m_isOpen;$/;"	m	class:xsens::Cmt1f
xsens::Cmt1f::m_lastResult	cmt1.h	/^	mutable XsensResultValue m_lastResult;$/;"	m	class:xsens::Cmt1f
xsens::Cmt1f::m_readOnly	cmt1.h	/^	bool m_readOnly;$/;"	m	class:xsens::Cmt1f
xsens::Cmt1f::m_readPos	cmt1.h	/^	XsensFilePos m_readPos;$/;"	m	class:xsens::Cmt1f
xsens::Cmt1f::m_reading	cmt1.h	/^	bool m_reading;$/;"	m	class:xsens::Cmt1f
xsens::Cmt1f::m_unicode	cmt1.h	/^	bool m_unicode;$/;"	m	class:xsens::Cmt1f
xsens::Cmt1f::m_writePos	cmt1.h	/^	XsensFilePos m_writePos;$/;"	m	class:xsens::Cmt1f
xsens::Cmt1f::open	cmt1.cpp	/^XsensResultValue Cmt1f::open(const char* filename, const bool create, const bool readOnly)$/;"	f	class:xsens::Cmt1f
xsens::Cmt1f::open	cmt1.cpp	/^XsensResultValue Cmt1f::open(const wchar_t* filename, const bool create, const bool readOnly)$/;"	f	class:xsens::Cmt1f
xsens::Cmt1f::readData	cmt1.cpp	/^XsensResultValue Cmt1f::readData (const uint32_t maxLength, const char terminator, void* dataV, uint32_t* length)$/;"	f	class:xsens::Cmt1f
xsens::Cmt1f::readData	cmt1.cpp	/^XsensResultValue Cmt1f::readData(const uint32_t maxLength, void* data, uint32_t* length)$/;"	f	class:xsens::Cmt1f
xsens::Cmt1f::setReadPos	cmt1.cpp	/^XsensResultValue Cmt1f::setReadPos (const XsensFilePos pos)$/;"	f	class:xsens::Cmt1f
xsens::Cmt1f::setWritePos	cmt1.cpp	/^XsensResultValue Cmt1f::setWritePos(const XsensFilePos pos)$/;"	f	class:xsens::Cmt1f
xsens::Cmt1f::writeData	cmt1.cpp	/^XsensResultValue Cmt1f::writeData (const uint32_t length,  const void* data)$/;"	f	class:xsens::Cmt1f
xsens::Cmt1f::~Cmt1f	cmt1.cpp	/^Cmt1f::~Cmt1f()$/;"	f	class:xsens::Cmt1f
xsens::Cmt1s	cmt1.h	/^class Cmt1s {$/;"	c	namespace:xsens
xsens::Cmt1s::Cmt1s	cmt1.cpp	/^Cmt1s::Cmt1s() :$/;"	f	class:xsens::Cmt1s
xsens::Cmt1s::close	cmt1.cpp	/^XsensResultValue Cmt1s::close (void)$/;"	f	class:xsens::Cmt1s
xsens::Cmt1s::escape	cmt1.cpp	/^XsensResultValue Cmt1s::escape (const CmtControlLine mask, const CmtControlLine state)$/;"	f	class:xsens::Cmt1s
xsens::Cmt1s::flushData	cmt1.cpp	/^XsensResultValue Cmt1s::flushData (void)$/;"	f	class:xsens::Cmt1s
xsens::Cmt1s::getBaudrate	cmt1.cpp	/^uint32_t Cmt1s::getBaudrate(void) const { return m_baudrate; }$/;"	f	class:xsens::Cmt1s
xsens::Cmt1s::getHandle	cmt1.cpp	/^HANDLE Cmt1s::getHandle(void) const { return m_handle; }$/;"	f	class:xsens::Cmt1s
xsens::Cmt1s::getLastResult	cmt1.cpp	/^XsensResultValue Cmt1s::getLastResult(void) const { return m_lastResult; }$/;"	f	class:xsens::Cmt1s
xsens::Cmt1s::getPortName	cmt1.cpp	/^void Cmt1s::getPortName(char *portname) const { sprintf(portname, "%s", m_portname); }$/;"	f	class:xsens::Cmt1s
xsens::Cmt1s::getPortNr	cmt1.cpp	/^uint16_t Cmt1s::getPortNr (void) const { return m_port; }$/;"	f	class:xsens::Cmt1s
xsens::Cmt1s::getTimeout	cmt1.cpp	/^uint32_t Cmt1s::getTimeout (void) const { return m_timeout; }$/;"	f	class:xsens::Cmt1s
xsens::Cmt1s::isOpen	cmt1.cpp	/^bool Cmt1s::isOpen (void) const { return m_isOpen; }$/;"	f	class:xsens::Cmt1s
xsens::Cmt1s::m_baudrate	cmt1.h	/^	uint32_t m_baudrate;$/;"	m	class:xsens::Cmt1s
xsens::Cmt1s::m_commState	cmt1.h	/^		DCB		m_commState;		\/\/!< Stored settings about the serial port$/;"	m	class:xsens::Cmt1s
xsens::Cmt1s::m_commState	cmt1.h	/^		termios	m_commState;		\/\/!< Stored settings about the serial port$/;"	m	class:xsens::Cmt1s
xsens::Cmt1s::m_endTime	cmt1.h	/^	uint32_t m_endTime;$/;"	m	class:xsens::Cmt1s
xsens::Cmt1s::m_handle	cmt1.h	/^		HANDLE	m_handle;			\/\/!< The serial port handle$/;"	m	class:xsens::Cmt1s
xsens::Cmt1s::m_handle	cmt1.h	/^		int32_t		m_handle;			\/\/!< The serial port handle$/;"	m	class:xsens::Cmt1s
xsens::Cmt1s::m_isOpen	cmt1.h	/^	bool m_isOpen;$/;"	m	class:xsens::Cmt1s
xsens::Cmt1s::m_lastResult	cmt1.h	/^	mutable XsensResultValue m_lastResult;$/;"	m	class:xsens::Cmt1s
xsens::Cmt1s::m_onBytesReceived	cmt1.h	/^	CmtCallbackFunction m_onBytesReceived;$/;"	m	class:xsens::Cmt1s
xsens::Cmt1s::m_onBytesReceivedInstance	cmt1.h	/^	int32_t m_onBytesReceivedInstance;$/;"	m	class:xsens::Cmt1s
xsens::Cmt1s::m_onBytesReceivedParam	cmt1.h	/^	void* m_onBytesReceivedParam;$/;"	m	class:xsens::Cmt1s
xsens::Cmt1s::m_port	cmt1.h	/^	uint16_t m_port;$/;"	m	class:xsens::Cmt1s
xsens::Cmt1s::m_portname	cmt1.h	/^	char m_portname[32];$/;"	m	class:xsens::Cmt1s
xsens::Cmt1s::m_timeout	cmt1.h	/^	uint32_t m_timeout;$/;"	m	class:xsens::Cmt1s
xsens::Cmt1s::open	cmt1.cpp	/^XsensResultValue Cmt1s::open (	const uint32_t portNumber,$/;"	f	class:xsens::Cmt1s
xsens::Cmt1s::open	cmt1.cpp	/^XsensResultValue Cmt1s::open(  const char *portName,$/;"	f	class:xsens::Cmt1s
xsens::Cmt1s::readData	cmt1.cpp	/^XsensResultValue Cmt1s::readData (const uint32_t maxLength, uint8_t* data,$/;"	f	class:xsens::Cmt1s
xsens::Cmt1s::rx_log	cmt1.h	/^		FILE* rx_log;$/;"	m	class:xsens::Cmt1s
xsens::Cmt1s::setCallbackFunction	cmt1.cpp	/^XsensResultValue Cmt1s::setCallbackFunction(CmtCallbackType tp, int32_t instance, CmtCallbackFunction func, void* param)$/;"	f	class:xsens::Cmt1s
xsens::Cmt1s::setTimeout	cmt1.cpp	/^XsensResultValue Cmt1s::setTimeout (const uint32_t ms)$/;"	f	class:xsens::Cmt1s
xsens::Cmt1s::tx_log	cmt1.h	/^		FILE* tx_log;$/;"	m	class:xsens::Cmt1s
xsens::Cmt1s::waitForData	cmt1.cpp	/^XsensResultValue Cmt1s::waitForData (const uint32_t maxLength,$/;"	f	class:xsens::Cmt1s
xsens::Cmt1s::writeData	cmt1.cpp	/^XsensResultValue Cmt1s::writeData (const uint32_t length,  const uint8_t* data,$/;"	f	class:xsens::Cmt1s
xsens::Cmt1s::~Cmt1s	cmt1.cpp	/^Cmt1s::~Cmt1s()$/;"	f	class:xsens::Cmt1s
xsens::Cmt2f	cmt2.h	/^class Cmt2f {$/;"	c	namespace:xsens
xsens::Cmt2f::Cmt2f	cmt2.cpp	/^Cmt2f::Cmt2f()$/;"	f	class:xsens::Cmt2f
xsens::Cmt2f::close	cmt2.cpp	/^XsensResultValue Cmt2f::close(void)$/;"	f	class:xsens::Cmt2f
xsens::Cmt2f::closeAndDelete	cmt2.cpp	/^XsensResultValue Cmt2f::closeAndDelete(void)$/;"	f	class:xsens::Cmt2f
xsens::Cmt2f::create	cmt2.cpp	/^XsensResultValue Cmt2f::create(const char* filename)$/;"	f	class:xsens::Cmt2f
xsens::Cmt2f::create	cmt2.cpp	/^XsensResultValue Cmt2f::create(const wchar_t* filename)$/;"	f	class:xsens::Cmt2f
xsens::Cmt2f::getCmt1f	cmt2.cpp	/^Cmt1f* Cmt2f::getCmt1f(void)$/;"	f	class:xsens::Cmt2f
xsens::Cmt2f::getFileSize	cmt2.cpp	/^XsensFilePos Cmt2f::getFileSize(void)$/;"	f	class:xsens::Cmt2f
xsens::Cmt2f::getLastResult	cmt2.cpp	/^XsensResultValue Cmt2f::getLastResult(void) const$/;"	f	class:xsens::Cmt2f
xsens::Cmt2f::getName	cmt2.cpp	/^XsensResultValue Cmt2f::getName(char* filename) const$/;"	f	class:xsens::Cmt2f
xsens::Cmt2f::getName	cmt2.cpp	/^XsensResultValue Cmt2f::getName(wchar_t* filename) const$/;"	f	class:xsens::Cmt2f
xsens::Cmt2f::getReadPosition	cmt2.cpp	/^XsensFilePos Cmt2f::getReadPosition(void)$/;"	f	class:xsens::Cmt2f
xsens::Cmt2f::isOpen	cmt2.cpp	/^bool Cmt2f::isOpen(void) const$/;"	f	class:xsens::Cmt2f
xsens::Cmt2f::m_cmt1f	cmt2.h	/^	Cmt1f m_cmt1f;$/;"	m	class:xsens::Cmt2f
xsens::Cmt2f::m_lastResult	cmt2.h	/^	mutable XsensResultValue m_lastResult;$/;"	m	class:xsens::Cmt2f
xsens::Cmt2f::m_readOnly	cmt2.h	/^	bool m_readOnly;				\/\/!< When set to true, the file is read-only and attempts to write to it will fail$/;"	m	class:xsens::Cmt2f
xsens::Cmt2f::open	cmt2.cpp	/^XsensResultValue Cmt2f::open(const char* filename, const bool readOnly)$/;"	f	class:xsens::Cmt2f
xsens::Cmt2f::open	cmt2.cpp	/^XsensResultValue Cmt2f::open(const wchar_t* filename, const bool readOnly)$/;"	f	class:xsens::Cmt2f
xsens::Cmt2f::readMessage	cmt2.cpp	/^XsensResultValue Cmt2f::readMessage(Message* msg, const uint8_t msgId)$/;"	f	class:xsens::Cmt2f
xsens::Cmt2f::setReadPosition	cmt2.cpp	/^XsensResultValue Cmt2f::setReadPosition(XsensFilePos pos)$/;"	f	class:xsens::Cmt2f
xsens::Cmt2f::writeMessage	cmt2.cpp	/^XsensResultValue Cmt2f::writeMessage(const Message* msg)$/;"	f	class:xsens::Cmt2f
xsens::Cmt2f::~Cmt2f	cmt2.cpp	/^Cmt2f::~Cmt2f()$/;"	f	class:xsens::Cmt2f
xsens::Cmt2s	cmt2.h	/^class Cmt2s {$/;"	c	namespace:xsens
xsens::Cmt2s::Cmt2s	cmt2.cpp	/^Cmt2s::Cmt2s() :$/;"	f	class:xsens::Cmt2s
xsens::Cmt2s::close	cmt2.cpp	/^XsensResultValue Cmt2s::close(void)$/;"	f	class:xsens::Cmt2s
xsens::Cmt2s::getBaudrate	cmt2.h	/^	uint32_t getBaudrate(void) { return (m_baudrate = m_cmt1s.getBaudrate()); }$/;"	f	class:xsens::Cmt2s
xsens::Cmt2s::getCmt1s	cmt2.h	/^	Cmt1s* getCmt1s(void) { return &m_cmt1s; }$/;"	f	class:xsens::Cmt2s
xsens::Cmt2s::getLastResult	cmt2.h	/^	XsensResultValue getLastResult(void) const { return m_lastResult; }$/;"	f	class:xsens::Cmt2s
xsens::Cmt2s::getPortName	cmt2.cpp	/^XsensResultValue Cmt2s::getPortName(char *portname) const$/;"	f	class:xsens::Cmt2s
xsens::Cmt2s::getPortNr	cmt2.cpp	/^XsensResultValue Cmt2s::getPortNr(int32_t& port) const$/;"	f	class:xsens::Cmt2s
xsens::Cmt2s::getPortNr	cmt2.cpp	/^XsensResultValue Cmt2s::getPortNr(uint16_t& port) const$/;"	f	class:xsens::Cmt2s
xsens::Cmt2s::getTimeout	cmt2.h	/^	uint32_t getTimeout(void) const { return m_timeout; }$/;"	f	class:xsens::Cmt2s
xsens::Cmt2s::isOpen	cmt2.h	/^	bool isOpen (void) const { return (m_cmt1s.isOpen()); }$/;"	f	class:xsens::Cmt2s
xsens::Cmt2s::m_baudrate	cmt2.h	/^	uint32_t m_baudrate;$/;"	m	class:xsens::Cmt2s
xsens::Cmt2s::m_cmt1s	cmt2.h	/^	Cmt1s m_cmt1s;$/;"	m	class:xsens::Cmt2s
xsens::Cmt2s::m_lastResult	cmt2.h	/^	mutable XsensResultValue m_lastResult;$/;"	m	class:xsens::Cmt2s
xsens::Cmt2s::m_onMessageReceived	cmt2.h	/^	CmtCallbackFunction m_onMessageReceived;$/;"	m	class:xsens::Cmt2s
xsens::Cmt2s::m_onMessageReceivedInstance	cmt2.h	/^	int32_t m_onMessageReceivedInstance;$/;"	m	class:xsens::Cmt2s
xsens::Cmt2s::m_onMessageReceivedParam	cmt2.h	/^	void* m_onMessageReceivedParam;$/;"	m	class:xsens::Cmt2s
xsens::Cmt2s::m_onMessageSent	cmt2.h	/^	CmtCallbackFunction m_onMessageSent;$/;"	m	class:xsens::Cmt2s
xsens::Cmt2s::m_onMessageSentInstance	cmt2.h	/^	int32_t m_onMessageSentInstance;$/;"	m	class:xsens::Cmt2s
xsens::Cmt2s::m_onMessageSentParam	cmt2.h	/^	void* m_onMessageSentParam;$/;"	m	class:xsens::Cmt2s
xsens::Cmt2s::m_readBuffer	cmt2.h	/^	uint8_t m_readBuffer[CMT_DEFAULT_READ_BUFFER_SIZE];$/;"	m	class:xsens::Cmt2s
xsens::Cmt2s::m_readBufferCount	cmt2.h	/^	uint16_t m_readBufferCount;$/;"	m	class:xsens::Cmt2s
xsens::Cmt2s::m_timeout	cmt2.h	/^	uint32_t m_timeout;$/;"	m	class:xsens::Cmt2s
xsens::Cmt2s::m_toEnd	cmt2.h	/^	uint32_t m_toEnd;$/;"	m	class:xsens::Cmt2s
xsens::Cmt2s::open	cmt2.cpp	/^XsensResultValue Cmt2s::open (const char *portName, const uint32_t baudRate, uint32_t readBufSize, uint32_t writeBufSize)$/;"	f	class:xsens::Cmt2s
xsens::Cmt2s::open	cmt2.cpp	/^XsensResultValue Cmt2s::open (const uint32_t portNumber, const uint32_t baudRate, uint32_t readBufSize, uint32_t writeBufSize)$/;"	f	class:xsens::Cmt2s
xsens::Cmt2s::readMessage	cmt2.cpp	/^XsensResultValue Cmt2s::readMessage(Message* rcv)$/;"	f	class:xsens::Cmt2s
xsens::Cmt2s::setCallbackFunction	cmt2.cpp	/^XsensResultValue Cmt2s::setCallbackFunction(CmtCallbackType tp, int32_t instance, CmtCallbackFunction func, void* param)$/;"	f	class:xsens::Cmt2s
xsens::Cmt2s::setTimeout	cmt2.cpp	/^XsensResultValue Cmt2s::setTimeout (const uint32_t ms)$/;"	f	class:xsens::Cmt2s
xsens::Cmt2s::waitForMessage	cmt2.cpp	/^XsensResultValue Cmt2s::waitForMessage(Message* rcv, const uint8_t msgId, uint32_t timeoutOverride, bool acceptErrorMessage)$/;"	f	class:xsens::Cmt2s
xsens::Cmt2s::writeMessage	cmt2.cpp	/^XsensResultValue Cmt2s::writeMessage(Message* msg)$/;"	f	class:xsens::Cmt2s
xsens::Cmt2s::~Cmt2s	cmt2.cpp	/^Cmt2s::~Cmt2s()$/;"	f	class:xsens::Cmt2s
xsens::Cmt3	cmt3.h	/^class Cmt3 {$/;"	c	namespace:xsens
xsens::Cmt3::Cmt3	cmt3.cpp	/^Cmt3::Cmt3()$/;"	f	class:xsens::Cmt3
xsens::Cmt3::clearHwError	cmt3.h	/^	void clearHwError(void)									\/\/!< \\brief Reset the hardware error code. \\details Use this function to reset the hardware error code reported by getHwError. \\see getHwError$/;"	f	class:xsens::Cmt3
xsens::Cmt3::closeLogFile	cmt3.cpp	/^XsensResultValue Cmt3::closeLogFile(bool del)$/;"	f	class:xsens::Cmt3
xsens::Cmt3::closePort	cmt3.cpp	/^XsensResultValue Cmt3::closePort(bool gotoConfigFirst)$/;"	f	class:xsens::Cmt3
xsens::Cmt3::createLogFile	cmt3.cpp	/^XsensResultValue Cmt3::createLogFile(const char* filename, bool startLogging)$/;"	f	class:xsens::Cmt3
xsens::Cmt3::createLogFile	cmt3.cpp	/^XsensResultValue Cmt3::createLogFile(const wchar_t* filename, bool startLogging)$/;"	f	class:xsens::Cmt3
xsens::Cmt3::fillRtc	cmt3.cpp	/^void Cmt3::fillRtc(Packet* pack)$/;"	f	class:xsens::Cmt3
xsens::Cmt3::getAvailableScenarios	cmt3.cpp	/^XsensResultValue Cmt3::getAvailableScenarios(CmtScenario* scenarios, const CmtDeviceId deviceId)$/;"	f	class:xsens::Cmt3
xsens::Cmt3::getBatteryLevel	cmt3.cpp	/^XsensResultValue Cmt3::getBatteryLevel(uint8_t& level)$/;"	f	class:xsens::Cmt3
xsens::Cmt3::getBaudrate	cmt3.cpp	/^XsensResultValue Cmt3::getBaudrate(uint32_t& baudrate)$/;"	f	class:xsens::Cmt3
xsens::Cmt3::getBluetoothState	cmt3.cpp	/^XsensResultValue Cmt3::getBluetoothState(bool& enabled)$/;"	f	class:xsens::Cmt3
xsens::Cmt3::getBusId	cmt3.cpp	/^XsensResultValue Cmt3::getBusId (uint8_t& busId, const CmtDeviceId deviceId) const$/;"	f	class:xsens::Cmt3
xsens::Cmt3::getBusIdInternal	cmt3.cpp	/^uint8_t Cmt3::getBusIdInternal(const CmtDeviceId devId) const$/;"	f	class:xsens::Cmt3
xsens::Cmt3::getBusPowerState	cmt3.cpp	/^XsensResultValue Cmt3::getBusPowerState(bool& enabled)$/;"	f	class:xsens::Cmt3
xsens::Cmt3::getCmt2f	cmt3.cpp	/^Cmt2f* Cmt3::getCmt2f(void)$/;"	f	class:xsens::Cmt3
xsens::Cmt3::getCmt2s	cmt3.cpp	/^Cmt2s* Cmt3::getCmt2s(void)$/;"	f	class:xsens::Cmt3
xsens::Cmt3::getConfiguration	cmt3.cpp	/^XsensResultValue Cmt3::getConfiguration(CmtDeviceConfiguration& configuration)$/;"	f	class:xsens::Cmt3
xsens::Cmt3::getDataLength	cmt3.cpp	/^XsensResultValue Cmt3::getDataLength(uint32_t& length, const CmtDeviceId deviceId)$/;"	f	class:xsens::Cmt3
xsens::Cmt3::getDeviceCount	cmt3.cpp	/^uint32_t Cmt3::getDeviceCount (void) const$/;"	f	class:xsens::Cmt3
xsens::Cmt3::getDeviceId	cmt3.cpp	/^XsensResultValue Cmt3::getDeviceId(const uint8_t busId, CmtDeviceId& deviceId) const$/;"	f	class:xsens::Cmt3
xsens::Cmt3::getDeviceMode	cmt3.cpp	/^XsensResultValue Cmt3::getDeviceMode(CmtDeviceMode& mode, const CmtDeviceId deviceId)$/;"	f	class:xsens::Cmt3
xsens::Cmt3::getDeviceMode2	cmt3.cpp	/^XsensResultValue Cmt3::getDeviceMode2(CmtDeviceMode2& mode, const CmtDeviceId deviceId)$/;"	f	class:xsens::Cmt3
xsens::Cmt3::getEMtsData	cmt3.cpp	/^XsensResultValue Cmt3::getEMtsData(void* buffer, const CmtDeviceId deviceId)$/;"	f	class:xsens::Cmt3
xsens::Cmt3::getErrorMode	cmt3.cpp	/^XsensResultValue Cmt3::getErrorMode(uint16_t& mode, const CmtDeviceId deviceId)$/;"	f	class:xsens::Cmt3
xsens::Cmt3::getFirmwareRevision	cmt3.cpp	/^XsensResultValue Cmt3::getFirmwareRevision(CmtVersion& revision, const CmtDeviceId deviceId)$/;"	f	class:xsens::Cmt3
xsens::Cmt3::getGpsLeverArm	cmt3.cpp	/^XsensResultValue Cmt3::getGpsLeverArm(CmtVector& arm, const CmtDeviceId deviceId)$/;"	f	class:xsens::Cmt3
xsens::Cmt3::getGpsStatus	cmt3.cpp	/^XsensResultValue Cmt3::getGpsStatus(CmtGpsStatus& status, const CmtDeviceId deviceId)$/;"	f	class:xsens::Cmt3
xsens::Cmt3::getGravityMagnitude	cmt3.cpp	/^XsensResultValue Cmt3::getGravityMagnitude(double& magnitude, const CmtDeviceId deviceId)$/;"	f	class:xsens::Cmt3
xsens::Cmt3::getHeading	cmt3.cpp	/^XsensResultValue Cmt3::getHeading(double& heading, const CmtDeviceId deviceId)$/;"	f	class:xsens::Cmt3
xsens::Cmt3::getHwError	cmt3.h	/^	XsensResultValue getHwError(CmtDeviceId& did) const		\/\/!< \\brief Return the last Hardware error code. \\details This function returns the XsensResultValue of the last problem reported by hardware (if any). Hardware problems are all 'error' messages returned by a sensor. \\param did If any problems were found, the responsible device ID will be returned in this parameter. \\see clearHwError$/;"	f	class:xsens::Cmt3
xsens::Cmt3::getLastResult	cmt3.h	/^	XsensResultValue getLastResult(void) const				\/\/!< \\brief Return the error code of the last user function call.$/;"	f	class:xsens::Cmt3
xsens::Cmt3::getLatLonAlt	cmt3.cpp	/^XsensResultValue Cmt3::getLatLonAlt(CmtVector& lla, const CmtDeviceId deviceId)$/;"	f	class:xsens::Cmt3
xsens::Cmt3::getLocationId	cmt3.cpp	/^XsensResultValue Cmt3::getLocationId(uint16_t& locationId, const CmtDeviceId deviceId)$/;"	f	class:xsens::Cmt3
xsens::Cmt3::getLogFileName	cmt3.cpp	/^XsensResultValue Cmt3::getLogFileName(char* filename)$/;"	f	class:xsens::Cmt3
xsens::Cmt3::getLogFileName	cmt3.cpp	/^XsensResultValue Cmt3::getLogFileName(wchar_t* filename)$/;"	f	class:xsens::Cmt3
xsens::Cmt3::getLogFileReadPosition	cmt3.cpp	/^XsensResultValue Cmt3::getLogFileReadPosition(XsensFilePos& pos)$/;"	f	class:xsens::Cmt3
xsens::Cmt3::getLogFileSize	cmt3.cpp	/^XsensResultValue Cmt3::getLogFileSize(XsensFilePos& size)$/;"	f	class:xsens::Cmt3
xsens::Cmt3::getMagneticDeclination	cmt3.cpp	/^XsensResultValue Cmt3::getMagneticDeclination(double& declination, const CmtDeviceId deviceId)$/;"	f	class:xsens::Cmt3
xsens::Cmt3::getMasterId	cmt3.cpp	/^CmtDeviceId Cmt3::getMasterId(void)$/;"	f	class:xsens::Cmt3
xsens::Cmt3::getMtCount	cmt3.cpp	/^uint16_t Cmt3::getMtCount(void) const$/;"	f	class:xsens::Cmt3
xsens::Cmt3::getMtDeviceId	cmt3.cpp	/^XsensResultValue Cmt3::getMtDeviceId (const uint8_t index, CmtDeviceId& deviceId) const$/;"	f	class:xsens::Cmt3
xsens::Cmt3::getObjectAlignmentMatrix	cmt3.cpp	/^XsensResultValue Cmt3::getObjectAlignmentMatrix(CmtMatrix& matrix, const CmtDeviceId deviceId)$/;"	f	class:xsens::Cmt3
xsens::Cmt3::getPortNr	cmt3.cpp	/^XsensResultValue Cmt3::getPortNr(uint16_t& port) const$/;"	f	class:xsens::Cmt3
xsens::Cmt3::getProcessingFlags	cmt3.cpp	/^XsensResultValue Cmt3::getProcessingFlags(uint16_t& processingFlags, const CmtDeviceId deviceId)$/;"	f	class:xsens::Cmt3
xsens::Cmt3::getProductCode	cmt3.cpp	/^XsensResultValue Cmt3::getProductCode (char* productCode, const CmtDeviceId deviceId)$/;"	f	class:xsens::Cmt3
xsens::Cmt3::getSampleFrequency	cmt3.cpp	/^uint16_t Cmt3::getSampleFrequency(void)$/;"	f	class:xsens::Cmt3
xsens::Cmt3::getScenario	cmt3.cpp	/^XsensResultValue Cmt3::getScenario(uint8_t& scenarioType, uint8_t& scenarioVersion, const CmtDeviceId deviceId)$/;"	f	class:xsens::Cmt3
xsens::Cmt3::getSerialBaudrate	cmt3.cpp	/^XsensResultValue Cmt3::getSerialBaudrate(uint32_t& baudrate)$/;"	f	class:xsens::Cmt3
xsens::Cmt3::getSyncInMode	cmt3.cpp	/^XsensResultValue Cmt3::getSyncInMode(uint16_t& mode)$/;"	f	class:xsens::Cmt3
xsens::Cmt3::getSyncInOffset	cmt3.cpp	/^XsensResultValue Cmt3::getSyncInOffset(uint32_t& offset)$/;"	f	class:xsens::Cmt3
xsens::Cmt3::getSyncInSettings	cmt3.cpp	/^XsensResultValue Cmt3::getSyncInSettings(CmtSyncInSettings& settings)$/;"	f	class:xsens::Cmt3
xsens::Cmt3::getSyncInSkipFactor	cmt3.cpp	/^XsensResultValue Cmt3::getSyncInSkipFactor(uint16_t& skipFactor)$/;"	f	class:xsens::Cmt3
xsens::Cmt3::getSyncMode	cmt3.cpp	/^XsensResultValue Cmt3::getSyncMode(uint8_t& mode)$/;"	f	class:xsens::Cmt3
xsens::Cmt3::getSyncOutMode	cmt3.cpp	/^XsensResultValue Cmt3::getSyncOutMode(uint16_t& mode)$/;"	f	class:xsens::Cmt3
xsens::Cmt3::getSyncOutOffset	cmt3.cpp	/^XsensResultValue Cmt3::getSyncOutOffset(uint32_t& offset)$/;"	f	class:xsens::Cmt3
xsens::Cmt3::getSyncOutPulseWidth	cmt3.cpp	/^XsensResultValue Cmt3::getSyncOutPulseWidth(uint32_t& pulseWidth)$/;"	f	class:xsens::Cmt3
xsens::Cmt3::getSyncOutSettings	cmt3.cpp	/^XsensResultValue Cmt3::getSyncOutSettings(CmtSyncOutSettings& settings)$/;"	f	class:xsens::Cmt3
xsens::Cmt3::getSyncOutSkipFactor	cmt3.cpp	/^XsensResultValue Cmt3::getSyncOutSkipFactor(uint16_t& skipFactor)$/;"	f	class:xsens::Cmt3
xsens::Cmt3::getTimeoutConfig	cmt3.cpp	/^uint32_t Cmt3::getTimeoutConfig (void) const$/;"	f	class:xsens::Cmt3
xsens::Cmt3::getTimeoutMeasurement	cmt3.cpp	/^uint32_t Cmt3::getTimeoutMeasurement (void) const$/;"	f	class:xsens::Cmt3
xsens::Cmt3::getTransmissionDelay	cmt3.cpp	/^XsensResultValue Cmt3::getTransmissionDelay(uint16_t& delay, const CmtDeviceId deviceId)$/;"	f	class:xsens::Cmt3
xsens::Cmt3::getUtcTime	cmt3.cpp	/^XsensResultValue Cmt3::getUtcTime(CmtUtcTime& utc, const CmtDeviceId deviceId)$/;"	f	class:xsens::Cmt3
xsens::Cmt3::getXmOutputMode	cmt3.cpp	/^XsensResultValue Cmt3::getXmOutputMode(uint8_t& mode)$/;"	f	class:xsens::Cmt3
xsens::Cmt3::gotoConfig	cmt3.cpp	/^XsensResultValue Cmt3::gotoConfig(void)$/;"	f	class:xsens::Cmt3
xsens::Cmt3::gotoMeasurement	cmt3.cpp	/^XsensResultValue Cmt3::gotoMeasurement(void)$/;"	f	class:xsens::Cmt3
xsens::Cmt3::initBus	cmt3.cpp	/^XsensResultValue Cmt3::initBus(void)$/;"	f	class:xsens::Cmt3
xsens::Cmt3::isLogFileOpen	cmt3.cpp	/^bool Cmt3::isLogFileOpen(const char* filename) const$/;"	f	class:xsens::Cmt3
xsens::Cmt3::isLogFileOpen	cmt3.cpp	/^bool Cmt3::isLogFileOpen(const wchar_t* filename) const$/;"	f	class:xsens::Cmt3
xsens::Cmt3::isLogging	cmt3.h	/^	bool isLogging(void) const			\/\/!< \\brief Return whether the Cmt3 object is writing to a log file or not$/;"	f	class:xsens::Cmt3
xsens::Cmt3::isPortOpen	cmt3.h	/^	bool isPortOpen(void) const			\/\/!< \\brief Return whether the communication port is open or not.$/;"	f	class:xsens::Cmt3
xsens::Cmt3::isReadingFromFile	cmt3.h	/^	bool isReadingFromFile(void) const	\/\/!< \\brief Return whether the Cmt3 object is reading from a log file or not$/;"	f	class:xsens::Cmt3
xsens::Cmt3::isXm	cmt3.cpp	/^bool Cmt3::isXm(void) const$/;"	f	class:xsens::Cmt3
xsens::Cmt3::m_baudrate	cmt3.h	/^	uint32_t m_baudrate;		\/\/!< The baudrate that was last set to be used by the port.$/;"	m	class:xsens::Cmt3
xsens::Cmt3::m_config	cmt3.h	/^	CmtDeviceConfiguration m_config;				\/\/!< Cached configuration data.$/;"	m	class:xsens::Cmt3
xsens::Cmt3::m_detailedScan	cmt3.h	/^	bool m_detailedScan;			\/\/!< Automatically scan for device details during open. Default is true (recommended).$/;"	m	class:xsens::Cmt3
xsens::Cmt3::m_eMtsData	cmt3.h	/^	void* m_eMtsData[CMT_MAX_DEVICES_PER_PORT];		\/\/!< Cached eMTS data.$/;"	m	class:xsens::Cmt3
xsens::Cmt3::m_firstItem	cmt3.h	/^	uint16_t m_firstItem;				\/\/!< The index of the first formatting item.$/;"	m	class:xsens::Cmt3
xsens::Cmt3::m_gotoConfigTries	cmt3.h	/^	uint16_t m_gotoConfigTries;		\/\/!< The number of times a goto config is attempted before the function fails.$/;"	m	class:xsens::Cmt3
xsens::Cmt3::m_lastHwError	cmt3.h	/^	XsensResultValue m_lastHwError;			\/\/!< Contains the last error reported by hardware.$/;"	m	class:xsens::Cmt3
xsens::Cmt3::m_lastHwErrorDeviceId	cmt3.h	/^	CmtDeviceId m_lastHwErrorDeviceId;		\/\/!< Contains the Device ID of the device that caused the last hardware error.$/;"	m	class:xsens::Cmt3
xsens::Cmt3::m_lastResult	cmt3.h	/^	mutable XsensResultValue m_lastResult;	\/\/!< The last result of an operation.$/;"	m	class:xsens::Cmt3
xsens::Cmt3::m_logFile	cmt3.h	/^	Cmt2f m_logFile;				\/\/!< The (optional) CMT level 2 logfile object that this class operates on. $/;"	m	class:xsens::Cmt3
xsens::Cmt3::m_logging	cmt3.h	/^	bool m_logging;							\/\/!< Indicates whether to write all received messages to the logfile or not, automatically set to true by createLogFile.$/;"	m	class:xsens::Cmt3
xsens::Cmt3::m_measuring	cmt3.h	/^	bool m_measuring;						\/\/!< Keeps track of whether the connected device is measuring or being configured.$/;"	m	class:xsens::Cmt3
xsens::Cmt3::m_period	cmt3.h	/^	uint16_t m_period;				\/\/!< The sample period of the port.$/;"	m	class:xsens::Cmt3
xsens::Cmt3::m_readBufSize	cmt3.h	/^	uint32_t m_readBufSize;					\/\/!< Contains the size of the serial read buffer$/;"	m	class:xsens::Cmt3
xsens::Cmt3::m_readFromFile	cmt3.h	/^	bool m_readFromFile;			\/\/!< Indicates whether to read from the log file or from the serial port.$/;"	m	class:xsens::Cmt3
xsens::Cmt3::m_rtcCount	cmt3.h	/^	uint32_t m_rtcCount;			\/\/!< The long sample counter (normal counter wraps at 64k).$/;"	m	class:xsens::Cmt3
xsens::Cmt3::m_rtcInitialized	cmt3.h	/^	bool m_rtcInitialized;			\/\/!< Indicates whether the RTC synchronization isinitialized$/;"	m	class:xsens::Cmt3
xsens::Cmt3::m_rtcLastSc	cmt3.h	/^	CmtMtTimeStamp m_rtcLastSc;		\/\/!< The last received sample counter, used to determine wrap-around.$/;"	m	class:xsens::Cmt3
xsens::Cmt3::m_rtcSync	cmt3.h	/^	xsens::TimeSync m_rtcSync;		\/\/!< Used for synchronizing MT timestamps to system timestamps$/;"	m	class:xsens::Cmt3
xsens::Cmt3::m_serial	cmt3.h	/^	Cmt2s m_serial;					\/\/!< The (optional) CMT level 2 serial object that this class operates on.$/;"	m	class:xsens::Cmt3
xsens::Cmt3::m_skip	cmt3.h	/^	uint16_t m_skip;				\/\/!< The skip factor of the port.$/;"	m	class:xsens::Cmt3
xsens::Cmt3::m_timeoutConf	cmt3.h	/^	uint32_t m_timeoutConf;	\/\/!< The config mode timeout.$/;"	m	class:xsens::Cmt3
xsens::Cmt3::m_timeoutMeas	cmt3.h	/^	uint32_t m_timeoutMeas;			\/\/!< The measurement mode timeout.$/;"	m	class:xsens::Cmt3
xsens::Cmt3::m_useRtc	cmt3.h	/^	bool m_useRtc;					\/\/!< Indicates if the RTC should be computed or not (to save CPU time).$/;"	m	class:xsens::Cmt3
xsens::Cmt3::m_writeBufSize	cmt3.h	/^	uint32_t m_writeBufSize;				\/\/!< Contains the size of the serial write buffer$/;"	m	class:xsens::Cmt3
xsens::Cmt3::openLogFile	cmt3.cpp	/^XsensResultValue Cmt3::openLogFile(const char* filename)$/;"	f	class:xsens::Cmt3
xsens::Cmt3::openLogFile	cmt3.cpp	/^XsensResultValue Cmt3::openLogFile(const wchar_t* filename)$/;"	f	class:xsens::Cmt3
xsens::Cmt3::openPort	cmt3.cpp	/^XsensResultValue Cmt3::openPort(const char *portName, const uint32_t baudRate, uint32_t readBufSize, uint32_t writeBufSize)$/;"	f	class:xsens::Cmt3
xsens::Cmt3::openPort	cmt3.cpp	/^XsensResultValue Cmt3::openPort(const uint32_t portNumber, const uint32_t baudRate, uint32_t readBufSize, uint32_t writeBufSize)$/;"	f	class:xsens::Cmt3
xsens::Cmt3::peekLogMessageId	cmt3.cpp	/^XsensResultValue Cmt3::peekLogMessageId(uint8_t& messageId)$/;"	f	class:xsens::Cmt3
xsens::Cmt3::readDataPacket	cmt3.cpp	/^XsensResultValue Cmt3::readDataPacket(Packet* pack, bool acceptOther)$/;"	f	class:xsens::Cmt3
xsens::Cmt3::refreshCache	cmt3.cpp	/^XsensResultValue Cmt3::refreshCache(const bool file)$/;"	f	class:xsens::Cmt3
xsens::Cmt3::requestData	cmt3.cpp	/^XsensResultValue Cmt3::requestData(Packet* pack, const uint8_t *data, const uint16_t count)$/;"	f	class:xsens::Cmt3
xsens::Cmt3::reset	cmt3.cpp	/^XsensResultValue Cmt3::reset(void)$/;"	f	class:xsens::Cmt3
xsens::Cmt3::resetLogFileReadPos	cmt3.cpp	/^XsensResultValue Cmt3::resetLogFileReadPos(void)$/;"	f	class:xsens::Cmt3
xsens::Cmt3::resetOrientation	cmt3.cpp	/^XsensResultValue Cmt3::resetOrientation(const CmtResetMethod method, const CmtDeviceId deviceId)$/;"	f	class:xsens::Cmt3
xsens::Cmt3::restoreFactoryDefaults	cmt3.cpp	/^XsensResultValue Cmt3::restoreFactoryDefaults(const CmtDeviceId deviceId)$/;"	f	class:xsens::Cmt3
xsens::Cmt3::runSelfTest	cmt3.cpp	/^XsensResultValue Cmt3::runSelfTest(uint16_t &result, const CmtDeviceId deviceId)$/;"	f	class:xsens::Cmt3
xsens::Cmt3::setBaudrate	cmt3.cpp	/^XsensResultValue Cmt3::setBaudrate(const uint32_t baudrate, bool reconnect)$/;"	f	class:xsens::Cmt3
xsens::Cmt3::setBluetoothState	cmt3.cpp	/^XsensResultValue Cmt3::setBluetoothState(const bool enabled)$/;"	f	class:xsens::Cmt3
xsens::Cmt3::setBusPowerState	cmt3.cpp	/^XsensResultValue Cmt3::setBusPowerState(const bool enabled)$/;"	f	class:xsens::Cmt3
xsens::Cmt3::setDataSource	cmt3.cpp	/^XsensResultValue Cmt3::setDataSource(bool readFromFile)$/;"	f	class:xsens::Cmt3
xsens::Cmt3::setDeviceMode	cmt3.cpp	/^XsensResultValue Cmt3::setDeviceMode (const CmtDeviceMode& mode, bool force, const CmtDeviceId deviceId)$/;"	f	class:xsens::Cmt3
xsens::Cmt3::setDeviceMode2	cmt3.cpp	/^XsensResultValue Cmt3::setDeviceMode2 (const CmtDeviceMode2& mode, bool force, const CmtDeviceId deviceId)$/;"	f	class:xsens::Cmt3
xsens::Cmt3::setErrorMode	cmt3.cpp	/^XsensResultValue Cmt3::setErrorMode(const uint16_t mode)$/;"	f	class:xsens::Cmt3
xsens::Cmt3::setGotoConfigTries	cmt3.cpp	/^XsensResultValue Cmt3::setGotoConfigTries(const uint16_t tries)$/;"	f	class:xsens::Cmt3
xsens::Cmt3::setGpsLeverArm	cmt3.cpp	/^XsensResultValue Cmt3::setGpsLeverArm(const CmtVector& arm, const CmtDeviceId deviceId)$/;"	f	class:xsens::Cmt3
xsens::Cmt3::setGravityMagnitude	cmt3.cpp	/^XsensResultValue Cmt3::setGravityMagnitude(const double magnitude, const CmtDeviceId deviceId)$/;"	f	class:xsens::Cmt3
xsens::Cmt3::setHeading	cmt3.cpp	/^XsensResultValue Cmt3::setHeading (const double heading, const CmtDeviceId deviceId)$/;"	f	class:xsens::Cmt3
xsens::Cmt3::setLatLonAlt	cmt3.cpp	/^XsensResultValue Cmt3::setLatLonAlt(const CmtVector& lla, const CmtDeviceId deviceId)$/;"	f	class:xsens::Cmt3
xsens::Cmt3::setLocationId	cmt3.cpp	/^XsensResultValue Cmt3::setLocationId (uint16_t locationId, const CmtDeviceId deviceId)$/;"	f	class:xsens::Cmt3
xsens::Cmt3::setLogMode	cmt3.cpp	/^XsensResultValue Cmt3::setLogMode(bool active)$/;"	f	class:xsens::Cmt3
xsens::Cmt3::setMagneticDeclination	cmt3.cpp	/^XsensResultValue Cmt3::setMagneticDeclination(const double declination, const CmtDeviceId deviceId)$/;"	f	class:xsens::Cmt3
xsens::Cmt3::setNoRotation	cmt3.cpp	/^XsensResultValue Cmt3::setNoRotation(const uint16_t duration, const CmtDeviceId deviceId)$/;"	f	class:xsens::Cmt3
xsens::Cmt3::setObjectAlignmentMatrix	cmt3.cpp	/^XsensResultValue Cmt3::setObjectAlignmentMatrix(const CmtMatrix& matrix, const CmtDeviceId deviceId)$/;"	f	class:xsens::Cmt3
xsens::Cmt3::setProcessingFlags	cmt3.cpp	/^XsensResultValue Cmt3::setProcessingFlags (uint16_t processingFlags, const CmtDeviceId deviceId)$/;"	f	class:xsens::Cmt3
xsens::Cmt3::setScenario	cmt3.cpp	/^XsensResultValue Cmt3::setScenario(const uint8_t scenarioType, const CmtDeviceId deviceId)$/;"	f	class:xsens::Cmt3
xsens::Cmt3::setSyncInMode	cmt3.cpp	/^XsensResultValue Cmt3::setSyncInMode (const uint16_t mode)$/;"	f	class:xsens::Cmt3
xsens::Cmt3::setSyncInOffset	cmt3.cpp	/^XsensResultValue Cmt3::setSyncInOffset (const uint32_t offset)$/;"	f	class:xsens::Cmt3
xsens::Cmt3::setSyncInSettings	cmt3.cpp	/^XsensResultValue Cmt3::setSyncInSettings (const CmtSyncInSettings& settings)$/;"	f	class:xsens::Cmt3
xsens::Cmt3::setSyncInSkipFactor	cmt3.cpp	/^XsensResultValue Cmt3::setSyncInSkipFactor (const uint16_t skipFactor)$/;"	f	class:xsens::Cmt3
xsens::Cmt3::setSyncMode	cmt3.cpp	/^XsensResultValue Cmt3::setSyncMode(const uint8_t mode)$/;"	f	class:xsens::Cmt3
xsens::Cmt3::setSyncOutMode	cmt3.cpp	/^XsensResultValue Cmt3::setSyncOutMode (const uint16_t mode)$/;"	f	class:xsens::Cmt3
xsens::Cmt3::setSyncOutOffset	cmt3.cpp	/^XsensResultValue Cmt3::setSyncOutOffset(const uint32_t offset)$/;"	f	class:xsens::Cmt3
xsens::Cmt3::setSyncOutPulseWidth	cmt3.cpp	/^XsensResultValue Cmt3::setSyncOutPulseWidth(const uint32_t pulseWidth)$/;"	f	class:xsens::Cmt3
xsens::Cmt3::setSyncOutSettings	cmt3.cpp	/^XsensResultValue Cmt3::setSyncOutSettings (const CmtSyncOutSettings& settings)$/;"	f	class:xsens::Cmt3
xsens::Cmt3::setSyncOutSkipFactor	cmt3.cpp	/^XsensResultValue Cmt3::setSyncOutSkipFactor(const uint16_t skipFactor)$/;"	f	class:xsens::Cmt3
xsens::Cmt3::setTimeout	cmt3.h	/^	XsensResultValue setTimeout (const uint32_t ms)						\/\/!< \\brief Set the default timeout value to use in blocking operations on the communication port.$/;"	f	class:xsens::Cmt3
xsens::Cmt3::setTimeoutConfig	cmt3.cpp	/^XsensResultValue Cmt3::setTimeoutConfig(const uint32_t timeout)$/;"	f	class:xsens::Cmt3
xsens::Cmt3::setTimeoutMeasurement	cmt3.cpp	/^XsensResultValue Cmt3::setTimeoutMeasurement(const uint32_t timeout)$/;"	f	class:xsens::Cmt3
xsens::Cmt3::setTransmissionDelay	cmt3.cpp	/^XsensResultValue Cmt3::setTransmissionDelay(const uint16_t delay)$/;"	f	class:xsens::Cmt3
xsens::Cmt3::setXmOutputMode	cmt3.cpp	/^XsensResultValue Cmt3::setXmOutputMode(const uint8_t mode)$/;"	f	class:xsens::Cmt3
xsens::Cmt3::setXmPowerOff	cmt3.cpp	/^XsensResultValue Cmt3::setXmPowerOff(void)$/;"	f	class:xsens::Cmt3
xsens::Cmt3::storeXkfState	cmt3.cpp	/^XsensResultValue Cmt3::storeXkfState(const CmtDeviceId deviceId)$/;"	f	class:xsens::Cmt3
xsens::Cmt3::waitForDataMessage	cmt3.cpp	/^XsensResultValue Cmt3::waitForDataMessage(Packet* pack)$/;"	f	class:xsens::Cmt3
xsens::Cmt3::writeMessageToLogFile	cmt3.cpp	/^XsensResultValue Cmt3::writeMessageToLogFile(const Message& msg)$/;"	f	class:xsens::Cmt3
xsens::Cmt3::~Cmt3	cmt3.cpp	/^Cmt3::~Cmt3()$/;"	f	class:xsens::Cmt3
xsens::Exception	xsens_exception.h	/^class Exception : public std::exception$/;"	c	namespace:xsens
xsens::Exception::Exception	xsens_exception.cpp	/^Exception::Exception() :$/;"	f	class:xsens::Exception
xsens::Exception::Exception	xsens_exception.cpp	/^Exception::Exception(const Exception &ex) :$/;"	f	class:xsens::Exception
xsens::Exception::Exception	xsens_exception.cpp	/^Exception::Exception(const std::string &what) :$/;"	f	class:xsens::Exception
xsens::Exception::m_what	xsens_exception.h	/^	std::string m_what;$/;"	m	class:xsens::Exception
xsens::Exception::what	xsens_exception.cpp	/^const char *Exception::what() const throw()$/;"	f	class:xsens::Exception
xsens::Exception::~Exception	xsens_exception.cpp	/^Exception::~Exception() throw()$/;"	f	class:xsens::Exception
xsens::FifoQueue	xsens_fifoqueue.h	/^class FifoQueue {$/;"	c	namespace:xsens
xsens::FifoQueue::FifoQueue	xsens_fifoqueue.h	/^	FifoQueue(const FifoQueue<T,E2>& q)$/;"	f	class:xsens::FifoQueue
xsens::FifoQueue::FifoQueue	xsens_fifoqueue.h	/^	FifoQueue(size_type size=16, bool delOnOverwrite = true)$/;"	f	class:xsens::FifoQueue
xsens::FifoQueue::back	xsens_fifoqueue.h	/^	const value_type& back() const$/;"	f	class:xsens::FifoQueue
xsens::FifoQueue::back	xsens_fifoqueue.h	/^	value_type& back()$/;"	f	class:xsens::FifoQueue
xsens::FifoQueue::clear	xsens_fifoqueue.h	/^	void clear(void)$/;"	f	class:xsens::FifoQueue
xsens::FifoQueue::empty	xsens_fifoqueue.h	/^	bool empty() const$/;"	f	class:xsens::FifoQueue
xsens::FifoQueue::eraseAndClear	xsens_fifoqueue.h	/^	void eraseAndClear(void)$/;"	f	class:xsens::FifoQueue
xsens::FifoQueue::front	xsens_fifoqueue.h	/^	const value_type& front() const$/;"	f	class:xsens::FifoQueue
xsens::FifoQueue::front	xsens_fifoqueue.h	/^	value_type& front()$/;"	f	class:xsens::FifoQueue
xsens::FifoQueue::length	xsens_fifoqueue.h	/^	size_type length() const$/;"	f	class:xsens::FifoQueue
xsens::FifoQueue::m_currentCount	xsens_fifoqueue.h	/^	size_t m_currentCount;$/;"	m	class:xsens::FifoQueue
xsens::FifoQueue::m_deleteOnOverwrite	xsens_fifoqueue.h	/^	bool m_deleteOnOverwrite;$/;"	m	class:xsens::FifoQueue
xsens::FifoQueue::m_first	xsens_fifoqueue.h	/^	size_t m_first;$/;"	m	class:xsens::FifoQueue
xsens::FifoQueue::m_list	xsens_fifoqueue.h	/^	T*	m_list;$/;"	m	class:xsens::FifoQueue
xsens::FifoQueue::m_maxCount	xsens_fifoqueue.h	/^	size_t m_maxCount;$/;"	m	class:xsens::FifoQueue
xsens::FifoQueue::operator =	xsens_fifoqueue.h	/^	FifoQueue<T,E>& operator=(const FifoQueue<T,E2>& q)$/;"	f	class:xsens::FifoQueue
xsens::FifoQueue::operator []	xsens_fifoqueue.h	/^	const value_type& operator[] (size_t index) const$/;"	f	class:xsens::FifoQueue
xsens::FifoQueue::operator []	xsens_fifoqueue.h	/^	value_type& operator[] (size_t index)$/;"	f	class:xsens::FifoQueue
xsens::FifoQueue::pop	xsens_fifoqueue.h	/^	void pop(void)$/;"	f	class:xsens::FifoQueue
xsens::FifoQueue::popBack	xsens_fifoqueue.h	/^	void popBack(void)$/;"	f	class:xsens::FifoQueue
xsens::FifoQueue::push	xsens_fifoqueue.h	/^	void push(const value_type& x)$/;"	f	class:xsens::FifoQueue
xsens::FifoQueue::remove	xsens_fifoqueue.h	/^	void remove(size_t index)$/;"	f	class:xsens::FifoQueue
xsens::FifoQueue::resize	xsens_fifoqueue.h	/^	void resize(const size_t size)$/;"	f	class:xsens::FifoQueue
xsens::FifoQueue::size	xsens_fifoqueue.h	/^	size_type size() const$/;"	f	class:xsens::FifoQueue
xsens::FifoQueue::size_type	xsens_fifoqueue.h	/^	typedef size_t	size_type;		\/\/!< The type of a 'size' value.$/;"	t	class:xsens::FifoQueue
xsens::FifoQueue::value_type	xsens_fifoqueue.h	/^	typedef T		value_type;		\/\/!< The type of the value stored in this queue.$/;"	t	class:xsens::FifoQueue
xsens::FifoQueue::~FifoQueue	xsens_fifoqueue.h	/^	~FifoQueue()$/;"	f	class:xsens::FifoQueue
xsens::FifoQueueBasic	xsens_fifoqueue.h	/^class FifoQueueBasic {$/;"	c	namespace:xsens
xsens::FifoQueueBasic::FifoQueueBasic	xsens_fifoqueue.h	/^	FifoQueueBasic(const FifoQueueBasic<T>& q)$/;"	f	class:xsens::FifoQueueBasic
xsens::FifoQueueBasic::FifoQueueBasic	xsens_fifoqueue.h	/^	FifoQueueBasic(size_type size=16)$/;"	f	class:xsens::FifoQueueBasic
xsens::FifoQueueBasic::back	xsens_fifoqueue.h	/^	const value_type& back() const$/;"	f	class:xsens::FifoQueueBasic
xsens::FifoQueueBasic::back	xsens_fifoqueue.h	/^	value_type& back()$/;"	f	class:xsens::FifoQueueBasic
xsens::FifoQueueBasic::clear	xsens_fifoqueue.h	/^	void clear(void)$/;"	f	class:xsens::FifoQueueBasic
xsens::FifoQueueBasic::empty	xsens_fifoqueue.h	/^	bool empty() const$/;"	f	class:xsens::FifoQueueBasic
xsens::FifoQueueBasic::eraseAndClear	xsens_fifoqueue.h	/^	void eraseAndClear(void)$/;"	f	class:xsens::FifoQueueBasic
xsens::FifoQueueBasic::front	xsens_fifoqueue.h	/^	const value_type& front() const$/;"	f	class:xsens::FifoQueueBasic
xsens::FifoQueueBasic::front	xsens_fifoqueue.h	/^	value_type& front()$/;"	f	class:xsens::FifoQueueBasic
xsens::FifoQueueBasic::length	xsens_fifoqueue.h	/^	size_type length() const$/;"	f	class:xsens::FifoQueueBasic
xsens::FifoQueueBasic::m_currentCount	xsens_fifoqueue.h	/^	size_t m_currentCount;$/;"	m	class:xsens::FifoQueueBasic
xsens::FifoQueueBasic::m_first	xsens_fifoqueue.h	/^	size_t m_first;$/;"	m	class:xsens::FifoQueueBasic
xsens::FifoQueueBasic::m_list	xsens_fifoqueue.h	/^	T*	m_list;$/;"	m	class:xsens::FifoQueueBasic
xsens::FifoQueueBasic::m_maxCount	xsens_fifoqueue.h	/^	size_t m_maxCount;$/;"	m	class:xsens::FifoQueueBasic
xsens::FifoQueueBasic::operator =	xsens_fifoqueue.h	/^	FifoQueueBasic<T>& operator=(const FifoQueueBasic<T>& q)$/;"	f	class:xsens::FifoQueueBasic
xsens::FifoQueueBasic::operator []	xsens_fifoqueue.h	/^	const value_type& operator[] (size_t index) const$/;"	f	class:xsens::FifoQueueBasic
xsens::FifoQueueBasic::operator []	xsens_fifoqueue.h	/^	value_type& operator[] (size_t index)$/;"	f	class:xsens::FifoQueueBasic
xsens::FifoQueueBasic::pop	xsens_fifoqueue.h	/^	void pop(void)$/;"	f	class:xsens::FifoQueueBasic
xsens::FifoQueueBasic::popBack	xsens_fifoqueue.h	/^	void popBack(void)$/;"	f	class:xsens::FifoQueueBasic
xsens::FifoQueueBasic::push	xsens_fifoqueue.h	/^	void push(const value_type& x)$/;"	f	class:xsens::FifoQueueBasic
xsens::FifoQueueBasic::push_front	xsens_fifoqueue.h	/^	void push_front(const value_type& x)$/;"	f	class:xsens::FifoQueueBasic
xsens::FifoQueueBasic::remove	xsens_fifoqueue.h	/^	void remove(size_t index)$/;"	f	class:xsens::FifoQueueBasic
xsens::FifoQueueBasic::resize	xsens_fifoqueue.h	/^	void resize(const size_t size)$/;"	f	class:xsens::FifoQueueBasic
xsens::FifoQueueBasic::size	xsens_fifoqueue.h	/^	size_type size() const$/;"	f	class:xsens::FifoQueueBasic
xsens::FifoQueueBasic::size_type	xsens_fifoqueue.h	/^	typedef size_t	size_type;		\/\/!< The type of a 'size' value.$/;"	t	class:xsens::FifoQueueBasic
xsens::FifoQueueBasic::value_type	xsens_fifoqueue.h	/^	typedef T		value_type;		\/\/!< The type of the value stored in this queue.$/;"	t	class:xsens::FifoQueueBasic
xsens::FifoQueueBasic::~FifoQueueBasic	xsens_fifoqueue.h	/^	~FifoQueueBasic()$/;"	f	class:xsens::FifoQueueBasic
xsens::HANDLE	cmt1.h	/^typedef int32_t HANDLE;$/;"	t	namespace:xsens
xsens::Itypes	cmtmessage.cpp	/^union Itypes {$/;"	u	namespace:xsens	file:
xsens::Itypes::__anon1::i0	cmtmessage.cpp	/^		int32_t i1,i0;$/;"	m	struct:xsens::Itypes::__anon1	file:
xsens::Itypes::__anon1::i1	cmtmessage.cpp	/^		int32_t i1,i0;$/;"	m	struct:xsens::Itypes::__anon1	file:
xsens::Itypes::__anon2::s0	cmtmessage.cpp	/^		int16_t s3,s2,s1,s0;$/;"	m	struct:xsens::Itypes::__anon2	file:
xsens::Itypes::__anon2::s1	cmtmessage.cpp	/^		int16_t s3,s2,s1,s0;$/;"	m	struct:xsens::Itypes::__anon2	file:
xsens::Itypes::__anon2::s2	cmtmessage.cpp	/^		int16_t s3,s2,s1,s0;$/;"	m	struct:xsens::Itypes::__anon2	file:
xsens::Itypes::__anon2::s3	cmtmessage.cpp	/^		int16_t s3,s2,s1,s0;$/;"	m	struct:xsens::Itypes::__anon2	file:
xsens::Itypes::__anon3::b0	cmtmessage.cpp	/^		signed char b7,b6,b5,b4,b3,b2,b1,b0;$/;"	m	struct:xsens::Itypes::__anon3	file:
xsens::Itypes::__anon3::b1	cmtmessage.cpp	/^		signed char b7,b6,b5,b4,b3,b2,b1,b0;$/;"	m	struct:xsens::Itypes::__anon3	file:
xsens::Itypes::__anon3::b2	cmtmessage.cpp	/^		signed char b7,b6,b5,b4,b3,b2,b1,b0;$/;"	m	struct:xsens::Itypes::__anon3	file:
xsens::Itypes::__anon3::b3	cmtmessage.cpp	/^		signed char b7,b6,b5,b4,b3,b2,b1,b0;$/;"	m	struct:xsens::Itypes::__anon3	file:
xsens::Itypes::__anon3::b4	cmtmessage.cpp	/^		signed char b7,b6,b5,b4,b3,b2,b1,b0;$/;"	m	struct:xsens::Itypes::__anon3	file:
xsens::Itypes::__anon3::b5	cmtmessage.cpp	/^		signed char b7,b6,b5,b4,b3,b2,b1,b0;$/;"	m	struct:xsens::Itypes::__anon3	file:
xsens::Itypes::__anon3::b6	cmtmessage.cpp	/^		signed char b7,b6,b5,b4,b3,b2,b1,b0;$/;"	m	struct:xsens::Itypes::__anon3	file:
xsens::Itypes::__anon3::b7	cmtmessage.cpp	/^		signed char b7,b6,b5,b4,b3,b2,b1,b0;$/;"	m	struct:xsens::Itypes::__anon3	file:
xsens::Itypes::__anon4::f0	cmtmessage.cpp	/^		float f1,f0;$/;"	m	struct:xsens::Itypes::__anon4	file:
xsens::Itypes::__anon4::f1	cmtmessage.cpp	/^		float f1,f0;$/;"	m	struct:xsens::Itypes::__anon4	file:
xsens::Itypes::d	cmtmessage.cpp	/^	double d;$/;"	m	union:xsens::Itypes	file:
xsens::Itypes::f32	cmtmessage.cpp	/^	} f32;$/;"	m	union:xsens::Itypes	typeref:struct:xsens::Itypes::__anon4	file:
xsens::Itypes::i16	cmtmessage.cpp	/^	} i16;$/;"	m	union:xsens::Itypes	typeref:struct:xsens::Itypes::__anon2	file:
xsens::Itypes::i32	cmtmessage.cpp	/^	} i32;$/;"	m	union:xsens::Itypes	typeref:struct:xsens::Itypes::__anon1	file:
xsens::Itypes::i64	cmtmessage.cpp	/^	int64_t i64;$/;"	m	union:xsens::Itypes	file:
xsens::Itypes::i8	cmtmessage.cpp	/^	} i8;$/;"	m	union:xsens::Itypes	typeref:struct:xsens::Itypes::__anon3	file:
xsens::JanitorClassFunc	xsens_janitors.h	/^class JanitorClassFunc {$/;"	c	namespace:xsens
xsens::JanitorClassFunc::JanitorClassFunc	xsens_janitors.h	/^	JanitorClassFunc<T,R>(T& control, t_func_JanitorClassFunc func, bool enabl = true) :$/;"	f	class:xsens::JanitorClassFunc
xsens::JanitorClassFunc::disable	xsens_janitors.h	/^	void disable(void)$/;"	f	class:xsens::JanitorClassFunc
xsens::JanitorClassFunc::enable	xsens_janitors.h	/^	void enable(void)$/;"	f	class:xsens::JanitorClassFunc
xsens::JanitorClassFunc::m_control	xsens_janitors.h	/^	T& m_control;$/;"	m	class:xsens::JanitorClassFunc
xsens::JanitorClassFunc::m_enabled	xsens_janitors.h	/^	bool m_enabled;$/;"	m	class:xsens::JanitorClassFunc
xsens::JanitorClassFunc::m_funcJCF	xsens_janitors.h	/^	t_func_JanitorClassFunc m_funcJCF;$/;"	m	class:xsens::JanitorClassFunc
xsens::JanitorClassFunc::t_func_JanitorClassFunc	xsens_janitors.h	/^	typedef R (T::*t_func_JanitorClassFunc)(void);$/;"	t	class:xsens::JanitorClassFunc
xsens::JanitorClassFunc::~JanitorClassFunc	xsens_janitors.h	/^	~JanitorClassFunc<T,R>()$/;"	f	class:xsens::JanitorClassFunc
xsens::JanitorClassFuncP1	xsens_janitors.h	/^class JanitorClassFuncP1 {$/;"	c	namespace:xsens
xsens::JanitorClassFuncP1::JanitorClassFuncP1	xsens_janitors.h	/^	JanitorClassFuncP1<T,P1,R>(T& control, P1 p1, t_func_JanitorClassFunc func, bool enabl = true) :$/;"	f	class:xsens::JanitorClassFuncP1
xsens::JanitorClassFuncP1::disable	xsens_janitors.h	/^	void disable(void)$/;"	f	class:xsens::JanitorClassFuncP1
xsens::JanitorClassFuncP1::enable	xsens_janitors.h	/^	void enable(void)$/;"	f	class:xsens::JanitorClassFuncP1
xsens::JanitorClassFuncP1::m_control	xsens_janitors.h	/^	T& m_control;$/;"	m	class:xsens::JanitorClassFuncP1
xsens::JanitorClassFuncP1::m_enabled	xsens_janitors.h	/^	bool m_enabled;$/;"	m	class:xsens::JanitorClassFuncP1
xsens::JanitorClassFuncP1::m_funcJCF	xsens_janitors.h	/^	t_func_JanitorClassFunc m_funcJCF;$/;"	m	class:xsens::JanitorClassFuncP1
xsens::JanitorClassFuncP1::m_param1	xsens_janitors.h	/^	P1 m_param1;$/;"	m	class:xsens::JanitorClassFuncP1
xsens::JanitorClassFuncP1::t_func_JanitorClassFunc	xsens_janitors.h	/^	typedef R (T::*t_func_JanitorClassFunc)(P1);$/;"	t	class:xsens::JanitorClassFuncP1
xsens::JanitorClassFuncP1::~JanitorClassFuncP1	xsens_janitors.h	/^	~JanitorClassFuncP1<T,P1,R>()$/;"	f	class:xsens::JanitorClassFuncP1
xsens::List	xsens_list.h	/^	class List$/;"	c	namespace:xsens
xsens::List::InequalityFunction	xsens_list.h	/^		typedef int32_t (__cdecl * InequalityFunction)(const T&, const T&);$/;"	t	class:xsens::List
xsens::List::List	xsens_list.h	/^List<T>::List()$/;"	f	class:xsens::List
xsens::List::List	xsens_list.h	/^List<T>::List(const List<T>& src)$/;"	f	class:xsens::List
xsens::List::List	xsens_list.h	/^List<T>::List(const uint32_t size, T* src, bool manage)$/;"	f	class:xsens::List
xsens::List::List	xsens_list.h	/^List<T>::List(const uint32_t size, const T* src)$/;"	f	class:xsens::List
xsens::List::List	xsens_list.h	/^List<T>::List(uint32_t size)$/;"	f	class:xsens::List
xsens::List::XSENS_LIST_THROW	xsens_list.h	/^		T& get(const uint32_t index) const XSENS_LIST_THROW;$/;"	m	class:xsens::List
xsens::List::XSENS_LIST_THROW	xsens_list.h	/^		T& last(void) const XSENS_LIST_THROW;$/;"	m	class:xsens::List
xsens::List::XSENS_LIST_THROW	xsens_list.h	/^		T& maxVal(void) const XSENS_LIST_THROW;$/;"	m	class:xsens::List
xsens::List::XSENS_LIST_THROW	xsens_list.h	/^		T& minVal(void) const XSENS_LIST_THROW;$/;"	m	class:xsens::List
xsens::List::XSENS_LIST_THROW	xsens_list.h	/^		T& operator [] (const uint32_t index) const XSENS_LIST_THROW;$/;"	m	class:xsens::List
xsens::List::XSENS_LIST_THROW	xsens_list.h	/^		void deleteAndRemove(const uint32_t index) XSENS_LIST_THROW;$/;"	m	class:xsens::List
xsens::List::XSENS_LIST_THROW	xsens_list.h	/^		void deleteAndRemoveTail(const uint32_t count) XSENS_LIST_THROW;$/;"	m	class:xsens::List
xsens::List::XSENS_LIST_THROW	xsens_list.h	/^		void freeAndRemove(const uint32_t index) XSENS_LIST_THROW;$/;"	m	class:xsens::List
xsens::List::XSENS_LIST_THROW	xsens_list.h	/^		void freeAndRemoveTail(const uint32_t count) XSENS_LIST_THROW;$/;"	m	class:xsens::List
xsens::List::XSENS_LIST_THROW	xsens_list.h	/^		void remove(const uint32_t index) XSENS_LIST_THROW;$/;"	m	class:xsens::List
xsens::List::XSENS_LIST_THROW	xsens_list.h	/^		void removeTail(const uint32_t count) XSENS_LIST_THROW;$/;"	m	class:xsens::List
xsens::List::XSENS_LIST_THROW	xsens_list.h	/^		void swap(const uint32_t i, const uint32_t j) XSENS_LIST_THROW;$/;"	m	class:xsens::List
xsens::List::append	xsens_list.h	/^void List<T>::append(const T& item)$/;"	f	class:xsens::List
xsens::List::appendCopy	xsens_list.h	/^void List<T>::appendCopy(const TB& item)$/;"	f	class:xsens::List
xsens::List::appendDeepCopy	xsens_list.h	/^void List<T>::appendDeepCopy(const List<T>& source)$/;"	f	class:xsens::List
xsens::List::appendList	xsens_list.h	/^void List<T>::appendList(uint32_t count, const T* lst)$/;"	f	class:xsens::List
xsens::List::appendRelated	xsens_list.h	/^void List<T>::appendRelated(const TR& item)$/;"	f	class:xsens::List
xsens::List::appendShallowCopy	xsens_list.h	/^void List<T>::appendShallowCopy(const List<T>& source)$/;"	f	class:xsens::List
xsens::List::clear	xsens_list.h	/^void List<T>::clear(void)$/;"	f	class:xsens::List
xsens::List::cmpFunc	xsens_list.h	/^		typedef int32_t (*cmpFunc) (const T&,const T&);$/;"	t	class:xsens::List
xsens::List::count	xsens_list.h	/^		uint32_t count(void) const { return m_count; }$/;"	f	class:xsens::List
xsens::List::deleteAndClear	xsens_list.h	/^void List<T>::deleteAndClear(void)$/;"	f	class:xsens::List
xsens::List::deleteItemsOnDestroy	xsens_list.h	/^void List<T>::deleteItemsOnDestroy(void)$/;"	f	class:xsens::List
xsens::List::find	xsens_list.h	/^uint32_t List<T>::find(const T item, InequalityFunction fnc) const$/;"	f	class:xsens::List
xsens::List::find	xsens_list.h	/^uint32_t List<T>::find(const TB& item) const$/;"	f	class:xsens::List
xsens::List::findDeref	xsens_list.h	/^uint32_t List<T>::findDeref(const TB& item) const$/;"	f	class:xsens::List
xsens::List::findSorted	xsens_list.h	/^uint32_t List<T>::findSorted(const TB& item) const$/;"	f	class:xsens::List
xsens::List::findSortedDeref	xsens_list.h	/^uint32_t List<T>::findSortedDeref(const TB& item) const$/;"	f	class:xsens::List
xsens::List::findSortedDerefForInsert	xsens_list.h	/^uint32_t List<T>::findSortedDerefForInsert(const TB& item) const$/;"	f	class:xsens::List
xsens::List::findSortedForInsert	xsens_list.h	/^uint32_t List<T>::findSortedForInsert(const TB& item) const$/;"	f	class:xsens::List
xsens::List::freeAndClear	xsens_list.h	/^void List<T>::freeAndClear(void)$/;"	f	class:xsens::List
xsens::List::freeItemsOnDestroy	xsens_list.h	/^void List<T>::freeItemsOnDestroy(void)$/;"	f	class:xsens::List
xsens::List::getBuffer	xsens_list.h	/^		const T* getBuffer(void) const { return m_data; }$/;"	f	class:xsens::List
xsens::List::insert	xsens_list.h	/^void List<T>::insert(const T& item, const uint32_t index)$/;"	f	class:xsens::List
xsens::List::insertCopy	xsens_list.h	/^void List<T>::insertCopy(const TB& item, const uint32_t index)$/;"	f	class:xsens::List
xsens::List::insertSorted	xsens_list.h	/^uint32_t List<T>::insertSorted(const T& item)$/;"	f	class:xsens::List
xsens::List::insertSortedCopy	xsens_list.h	/^uint32_t List<T>::insertSortedCopy(const TB& item)$/;"	f	class:xsens::List
xsens::List::insertSortedDeref	xsens_list.h	/^uint32_t List<T>::insertSortedDeref(const T& item)$/;"	f	class:xsens::List
xsens::List::isDeepCopyOf	xsens_list.h	/^void List<T>::isDeepCopyOf(const List<T>& source)$/;"	f	class:xsens::List
xsens::List::isShallowCopyOf	xsens_list.h	/^void List<T>::isShallowCopyOf(const List<T>& x)$/;"	f	class:xsens::List
xsens::List::length	xsens_list.h	/^		uint32_t length(void) const { return m_count; }$/;"	f	class:xsens::List
xsens::List::m_count	xsens_list.h	/^		uint32_t m_count;				\/\/!< The number of items currently in the list$/;"	m	class:xsens::List
xsens::List::m_data	xsens_list.h	/^		T* m_data;							\/\/!< The array containing the items$/;"	m	class:xsens::List
xsens::List::m_jcf	xsens_list.h	/^		JanitorClassFunc<List<T> >* m_jcf;	\/\/!< Used to clean up the list on exit$/;"	m	class:xsens::List
xsens::List::m_manage	xsens_list.h	/^		bool m_manage;$/;"	m	class:xsens::List
xsens::List::m_max	xsens_list.h	/^		uint32_t m_max;				\/\/!< The current size of the data array$/;"	m	class:xsens::List
xsens::List::operator ==	xsens_list.h	/^bool List<T>::operator == (const List<TB>& lst)$/;"	f	class:xsens::List
xsens::List::qSort	xsens_list.h	/^void List<T>::qSort(uint32_t left, uint32_t right)$/;"	f	class:xsens::List
xsens::List::qSortDeref	xsens_list.h	/^void List<T>::qSortDeref(uint32_t left, uint32_t right)$/;"	f	class:xsens::List
xsens::List::removeDuplicateEntries	xsens_list.h	/^uint32_t List<T>::removeDuplicateEntries(void)$/;"	f	class:xsens::List
xsens::List::removeDuplicateEntriesDeref	xsens_list.h	/^uint32_t List<T>::removeDuplicateEntriesDeref(void)$/;"	f	class:xsens::List
xsens::List::resize	xsens_list.h	/^void List<T>::resize(uint32_t newSize)$/;"	f	class:xsens::List
xsens::List::reverse	xsens_list.h	/^void List<T>::reverse(void)$/;"	f	class:xsens::List
xsens::List::reverseFind	xsens_list.h	/^uint32_t List<T>::reverseFind(const TB& item) const$/;"	f	class:xsens::List
xsens::List::reverseFindDeref	xsens_list.h	/^uint32_t List<T>::reverseFindDeref(const TB& item) const$/;"	f	class:xsens::List
xsens::List::sortAscending	xsens_list.h	/^void List<T>::sortAscending(void)$/;"	f	class:xsens::List
xsens::List::sortAscendingDeref	xsens_list.h	/^void List<T>::sortAscendingDeref(void)$/;"	f	class:xsens::List
xsens::List::twinSortAscending	xsens_list.h	/^void List<T>::twinSortAscending(List<T2>& twin)$/;"	f	class:xsens::List
xsens::List::~List	xsens_list.h	/^List<T>::~List()$/;"	f	class:xsens::List
xsens::Message	cmtmessage.h	/^class Message {$/;"	c	namespace:xsens
xsens::Message::Message	cmtmessage.cpp	/^Message::Message(const Message& src)$/;"	f	class:xsens::Message
xsens::Message::Message	cmtmessage.cpp	/^Message::Message(const uint8_t msgId, const uint16_t length, const uint16_t maxLength)$/;"	f	class:xsens::Message
xsens::Message::Message	cmtmessage.cpp	/^Message::Message(const uint8_t* source, const uint16_t size, const uint16_t maxLength)$/;"	f	class:xsens::Message
xsens::Message::calcChecksum	cmtmessage.h	/^	uint8_t calcChecksum(void) const$/;"	f	class:xsens::Message
xsens::Message::clear	cmtmessage.cpp	/^void Message::clear(void)$/;"	f	class:xsens::Message
xsens::Message::deleteData	cmtmessage.cpp	/^void Message::deleteData(uint16_t size, uint16_t offset)$/;"	f	class:xsens::Message
xsens::Message::getBusId	cmtmessage.h	/^	uint8_t getBusId(void) const { return m_buffer->m_busId; }$/;"	f	class:xsens::Message
xsens::Message::getDataBuffer	cmtmessage.h	/^	const uint8_t* getDataBuffer(const uint16_t offset = 0) const$/;"	f	class:xsens::Message
xsens::Message::getDataBuffer	cmtmessage.h	/^	uint8_t* getDataBuffer(const uint16_t offset = 0)$/;"	f	class:xsens::Message
xsens::Message::getDataByte	cmtmessage.h	/^	uint8_t getDataByte(const uint16_t offset = 0) const$/;"	f	class:xsens::Message
xsens::Message::getDataDouble	cmtmessage.cpp	/^double Message::getDataDouble(const uint16_t offset) const$/;"	f	class:xsens::Message
xsens::Message::getDataF1220	cmtmessage.cpp	/^double Message::getDataF1220(const uint16_t offset) const$/;"	f	class:xsens::Message
xsens::Message::getDataFP1632	cmtmessage.cpp	/^double Message::getDataFP1632(const uint16_t offset) const$/;"	f	class:xsens::Message
xsens::Message::getDataFPValue	cmtmessage.cpp	/^double Message::getDataFPValue(const uint64_t outputSettings, const uint16_t offset) const$/;"	f	class:xsens::Message
xsens::Message::getDataFPValue	cmtmessage.cpp	/^void Message::getDataFPValue(double *dest, const uint64_t outputSettings, uint16_t offset, const int16_t numValues) const$/;"	f	class:xsens::Message
xsens::Message::getDataFloat	cmtmessage.cpp	/^float Message::getDataFloat(const uint16_t offset) const$/;"	f	class:xsens::Message
xsens::Message::getDataLong	cmtmessage.cpp	/^uint32_t Message::getDataLong(const uint16_t offset) const$/;"	f	class:xsens::Message
xsens::Message::getDataShort	cmtmessage.cpp	/^uint16_t Message::getDataShort(const uint16_t offset) const$/;"	f	class:xsens::Message
xsens::Message::getDataSize	cmtmessage.cpp	/^uint16_t Message::getDataSize(void) const$/;"	f	class:xsens::Message
xsens::Message::getDataStart	cmtmessage.cpp	/^uint8_t* Message::getDataStart(void) const$/;"	f	class:xsens::Message
xsens::Message::getMessageId	cmtmessage.h	/^	uint8_t getMessageId(void) const { return m_buffer->m_messageId; }$/;"	f	class:xsens::Message
xsens::Message::getMessageStart	cmtmessage.h	/^	const uint8_t* getMessageStart(void) const$/;"	f	class:xsens::Message
xsens::Message::getTotalMessageSize	cmtmessage.cpp	/^uint16_t Message::getTotalMessageSize(void) const$/;"	f	class:xsens::Message
xsens::Message::insertData	cmtmessage.cpp	/^void Message::insertData(uint16_t size, uint16_t offset)$/;"	f	class:xsens::Message
xsens::Message::isChecksumOk	cmtmessage.cpp	/^bool Message::isChecksumOk(void) const$/;"	f	class:xsens::Message
xsens::Message::loadFromString	cmtmessage.cpp	/^XsensResultValue Message::loadFromString(const uint8_t* source, const uint16_t size)$/;"	f	class:xsens::Message
xsens::Message::m_autoUpdateChecksum	cmtmessage.h	/^	bool m_autoUpdateChecksum;$/;"	m	class:xsens::Message
xsens::Message::m_buffer	cmtmessage.h	/^	MessageHeader* m_buffer;$/;"	m	class:xsens::Message
xsens::Message::m_checksum	cmtmessage.h	/^	uint8_t* m_checksum;$/;"	m	class:xsens::Message
xsens::Message::m_maxLength	cmtmessage.h	/^	uint32_t m_maxLength;$/;"	m	class:xsens::Message
xsens::Message::operator =	cmtmessage.cpp	/^void Message::operator = (const Message& src)$/;"	f	class:xsens::Message
xsens::Message::recomputeChecksum	cmtmessage.h	/^	void recomputeChecksum(void) { m_checksum[0] = calcChecksum(); }$/;"	f	class:xsens::Message
xsens::Message::resizeData	cmtmessage.cpp	/^void Message::resizeData(const uint16_t newSize)$/;"	f	class:xsens::Message
xsens::Message::setBusId	cmtmessage.cpp	/^void Message::setBusId(const uint8_t busId)$/;"	f	class:xsens::Message
xsens::Message::setDataBuffer	cmtmessage.cpp	/^void Message::setDataBuffer(const uint8_t* data, const uint16_t offset,$/;"	f	class:xsens::Message
xsens::Message::setDataByte	cmtmessage.cpp	/^void Message::setDataByte(const uint8_t data, const uint16_t offset)$/;"	f	class:xsens::Message
xsens::Message::setDataDouble	cmtmessage.cpp	/^void Message::setDataDouble(const double data, const uint16_t offset)$/;"	f	class:xsens::Message
xsens::Message::setDataF1220	cmtmessage.cpp	/^void Message::setDataF1220(const double data, const uint16_t offset)$/;"	f	class:xsens::Message
xsens::Message::setDataFP1632	cmtmessage.cpp	/^void Message::setDataFP1632(const double data, const uint16_t offset)$/;"	f	class:xsens::Message
xsens::Message::setDataFPValue	cmtmessage.cpp	/^void Message::setDataFPValue(const uint64_t outputSettings, const double *data, uint16_t offset, const uint16_t numValues)$/;"	f	class:xsens::Message
xsens::Message::setDataFPValue	cmtmessage.cpp	/^void Message::setDataFPValue(const uint64_t outputSettings, const double data, const uint16_t offset)$/;"	f	class:xsens::Message
xsens::Message::setDataFloat	cmtmessage.cpp	/^void Message::setDataFloat(const float data, const uint16_t offset)$/;"	f	class:xsens::Message
xsens::Message::setDataLong	cmtmessage.cpp	/^void Message::setDataLong(const uint32_t data, const uint16_t offset)$/;"	f	class:xsens::Message
xsens::Message::setDataShort	cmtmessage.cpp	/^void Message::setDataShort(const uint16_t data, const uint16_t offset)$/;"	f	class:xsens::Message
xsens::Message::setMessageId	cmtmessage.cpp	/^void Message::setMessageId(const uint8_t msgId)$/;"	f	class:xsens::Message
xsens::Message::~Message	cmtmessage.cpp	/^Message::~Message()$/;"	f	class:xsens::Message
xsens::MessageHeader	cmtmessage.h	/^struct MessageHeader {$/;"	s	namespace:xsens
xsens::MessageHeader::_mdl	cmtmessage.h	/^	union _mdl {$/;"	u	struct:xsens::MessageHeader
xsens::MessageHeader::_mdl::_mextd	cmtmessage.h	/^		struct _mextd {$/;"	s	union:xsens::MessageHeader::_mdl
xsens::MessageHeader::_mdl::_mextd::_mlen	cmtmessage.h	/^			struct _mlen {$/;"	s	struct:xsens::MessageHeader::_mdl::_mextd
xsens::MessageHeader::_mdl::_mextd::_mlen::m_high	cmtmessage.h	/^				uint8_t m_high;$/;"	m	struct:xsens::MessageHeader::_mdl::_mextd::_mlen
xsens::MessageHeader::_mdl::_mextd::_mlen::m_low	cmtmessage.h	/^				uint8_t m_low;$/;"	m	struct:xsens::MessageHeader::_mdl::_mextd::_mlen
xsens::MessageHeader::_mdl::_mextd::m_data	cmtmessage.h	/^			uint8_t m_data[CMT_MAXDATALEN];$/;"	m	struct:xsens::MessageHeader::_mdl::_mextd
xsens::MessageHeader::_mdl::_mextd::m_length	cmtmessage.h	/^			} m_length;$/;"	m	struct:xsens::MessageHeader::_mdl::_mextd	typeref:struct:xsens::MessageHeader::_mdl::_mextd::_mlen
xsens::MessageHeader::_mdl::m_data	cmtmessage.h	/^		uint8_t m_data[254];$/;"	m	union:xsens::MessageHeader::_mdl
xsens::MessageHeader::_mdl::m_extended	cmtmessage.h	/^		} m_extended;$/;"	m	union:xsens::MessageHeader::_mdl	typeref:struct:xsens::MessageHeader::_mdl::_mextd
xsens::MessageHeader::m_busId	cmtmessage.h	/^	uint8_t m_busId;$/;"	m	struct:xsens::MessageHeader
xsens::MessageHeader::m_datlen	cmtmessage.h	/^	} m_datlen;$/;"	m	struct:xsens::MessageHeader	typeref:union:xsens::MessageHeader::_mdl
xsens::MessageHeader::m_length	cmtmessage.h	/^	uint8_t m_length;$/;"	m	struct:xsens::MessageHeader
xsens::MessageHeader::m_messageId	cmtmessage.h	/^	uint8_t m_messageId;$/;"	m	struct:xsens::MessageHeader
xsens::MessageHeader::m_preamble	cmtmessage.h	/^	uint8_t m_preamble;$/;"	m	struct:xsens::MessageHeader
xsens::MillisecondTimer	xsens_time.h	/^class MillisecondTimer$/;"	c	namespace:xsens
xsens::MillisecondTimer::MillisecondTimer	xsens_time.cpp	/^MillisecondTimer::MillisecondTimer()$/;"	f	class:xsens::MillisecondTimer
xsens::MillisecondTimer::m_tstart	xsens_time.h	/^	uint32_t m_tstart;$/;"	m	class:xsens::MillisecondTimer
xsens::MillisecondTimer::millisecondsElapsed	xsens_time.cpp	/^uint32_t MillisecondTimer::millisecondsElapsed()$/;"	f	class:xsens::MillisecondTimer
xsens::MillisecondTimer::restart	xsens_time.cpp	/^void MillisecondTimer::restart()$/;"	f	class:xsens::MillisecondTimer
xsens::Packet	cmtpacket.h	/^class Packet$/;"	c	namespace:xsens
xsens::Packet::Packet	cmtpacket.cpp	/^Packet::Packet(const Packet& pack)$/;"	f	class:xsens::Packet
xsens::Packet::Packet	cmtpacket.cpp	/^Packet::Packet(uint16_t items, bool xbus)$/;"	f	class:xsens::Packet
xsens::Packet::PacketInfo	cmtpacket.h	/^	mutable struct PacketInfo {$/;"	s	class:xsens::Packet
xsens::Packet::PacketInfo::m_acc_g	cmtpacket.h	/^		uint16_t m_acc_g;$/;"	m	struct:xsens::Packet::PacketInfo
xsens::Packet::PacketInfo::m_analogIn1	cmtpacket.h	/^		uint16_t m_analogIn1;$/;"	m	struct:xsens::Packet::PacketInfo
xsens::Packet::PacketInfo::m_analogIn2	cmtpacket.h	/^		uint16_t m_analogIn2;$/;"	m	struct:xsens::Packet::PacketInfo
xsens::Packet::PacketInfo::m_calAcc	cmtpacket.h	/^		uint16_t m_calAcc;$/;"	m	struct:xsens::Packet::PacketInfo
xsens::Packet::PacketInfo::m_calData	cmtpacket.h	/^		uint16_t m_calData;$/;"	m	struct:xsens::Packet::PacketInfo
xsens::Packet::PacketInfo::m_calGyr	cmtpacket.h	/^		uint16_t m_calGyr;$/;"	m	struct:xsens::Packet::PacketInfo
xsens::Packet::PacketInfo::m_calMag	cmtpacket.h	/^		uint16_t m_calMag;$/;"	m	struct:xsens::Packet::PacketInfo
xsens::Packet::PacketInfo::m_doubleBoundary	cmtpacket.h	/^		uint16_t m_doubleBoundary;$/;"	m	struct:xsens::Packet::PacketInfo
xsens::Packet::PacketInfo::m_gpsPvtData	cmtpacket.h	/^		uint16_t m_gpsPvtData;$/;"	m	struct:xsens::Packet::PacketInfo
xsens::Packet::PacketInfo::m_gpsPvtGpsAge	cmtpacket.h	/^		uint16_t m_gpsPvtGpsAge;$/;"	m	struct:xsens::Packet::PacketInfo
xsens::Packet::PacketInfo::m_gpsPvtGpsData	cmtpacket.h	/^		uint16_t m_gpsPvtGpsData;$/;"	m	struct:xsens::Packet::PacketInfo
xsens::Packet::PacketInfo::m_gpsPvtHacc	cmtpacket.h	/^		uint16_t m_gpsPvtHacc;$/;"	m	struct:xsens::Packet::PacketInfo
xsens::Packet::PacketInfo::m_gpsPvtHeight	cmtpacket.h	/^		uint16_t m_gpsPvtHeight;$/;"	m	struct:xsens::Packet::PacketInfo
xsens::Packet::PacketInfo::m_gpsPvtItow	cmtpacket.h	/^		uint16_t m_gpsPvtItow;$/;"	m	struct:xsens::Packet::PacketInfo
xsens::Packet::PacketInfo::m_gpsPvtLatitude	cmtpacket.h	/^		uint16_t m_gpsPvtLatitude;$/;"	m	struct:xsens::Packet::PacketInfo
xsens::Packet::PacketInfo::m_gpsPvtLongitude	cmtpacket.h	/^		uint16_t m_gpsPvtLongitude;$/;"	m	struct:xsens::Packet::PacketInfo
xsens::Packet::PacketInfo::m_gpsPvtPressure	cmtpacket.h	/^		uint16_t m_gpsPvtPressure;$/;"	m	struct:xsens::Packet::PacketInfo
xsens::Packet::PacketInfo::m_gpsPvtPressureAge	cmtpacket.h	/^		uint16_t m_gpsPvtPressureAge;$/;"	m	struct:xsens::Packet::PacketInfo
xsens::Packet::PacketInfo::m_gpsPvtSacc	cmtpacket.h	/^		uint16_t m_gpsPvtSacc;$/;"	m	struct:xsens::Packet::PacketInfo
xsens::Packet::PacketInfo::m_gpsPvtVacc	cmtpacket.h	/^		uint16_t m_gpsPvtVacc;$/;"	m	struct:xsens::Packet::PacketInfo
xsens::Packet::PacketInfo::m_gpsPvtVeld	cmtpacket.h	/^		uint16_t m_gpsPvtVeld;$/;"	m	struct:xsens::Packet::PacketInfo
xsens::Packet::PacketInfo::m_gpsPvtVele	cmtpacket.h	/^		uint16_t m_gpsPvtVele;$/;"	m	struct:xsens::Packet::PacketInfo
xsens::Packet::PacketInfo::m_gpsPvtVeln	cmtpacket.h	/^		uint16_t m_gpsPvtVeln;$/;"	m	struct:xsens::Packet::PacketInfo
xsens::Packet::PacketInfo::m_offset	cmtpacket.h	/^		uint16_t m_offset;$/;"	m	struct:xsens::Packet::PacketInfo
xsens::Packet::PacketInfo::m_oriEul	cmtpacket.h	/^		uint16_t m_oriEul;$/;"	m	struct:xsens::Packet::PacketInfo
xsens::Packet::PacketInfo::m_oriMat	cmtpacket.h	/^		uint16_t m_oriMat;$/;"	m	struct:xsens::Packet::PacketInfo
xsens::Packet::PacketInfo::m_oriQuat	cmtpacket.h	/^		uint16_t m_oriQuat;$/;"	m	struct:xsens::Packet::PacketInfo
xsens::Packet::PacketInfo::m_posLLA	cmtpacket.h	/^		uint16_t m_posLLA;$/;"	m	struct:xsens::Packet::PacketInfo
xsens::Packet::PacketInfo::m_rawAcc	cmtpacket.h	/^		uint16_t m_rawAcc;$/;"	m	struct:xsens::Packet::PacketInfo
xsens::Packet::PacketInfo::m_rawData	cmtpacket.h	/^		uint16_t m_rawData;$/;"	m	struct:xsens::Packet::PacketInfo
xsens::Packet::PacketInfo::m_rawGyr	cmtpacket.h	/^		uint16_t m_rawGyr;$/;"	m	struct:xsens::Packet::PacketInfo
xsens::Packet::PacketInfo::m_rawMag	cmtpacket.h	/^		uint16_t m_rawMag;$/;"	m	struct:xsens::Packet::PacketInfo
xsens::Packet::PacketInfo::m_rawTemp	cmtpacket.h	/^		uint16_t m_rawTemp;$/;"	m	struct:xsens::Packet::PacketInfo
xsens::Packet::PacketInfo::m_sc	cmtpacket.h	/^		uint16_t m_sc;$/;"	m	struct:xsens::Packet::PacketInfo
xsens::Packet::PacketInfo::m_size	cmtpacket.h	/^		uint16_t m_size;$/;"	m	struct:xsens::Packet::PacketInfo
xsens::Packet::PacketInfo::m_status	cmtpacket.h	/^		uint16_t m_status;$/;"	m	struct:xsens::Packet::PacketInfo
xsens::Packet::PacketInfo::m_temp	cmtpacket.h	/^		uint16_t m_temp;$/;"	m	struct:xsens::Packet::PacketInfo
xsens::Packet::PacketInfo::m_utcDay	cmtpacket.h	/^		uint16_t m_utcDay;$/;"	m	struct:xsens::Packet::PacketInfo
xsens::Packet::PacketInfo::m_utcHour	cmtpacket.h	/^		uint16_t m_utcHour;$/;"	m	struct:xsens::Packet::PacketInfo
xsens::Packet::PacketInfo::m_utcMinute	cmtpacket.h	/^		uint16_t m_utcMinute;$/;"	m	struct:xsens::Packet::PacketInfo
xsens::Packet::PacketInfo::m_utcMonth	cmtpacket.h	/^		uint16_t m_utcMonth;$/;"	m	struct:xsens::Packet::PacketInfo
xsens::Packet::PacketInfo::m_utcNano	cmtpacket.h	/^		uint16_t m_utcNano;$/;"	m	struct:xsens::Packet::PacketInfo
xsens::Packet::PacketInfo::m_utcSecond	cmtpacket.h	/^		uint16_t m_utcSecond;$/;"	m	struct:xsens::Packet::PacketInfo
xsens::Packet::PacketInfo::m_utcTime	cmtpacket.h	/^		uint16_t m_utcTime;$/;"	m	struct:xsens::Packet::PacketInfo
xsens::Packet::PacketInfo::m_utcValid	cmtpacket.h	/^		uint16_t m_utcValid;$/;"	m	struct:xsens::Packet::PacketInfo
xsens::Packet::PacketInfo::m_utcYear	cmtpacket.h	/^		uint16_t m_utcYear;$/;"	m	struct:xsens::Packet::PacketInfo
xsens::Packet::PacketInfo::m_velNEDorNWU	cmtpacket.h	/^		uint16_t m_velNEDorNWU;$/;"	m	struct:xsens::Packet::PacketInfo
xsens::Packet::containsAccG	cmtpacket.cpp	/^bool Packet::containsAccG(const uint16_t index) const$/;"	f	class:xsens::Packet
xsens::Packet::containsAnalogIn1	cmtpacket.cpp	/^bool Packet::containsAnalogIn1(const uint16_t index) const$/;"	f	class:xsens::Packet
xsens::Packet::containsAnalogIn2	cmtpacket.cpp	/^bool Packet::containsAnalogIn2(const uint16_t index) const$/;"	f	class:xsens::Packet
xsens::Packet::containsCalAcc	cmtpacket.cpp	/^bool Packet::containsCalAcc(const uint16_t index) const$/;"	f	class:xsens::Packet
xsens::Packet::containsCalData	cmtpacket.cpp	/^bool Packet::containsCalData(const uint16_t index) const$/;"	f	class:xsens::Packet
xsens::Packet::containsCalGyr	cmtpacket.cpp	/^bool Packet::containsCalGyr(const uint16_t index) const$/;"	f	class:xsens::Packet
xsens::Packet::containsCalMag	cmtpacket.cpp	/^bool Packet::containsCalMag(const uint16_t index) const$/;"	f	class:xsens::Packet
xsens::Packet::containsGpsPvtData	cmtpacket.cpp	/^bool Packet::containsGpsPvtData(const uint16_t index) const$/;"	f	class:xsens::Packet
xsens::Packet::containsOri	cmtpacket.cpp	/^bool Packet::containsOri(const uint16_t index) const$/;"	f	class:xsens::Packet
xsens::Packet::containsOriEuler	cmtpacket.cpp	/^bool Packet::containsOriEuler(const uint16_t index) const$/;"	f	class:xsens::Packet
xsens::Packet::containsOriMatrix	cmtpacket.cpp	/^bool Packet::containsOriMatrix(const uint16_t index) const$/;"	f	class:xsens::Packet
xsens::Packet::containsOriQuat	cmtpacket.cpp	/^bool Packet::containsOriQuat(const uint16_t index) const$/;"	f	class:xsens::Packet
xsens::Packet::containsPositionLLA	cmtpacket.cpp	/^bool Packet::containsPositionLLA(const uint16_t index) const$/;"	f	class:xsens::Packet
xsens::Packet::containsRawAcc	cmtpacket.cpp	/^bool Packet::containsRawAcc(const uint16_t index) const$/;"	f	class:xsens::Packet
xsens::Packet::containsRawData	cmtpacket.cpp	/^bool Packet::containsRawData(const uint16_t index) const$/;"	f	class:xsens::Packet
xsens::Packet::containsRawGyr	cmtpacket.cpp	/^bool Packet::containsRawGyr(const uint16_t index) const$/;"	f	class:xsens::Packet
xsens::Packet::containsRawMag	cmtpacket.cpp	/^bool Packet::containsRawMag(const uint16_t index) const$/;"	f	class:xsens::Packet
xsens::Packet::containsRawPressureData	cmtpacket.cpp	/^bool Packet::containsRawPressureData(const uint16_t index) const$/;"	f	class:xsens::Packet
xsens::Packet::containsRawTemp	cmtpacket.cpp	/^bool Packet::containsRawTemp(const uint16_t index) const$/;"	f	class:xsens::Packet
xsens::Packet::containsSampleCounter	cmtpacket.cpp	/^bool Packet::containsSampleCounter(const uint16_t index) const$/;"	f	class:xsens::Packet
xsens::Packet::containsStatus	cmtpacket.cpp	/^bool Packet::containsStatus(const uint16_t index) const$/;"	f	class:xsens::Packet
xsens::Packet::containsTemp	cmtpacket.cpp	/^bool Packet::containsTemp(const uint16_t index) const$/;"	f	class:xsens::Packet
xsens::Packet::containsUtcTime	cmtpacket.cpp	/^bool Packet::containsUtcTime(const uint16_t index) const$/;"	f	class:xsens::Packet
xsens::Packet::containsVelocity	cmtpacket.cpp	/^bool Packet::containsVelocity(const uint16_t index) const$/;"	f	class:xsens::Packet
xsens::Packet::getAccG	cmtpacket.cpp	/^CmtVector Packet::getAccG(const uint16_t index) const$/;"	f	class:xsens::Packet
xsens::Packet::getAnalogIn1	cmtpacket.cpp	/^CmtAnalogInData Packet::getAnalogIn1(const uint16_t index) const$/;"	f	class:xsens::Packet
xsens::Packet::getAnalogIn2	cmtpacket.cpp	/^CmtAnalogInData Packet::getAnalogIn2(const uint16_t index) const$/;"	f	class:xsens::Packet
xsens::Packet::getCalAcc	cmtpacket.cpp	/^CmtVector Packet::getCalAcc(const uint16_t index) const$/;"	f	class:xsens::Packet
xsens::Packet::getCalData	cmtpacket.cpp	/^CmtCalData Packet::getCalData(const uint16_t index) const$/;"	f	class:xsens::Packet
xsens::Packet::getCalGyr	cmtpacket.cpp	/^CmtVector Packet::getCalGyr(const uint16_t index) const$/;"	f	class:xsens::Packet
xsens::Packet::getCalMag	cmtpacket.cpp	/^CmtVector Packet::getCalMag(const uint16_t index) const$/;"	f	class:xsens::Packet
xsens::Packet::getDataFormat	cmtpacket.cpp	/^CmtDataFormat Packet::getDataFormat(const uint16_t index) const$/;"	f	class:xsens::Packet
xsens::Packet::getDataSize	cmtpacket.cpp	/^uint16_t Packet::getDataSize(const uint16_t index) const$/;"	f	class:xsens::Packet
xsens::Packet::getFPValueSize	cmtpacket.cpp	/^uint16_t Packet::getFPValueSize(const uint16_t index) const$/;"	f	class:xsens::Packet
xsens::Packet::getGpsPvtData	cmtpacket.cpp	/^CmtGpsPvtData Packet::getGpsPvtData(const uint16_t index) const$/;"	f	class:xsens::Packet
xsens::Packet::getOriEuler	cmtpacket.cpp	/^CmtEuler Packet::getOriEuler(const uint16_t index) const$/;"	f	class:xsens::Packet
xsens::Packet::getOriMatrix	cmtpacket.cpp	/^CmtMatrix Packet::getOriMatrix(const uint16_t index) const$/;"	f	class:xsens::Packet
xsens::Packet::getOriQuat	cmtpacket.cpp	/^CmtQuat Packet::getOriQuat(const uint16_t index) const$/;"	f	class:xsens::Packet
xsens::Packet::getPositionLLA	cmtpacket.cpp	/^CmtVector Packet::getPositionLLA(const uint16_t index) const$/;"	f	class:xsens::Packet
xsens::Packet::getRawAcc	cmtpacket.cpp	/^CmtShortVector Packet::getRawAcc(const uint16_t index) const$/;"	f	class:xsens::Packet
xsens::Packet::getRawData	cmtpacket.cpp	/^CmtRawData Packet::getRawData(const uint16_t index) const$/;"	f	class:xsens::Packet
xsens::Packet::getRawGyr	cmtpacket.cpp	/^CmtShortVector Packet::getRawGyr(const uint16_t index) const$/;"	f	class:xsens::Packet
xsens::Packet::getRawMag	cmtpacket.cpp	/^CmtShortVector Packet::getRawMag(const uint16_t index) const$/;"	f	class:xsens::Packet
xsens::Packet::getRawPressureData	cmtpacket.cpp	/^CmtRawPressureData Packet::getRawPressureData(const uint16_t index) const$/;"	f	class:xsens::Packet
xsens::Packet::getRawTemp	cmtpacket.cpp	/^uint16_t Packet::getRawTemp(const uint16_t index) const$/;"	f	class:xsens::Packet
xsens::Packet::getRtc	cmtpacket.cpp	/^TimeStamp Packet::getRtc(const uint16_t index) const$/;"	f	class:xsens::Packet
xsens::Packet::getSampleCounter	cmtpacket.cpp	/^uint16_t Packet::getSampleCounter(const uint16_t index) const$/;"	f	class:xsens::Packet
xsens::Packet::getStatus	cmtpacket.cpp	/^uint8_t Packet::getStatus(const uint16_t index) const$/;"	f	class:xsens::Packet
xsens::Packet::getTemp	cmtpacket.cpp	/^double Packet::getTemp(const uint16_t index) const$/;"	f	class:xsens::Packet
xsens::Packet::getUtcTime	cmtpacket.cpp	/^CmtUtcTime Packet::getUtcTime(const uint16_t index) const$/;"	f	class:xsens::Packet
xsens::Packet::getVelocity	cmtpacket.cpp	/^CmtVector Packet::getVelocity(const uint16_t index) const$/;"	f	class:xsens::Packet
xsens::Packet::getXbus	cmtpacket.cpp	/^bool Packet::getXbus(void) const$/;"	f	class:xsens::Packet
xsens::Packet::m_formatList	cmtpacket.h	/^	CmtDataFormat*	m_formatList;	\/\/!< A list of the formats of the data items$/;"	m	class:xsens::Packet
xsens::Packet::m_infoList	cmtpacket.h	/^	}*	m_infoList;$/;"	m	class:xsens::Packet	typeref:struct:xsens::Packet::PacketInfo
xsens::Packet::m_itemCount	cmtpacket.h	/^	uint16_t		m_itemCount;	\/\/!< The number of data items in the message$/;"	m	class:xsens::Packet
xsens::Packet::m_msg	cmtpacket.h	/^	Message			m_msg;			\/\/!< The message$/;"	m	class:xsens::Packet
xsens::Packet::m_rtc	cmtpacket.h	/^	TimeStamp		m_rtc;			\/\/!< Sample time in ms, based on the sample counter$/;"	m	class:xsens::Packet
xsens::Packet::m_toa	cmtpacket.h	/^	TimeStamp		m_toa;			\/\/!< Time of arrival$/;"	m	class:xsens::Packet
xsens::Packet::m_xm	cmtpacket.h	/^	bool m_xm;						\/\/!< Indicates that xbus-formatting is used$/;"	m	class:xsens::Packet
xsens::Packet::operator =	cmtpacket.cpp	/^void Packet::operator = (const Packet& pack)$/;"	f	class:xsens::Packet
xsens::Packet::setDataFormat	cmtpacket.cpp	/^bool Packet::setDataFormat(const CmtDataFormat& format, const uint16_t index)$/;"	f	class:xsens::Packet
xsens::Packet::setDataFormat	cmtpacket.cpp	/^bool Packet::setDataFormat(const CmtOutputMode outputMode, const CmtOutputSettings outputSettings, const uint16_t index)$/;"	f	class:xsens::Packet
xsens::Packet::setXbus	cmtpacket.cpp	/^void Packet::setXbus(bool xbus, bool convert)$/;"	f	class:xsens::Packet
xsens::Packet::updateAccG	cmtpacket.cpp	/^bool Packet::updateAccG(const CmtVector& g, const uint16_t index)$/;"	f	class:xsens::Packet
xsens::Packet::updateAnalogIn1	cmtpacket.cpp	/^bool Packet::updateAnalogIn1(const CmtAnalogInData& data, const uint16_t index)$/;"	f	class:xsens::Packet
xsens::Packet::updateAnalogIn2	cmtpacket.cpp	/^bool Packet::updateAnalogIn2(const CmtAnalogInData& data, const uint16_t index)$/;"	f	class:xsens::Packet
xsens::Packet::updateCalAcc	cmtpacket.cpp	/^bool Packet::updateCalAcc(const CmtVector& vec, const uint16_t index)$/;"	f	class:xsens::Packet
xsens::Packet::updateCalData	cmtpacket.cpp	/^bool Packet::updateCalData(const CmtCalData& data, const uint16_t index)$/;"	f	class:xsens::Packet
xsens::Packet::updateCalGyr	cmtpacket.cpp	/^bool Packet::updateCalGyr(const CmtVector& vec, const uint16_t index)$/;"	f	class:xsens::Packet
xsens::Packet::updateCalMag	cmtpacket.cpp	/^bool Packet::updateCalMag(const CmtVector& vec, const uint16_t index)$/;"	f	class:xsens::Packet
xsens::Packet::updateGpsPvtData	cmtpacket.cpp	/^bool Packet::updateGpsPvtData(const CmtGpsPvtData& data, const uint16_t index)$/;"	f	class:xsens::Packet
xsens::Packet::updateOriEuler	cmtpacket.cpp	/^bool Packet::updateOriEuler(const CmtEuler& data, const uint16_t index)$/;"	f	class:xsens::Packet
xsens::Packet::updateOriMatrix	cmtpacket.cpp	/^bool Packet::updateOriMatrix(const CmtMatrix& data, const uint16_t index)$/;"	f	class:xsens::Packet
xsens::Packet::updateOriQuat	cmtpacket.cpp	/^bool Packet::updateOriQuat(const CmtQuat& data, const uint16_t index)$/;"	f	class:xsens::Packet
xsens::Packet::updatePositionLLA	cmtpacket.cpp	/^bool Packet::updatePositionLLA(const CmtVector& data, const uint16_t index)$/;"	f	class:xsens::Packet
xsens::Packet::updateRawAcc	cmtpacket.cpp	/^bool Packet::updateRawAcc(const CmtShortVector& vec, const uint16_t index)$/;"	f	class:xsens::Packet
xsens::Packet::updateRawData	cmtpacket.cpp	/^bool Packet::updateRawData(const CmtRawData& data, const uint16_t index)$/;"	f	class:xsens::Packet
xsens::Packet::updateRawGyr	cmtpacket.cpp	/^bool Packet::updateRawGyr(const CmtShortVector& vec, const uint16_t index)$/;"	f	class:xsens::Packet
xsens::Packet::updateRawMag	cmtpacket.cpp	/^bool Packet::updateRawMag(const CmtShortVector& vec, const uint16_t index)$/;"	f	class:xsens::Packet
xsens::Packet::updateRawPressureData	cmtpacket.cpp	/^bool Packet::updateRawPressureData(const CmtRawPressureData& data, const uint16_t index)$/;"	f	class:xsens::Packet
xsens::Packet::updateRawTemp	cmtpacket.cpp	/^bool Packet::updateRawTemp(const uint16_t temp, const uint16_t index)$/;"	f	class:xsens::Packet
xsens::Packet::updateSampleCounter	cmtpacket.cpp	/^bool Packet::updateSampleCounter(const uint16_t counter, const uint16_t index)$/;"	f	class:xsens::Packet
xsens::Packet::updateStatus	cmtpacket.cpp	/^bool Packet::updateStatus(const uint8_t data, const uint16_t index)$/;"	f	class:xsens::Packet
xsens::Packet::updateTemp	cmtpacket.cpp	/^bool Packet::updateTemp(const double& temp, const uint16_t index)$/;"	f	class:xsens::Packet
xsens::Packet::updateUtcTime	cmtpacket.cpp	/^bool Packet::updateUtcTime(const CmtUtcTime& data, const uint16_t index)$/;"	f	class:xsens::Packet
xsens::Packet::updateVelocity	cmtpacket.cpp	/^bool Packet::updateVelocity(const CmtVector& data, const uint16_t index)$/;"	f	class:xsens::Packet
xsens::Packet::~Packet	cmtpacket.cpp	/^Packet::~Packet()$/;"	f	class:xsens::Packet
xsens::TimeStamp	xsens_time.h	/^typedef int64_t TimeStamp;$/;"	t	namespace:xsens
xsens::TimeSync	xsens_time.h	/^class TimeSync {$/;"	c	namespace:xsens
xsens::TimeSync::TimeSync	xsens_time.cpp	/^TimeSync::TimeSync(double skew, int historySize)$/;"	f	class:xsens::TimeSync
xsens::TimeSync::d	xsens_time.h	/^	TimeSyncPrivate* d;$/;"	m	class:xsens::TimeSync
xsens::TimeSync::externalTime	xsens_time.cpp	/^TimeStamp TimeSync::externalTime(TimeStamp tLi)$/;"	f	class:xsens::TimeSync
xsens::TimeSync::isInitialized	xsens_time.cpp	/^int TimeSync::isInitialized() const$/;"	f	class:xsens::TimeSync
xsens::TimeSync::localTime	xsens_time.cpp	/^TimeStamp TimeSync::localTime(TimeStamp tMi)$/;"	f	class:xsens::TimeSync
xsens::TimeSync::reset	xsens_time.cpp	/^void TimeSync::reset()$/;"	f	class:xsens::TimeSync
xsens::TimeSync::setInitialSkew	xsens_time.cpp	/^void TimeSync::setInitialSkew(double skew)$/;"	f	class:xsens::TimeSync
xsens::TimeSync::update	xsens_time.cpp	/^void TimeSync::update(TimeStamp local, TimeStamp external)$/;"	f	class:xsens::TimeSync
xsens::TimeSync::~TimeSync	xsens_time.cpp	/^TimeSync::~TimeSync()$/;"	f	class:xsens::TimeSync
xsens::TimeSyncHistoryUnit	xsens_time.cpp	/^struct TimeSyncHistoryUnit {$/;"	s	namespace:xsens	file:
xsens::TimeSyncHistoryUnit::tCR	xsens_time.cpp	/^	double tS, tR, tCR;$/;"	m	struct:xsens::TimeSyncHistoryUnit	file:
xsens::TimeSyncHistoryUnit::tR	xsens_time.cpp	/^	double tS, tR, tCR;$/;"	m	struct:xsens::TimeSyncHistoryUnit	file:
xsens::TimeSyncHistoryUnit::tS	xsens_time.cpp	/^	double tS, tR, tCR;$/;"	m	struct:xsens::TimeSyncHistoryUnit	file:
xsens::TimeSyncPrivate	xsens_time.cpp	/^class TimeSyncPrivate {$/;"	c	namespace:xsens	file:
xsens::TimeSyncPrivate::addHistoryItem	xsens_time.cpp	/^void TimeSyncPrivate::addHistoryItem(const TimeSyncHistoryUnit& tu)$/;"	f	class:xsens::TimeSyncPrivate
xsens::TimeSyncPrivate::firstIndex	xsens_time.cpp	/^int TimeSyncPrivate::firstIndex() const$/;"	f	class:xsens::TimeSyncPrivate
xsens::TimeSyncPrivate::historyMax	xsens_time.cpp	/^double TimeSyncPrivate::historyMax() const$/;"	f	class:xsens::TimeSyncPrivate
xsens::TimeSyncPrivate::lastIndex	xsens_time.cpp	/^int TimeSyncPrivate::lastIndex() const$/;"	f	class:xsens::TimeSyncPrivate
xsens::TimeSyncPrivate::m_C	xsens_time.cpp	/^	double m_C;				\/\/!< Stability factor (lower is more stable)$/;"	m	class:xsens::TimeSyncPrivate	file:
xsens::TimeSyncPrivate::m_a	xsens_time.cpp	/^	double m_a;				\/\/!< Fuzzy factor$/;"	m	class:xsens::TimeSyncPrivate	file:
xsens::TimeSyncPrivate::m_correction	xsens_time.cpp	/^	double m_correction;		\/\/!< Last known correction value computed from the history$/;"	m	class:xsens::TimeSyncPrivate	file:
xsens::TimeSyncPrivate::m_history	xsens_time.cpp	/^	TimeSyncHistoryUnit* m_history;		\/\/!< The time sync history buffer, implemented as a circular buffer$/;"	m	class:xsens::TimeSyncPrivate	file:
xsens::TimeSyncPrivate::m_historyCount	xsens_time.cpp	/^	int m_historyCount;			\/\/!< Items currently in the history$/;"	m	class:xsens::TimeSyncPrivate	file:
xsens::TimeSyncPrivate::m_historyIndex	xsens_time.cpp	/^	int m_historyIndex;			\/\/!< Index of the next item to write in the history (in a full history this is also the oldest item index)$/;"	m	class:xsens::TimeSyncPrivate	file:
xsens::TimeSyncPrivate::m_historyMaxIndex	xsens_time.cpp	/^	int m_historyMaxIndex;		\/\/!< Index of the maximum tCR value in the history$/;"	m	class:xsens::TimeSyncPrivate	file:
xsens::TimeSyncPrivate::m_historySize	xsens_time.cpp	/^	int m_historySize;		\/\/!< The number of items stored in the history$/;"	m	class:xsens::TimeSyncPrivate	file:
xsens::TimeSyncPrivate::m_initialSkew	xsens_time.cpp	/^	double m_initialSkew;	\/\/!< Initial skew to apply. When 0, the skew will be estimated automatically.$/;"	m	class:xsens::TimeSyncPrivate	file:
xsens::TimeSyncPrivate::m_initialized	xsens_time.cpp	/^	bool m_initialized;			\/\/!< Whether an initial estimate has been made and the normal time sync estimation can take place$/;"	m	class:xsens::TimeSyncPrivate	file:
xsens::TimeSyncPrivate::m_outlierDelta	xsens_time.cpp	/^	double m_outlierDelta;		\/\/!< Used to move m_outlierThreshold up or down (lower value is less movement)$/;"	m	class:xsens::TimeSyncPrivate	file:
xsens::TimeSyncPrivate::m_outlierThreshold	xsens_time.cpp	/^	double m_outlierThreshold;	\/\/!< Dynamic threshold for detecting outliers in the update function$/;"	m	class:xsens::TimeSyncPrivate	file:
xsens::TimeSyncPrivate::m_quickSkewWindow	xsens_time.cpp	/^	int m_quickSkewWindow;	\/\/!< The number of steps to apply the quick skew estimation algorithm$/;"	m	class:xsens::TimeSyncPrivate	file:
xsens::TimeSyncPrivate::m_skew	xsens_time.cpp	/^	double m_skew;			\/\/!< Last known computed skew$/;"	m	class:xsens::TimeSyncPrivate	file:
xsens::TimeSyncPrivate::m_tC	xsens_time.cpp	/^	double m_tC;				\/\/!< Last known computed time value, used in update and time conversion functions$/;"	m	class:xsens::TimeSyncPrivate	file:
xsens::TimeSyncPrivate::m_tMc	xsens_time.cpp	/^	double m_tMc;				\/\/!< Linearization point for the xsens::TimeSync::localTime and xsens::TimeSync::externalTime functions$/;"	m	class:xsens::TimeSyncPrivate	file:
xsens::TimeSyncPrivate::m_tR0	xsens_time.cpp	/^	TimeStamp m_tR0;		\/\/!< Linearization point for R (local) values$/;"	m	class:xsens::TimeSyncPrivate	file:
xsens::TimeSyncPrivate::m_tS0	xsens_time.cpp	/^	TimeStamp m_tS0;		\/\/!< Linearization point for S (external) values$/;"	m	class:xsens::TimeSyncPrivate	file:
xsens::_wcsnicmp	cmt1.cpp	/^int _wcsnicmp(const wchar_t* s1, const wchar_t* s2,int count)$/;"	f	namespace:xsens
xsens::abortScan	cmtscan.cpp	/^bool abortScan = false;$/;"	m	namespace:xsens	file:
xsens::clock_gettime	xsens_time.cpp	/^static int clock_gettime(int clk_id, struct timespec *tp)$/;"	f	namespace:xsens
xsens::cmtScanPort	cmtscan.cpp	/^bool cmtScanPort(CmtPortInfo& portInfo, uint32_t baud, uint32_t singleScanTimeout, uint32_t scanTries)$/;"	f	namespace:xsens
xsens::cmtScanPorts	cmtscan.cpp	/^bool cmtScanPorts(List<CmtPortInfo>& ports,uint32_t baudrate, uint32_t singleScanTimeout, uint32_t scanTries, bool ignoreNonXsensDevices)$/;"	f	namespace:xsens
xsens::computeChecksum	cmtmessage.cpp	/^uint8_t computeChecksum(const uint8_t* buffer, uint32_t length)$/;"	f	namespace:xsens
xsens::debug_log_fp	cmt1.cpp	/^			FILE* debug_log_fp = NULL;$/;"	m	namespace:xsens	file:
xsens::debug_log_valid	cmt1.cpp	/^			int32_t debug_log_valid = 0;$/;"	m	namespace:xsens	file:
xsens::debug_qlog_fp	cmt1.cpp	/^			FILE* debug_qlog_fp = NULL;$/;"	m	namespace:xsens	file:
xsens::debug_qlog_valid	cmt1.cpp	/^			int32_t debug_qlog_valid = 0;$/;"	m	namespace:xsens	file:
xsens::findValidMessage	cmt2.cpp	/^int32_t findValidMessage(const uint8_t* buffer, const uint16_t bufferLength)$/;"	f	namespace:xsens
xsens::getDateAsString	xsens_time.cpp	/^void getDateAsString(uint8_t *dest, const tm* date)$/;"	f	namespace:xsens
xsens::getDateTime	xsens_time.cpp	/^int64_t getDateTime(tm *date)$/;"	f	namespace:xsens
xsens::getTimeAsString	xsens_time.cpp	/^void getTimeAsString(uint8_t *dest, const tm* date)$/;"	f	namespace:xsens
xsens::getTimeOfDay	xsens_time.cpp	/^uint32_t getTimeOfDay(tm* date_, time_t* secs_)$/;"	f	namespace:xsens
xsens::initializeTime	xsens_time.cpp	/^void initializeTime()$/;"	f	namespace:xsens
xsens::msleep	xsens_time.cpp	/^void msleep(uint32_t ms)$/;"	f	namespace:xsens
xsens::timeStampNow	xsens_time.cpp	/^TimeStamp timeStampNow()$/;"	f	namespace:xsens
xsensResultText	xsens_std.cpp	/^const char* xsensResultText(const XsensResultValue result)$/;"	f
~Cmt1f	cmt1.cpp	/^Cmt1f::~Cmt1f()$/;"	f	class:xsens::Cmt1f
~Cmt1s	cmt1.cpp	/^Cmt1s::~Cmt1s()$/;"	f	class:xsens::Cmt1s
~Cmt2f	cmt2.cpp	/^Cmt2f::~Cmt2f()$/;"	f	class:xsens::Cmt2f
~Cmt2s	cmt2.cpp	/^Cmt2s::~Cmt2s()$/;"	f	class:xsens::Cmt2s
~Cmt3	cmt3.cpp	/^Cmt3::~Cmt3()$/;"	f	class:xsens::Cmt3
~Exception	xsens_exception.cpp	/^Exception::~Exception() throw()$/;"	f	class:xsens::Exception
~FifoQueue	xsens_fifoqueue.h	/^	~FifoQueue()$/;"	f	class:xsens::FifoQueue
~FifoQueueBasic	xsens_fifoqueue.h	/^	~FifoQueueBasic()$/;"	f	class:xsens::FifoQueueBasic
~JanitorClassFunc	xsens_janitors.h	/^	~JanitorClassFunc<T,R>()$/;"	f	class:xsens::JanitorClassFunc
~JanitorClassFuncP1	xsens_janitors.h	/^	~JanitorClassFuncP1<T,P1,R>()$/;"	f	class:xsens::JanitorClassFuncP1
~List	xsens_list.h	/^List<T>::~List()$/;"	f	class:xsens::List
~Message	cmtmessage.cpp	/^Message::~Message()$/;"	f	class:xsens::Message
~Packet	cmtpacket.cpp	/^Packet::~Packet()$/;"	f	class:xsens::Packet
~TimeSync	xsens_time.cpp	/^TimeSync::~TimeSync()$/;"	f	class:xsens::TimeSync
